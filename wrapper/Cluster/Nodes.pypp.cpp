// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 2 License

#include "boost/python.hpp"
#include "Nodes.pypp.hpp"

namespace bp = boost::python;

#include "SireError/errors.h"

#include "SireError/printerror.h"

#include "backend.h"

#include "cluster.h"

#include "frontend.h"

#include "node.h"

#include "nodes.h"

#include <QDebug>

#include <QElapsedTimer>

#include <QHash>

#include <QList>

#include <QMutex>

#include <QSemaphore>

#include <QSet>

#include <QThreadStorage>

#include <QUuid>

#include <QWaitCondition>

#include "nodes.h"

SireCluster::Nodes __copy__(const SireCluster::Nodes &other){ return SireCluster::Nodes(other); }

#include "Helpers/str.hpp"

#include "Helpers/release_gil_policy.hpp"

#include "Helpers/len.hpp"

void register_Nodes_class(){

    { //::SireCluster::Nodes
        typedef bp::class_< SireCluster::Nodes > Nodes_exposer_t;
        Nodes_exposer_t Nodes_exposer = Nodes_exposer_t( "Nodes", "This class holds, and schedules, a collection of Node objects.\n\nAuthor: Christopher Woods\n", bp::init< >("Construct an empty set of nodes") );
        bp::scope Nodes_scope( Nodes_exposer );
        Nodes_exposer.def( bp::init< SireCluster::Nodes const & >(( bp::arg("other") ), "Copy constructor - Nodes are explicitly shared") );
        { //::SireCluster::Nodes::add
        
            typedef void ( ::SireCluster::Nodes::*add_function_type)( ::SireCluster::Node ) ;
            add_function_type add_function_value( &::SireCluster::Nodes::add );
            
            Nodes_exposer.def( 
                "add"
                , add_function_value
                , ( bp::arg("node") )
                , bp::release_gil_policy()
                , "Add the node node to this set. This will be added as a busy\nNode (as obviously someone is holding onto it) This does\nnothing if this node is already part of this set" );
        
        }
        { //::SireCluster::Nodes::add
        
            typedef void ( ::SireCluster::Nodes::*add_function_type)( ::SireCluster::Nodes & ) ;
            add_function_type add_function_value( &::SireCluster::Nodes::add );
            
            Nodes_exposer.def( 
                "add"
                , add_function_value
                , ( bp::arg("nodes") )
                , bp::release_gil_policy()
                , "Add all of the nodes in nodes to this set" );
        
        }
        { //::SireCluster::Nodes::addNode
        
            typedef void ( ::SireCluster::Nodes::*addNode_function_type)(  ) ;
            addNode_function_type addNode_function_value( &::SireCluster::Nodes::addNode );
            
            Nodes_exposer.def( 
                "addNode"
                , addNode_function_value
                , bp::release_gil_policy()
                , "Try to add one more node to this set by taking a node from the\npool - this only looks for immediately available nodes, and may\nnot work" );
        
        }
        { //::SireCluster::Nodes::addNode
        
            typedef void ( ::SireCluster::Nodes::*addNode_function_type)( int ) ;
            addNode_function_type addNode_function_value( &::SireCluster::Nodes::addNode );
            
            Nodes_exposer.def( 
                "addNode"
                , addNode_function_value
                , ( bp::arg("timeout") )
                , bp::release_gil_policy()
                , "Try to add one more node to this set by taking a node from the\npool - this only tries to find an available node for\ntimeout milliseconds, and so it may fail" );
        
        }
        { //::SireCluster::Nodes::addNodes
        
            typedef void ( ::SireCluster::Nodes::*addNodes_function_type)( int ) ;
            addNodes_function_type addNodes_function_value( &::SireCluster::Nodes::addNodes );
            
            Nodes_exposer.def( 
                "addNodes"
                , addNodes_function_value
                , ( bp::arg("n") )
                , bp::release_gil_policy()
                , "Try to add up to n nodes to this set, by taking the nodes\nfrom the pool - this only looks for immediately available\nnodes, so you may get less than n (you may even get zero)" );
        
        }
        { //::SireCluster::Nodes::addNodes
        
            typedef void ( ::SireCluster::Nodes::*addNodes_function_type)( int,int ) ;
            addNodes_function_type addNodes_function_value( &::SireCluster::Nodes::addNodes );
            
            Nodes_exposer.def( 
                "addNodes"
                , addNodes_function_value
                , ( bp::arg("n"), bp::arg("timeout") )
                , bp::release_gil_policy()
                , "Try to add up to n nodes to this set, by taking the nodes\nfrom the pool - this only looks for available\nnodes for timeout milliseconds, so you may get less\nthan n (you may even get zero)" );
        
        }
        { //::SireCluster::Nodes::borrowThisThread
        
            typedef ::SireCluster::ThisThread ( ::SireCluster::Nodes::*borrowThisThread_function_type)(  ) ;
            borrowThisThread_function_type borrowThisThread_function_value( &::SireCluster::Nodes::borrowThisThread );
            
            Nodes_exposer.def( 
                "borrowThisThread"
                , borrowThisThread_function_value
                , bp::release_gil_policy()
                , "Let this Nodes scheduler borrow this thread to run WorkPackets.\nTechnically, this doesnt use the current thread, but instead\ncreates a duplicate, so you are still able to use your thread.\nHowever, you should avoid doing anything compute intensive in\nyour thread while the Node has borrowed it, as otherwise you\nrisk using more CPU than is available.\nThis returns a ThisThread holder that is used to ask the Nodes\nobject to return this thread when the ThisThread object is\ndeleted, or when ThisThread::reclaim() is called.\n" );
        
        }
        { //::SireCluster::Nodes::count
        
            typedef int ( ::SireCluster::Nodes::*count_function_type)(  ) ;
            count_function_type count_function_value( &::SireCluster::Nodes::count );
            
            Nodes_exposer.def( 
                "count"
                , count_function_value
                , bp::release_gil_policy()
                , "Return the total number of nodes available" );
        
        }
        { //::SireCluster::Nodes::getAllNodes
        
            typedef ::QList< SireCluster::Node > ( ::SireCluster::Nodes::*getAllNodes_function_type)(  ) ;
            getAllNodes_function_type getAllNodes_function_value( &::SireCluster::Nodes::getAllNodes );
            
            Nodes_exposer.def( 
                "getAllNodes"
                , getAllNodes_function_value
                , bp::release_gil_policy()
                , "Return all of the nodes - this blocks until all of the\nnodes are available. Remember that this will return an\nempty list if there are no nodes.\n" );
        
        }
        { //::SireCluster::Nodes::getAllNodes
        
            typedef ::QList< SireCluster::Node > ( ::SireCluster::Nodes::*getAllNodes_function_type)( int ) ;
            getAllNodes_function_type getAllNodes_function_value( &::SireCluster::Nodes::getAllNodes );
            
            Nodes_exposer.def( 
                "getAllNodes"
                , getAllNodes_function_value
                , ( bp::arg("timeout") )
                , bp::release_gil_policy()
                , "Try to get all the nodes, within the time timeout.\nIf this fails, then no nodes are returned" );
        
        }
        { //::SireCluster::Nodes::getNode
        
            typedef ::SireCluster::Node ( ::SireCluster::Nodes::*getNode_function_type)(  ) ;
            getNode_function_type getNode_function_value( &::SireCluster::Nodes::getNode );
            
            Nodes_exposer.def( 
                "getNode"
                , getNode_function_value
                , bp::release_gil_policy()
                , "Return a free node - this blocks until a free node\nis available. In certain circumstances this will fail\nand return a null Node (e.g. at program shutdown, or\nif all nodes are removed from this set)\n" );
        
        }
        { //::SireCluster::Nodes::getNode
        
            typedef ::SireCluster::Node ( ::SireCluster::Nodes::*getNode_function_type)( int ) ;
            getNode_function_type getNode_function_value( &::SireCluster::Nodes::getNode );
            
            Nodes_exposer.def( 
                "getNode"
                , getNode_function_value
                , ( bp::arg("timeout") )
                , bp::release_gil_policy()
                , "Try to get a free node - giving only timeout milliseconds\nto get that node. This returns a null node if the call\nis unsuccessful" );
        
        }
        { //::SireCluster::Nodes::getNodes
        
            typedef ::QList< SireCluster::Node > ( ::SireCluster::Nodes::*getNodes_function_type)( int ) ;
            getNodes_function_type getNodes_function_value( &::SireCluster::Nodes::getNodes );
            
            Nodes_exposer.def( 
                "getNodes"
                , getNodes_function_value
                , ( bp::arg("n") )
                , bp::release_gil_policy()
                , "Return n free nodes - this blocks until all of the\nnodes are available. In some circumstances this will fail,\ne.g. if there arent enough nodes to fulfill this request\n" );
        
        }
        { //::SireCluster::Nodes::getNodes
        
            typedef ::QList< SireCluster::Node > ( ::SireCluster::Nodes::*getNodes_function_type)( int,int ) ;
            getNodes_function_type getNodes_function_value( &::SireCluster::Nodes::getNodes );
            
            Nodes_exposer.def( 
                "getNodes"
                , getNodes_function_value
                , ( bp::arg("n"), bp::arg("timeout") )
                , bp::release_gil_policy()
                , "Try to get n free nodes, within the time timeout.\nIf this fails, then no nodes are returned" );
        
        }
        { //::SireCluster::Nodes::isEmpty
        
            typedef bool ( ::SireCluster::Nodes::*isEmpty_function_type)(  ) ;
            isEmpty_function_type isEmpty_function_value( &::SireCluster::Nodes::isEmpty );
            
            Nodes_exposer.def( 
                "isEmpty"
                , isEmpty_function_value
                , bp::release_gil_policy()
                , "Return whether or not this is empty (contains no nodes)" );
        
        }
        { //::SireCluster::Nodes::nBusy
        
            typedef int ( ::SireCluster::Nodes::*nBusy_function_type)(  ) ;
            nBusy_function_type nBusy_function_value( &::SireCluster::Nodes::nBusy );
            
            Nodes_exposer.def( 
                "nBusy"
                , nBusy_function_value
                , bp::release_gil_policy()
                , "Return the number of busy nodes" );
        
        }
        { //::SireCluster::Nodes::nFree
        
            typedef int ( ::SireCluster::Nodes::*nFree_function_type)(  ) ;
            nFree_function_type nFree_function_value( &::SireCluster::Nodes::nFree );
            
            Nodes_exposer.def( 
                "nFree"
                , nFree_function_value
                , bp::release_gil_policy()
                , "Return the number of free nodes" );
        
        }
        { //::SireCluster::Nodes::nNodes
        
            typedef int ( ::SireCluster::Nodes::*nNodes_function_type)(  ) ;
            nNodes_function_type nNodes_function_value( &::SireCluster::Nodes::nNodes );
            
            Nodes_exposer.def( 
                "nNodes"
                , nNodes_function_value
                , bp::release_gil_policy()
                , "Return the total number of nodes available" );
        
        }
        Nodes_exposer.def( bp::self != bp::self );
        { //::SireCluster::Nodes::operator=
        
            typedef ::SireCluster::Nodes & ( ::SireCluster::Nodes::*assign_function_type)( ::SireCluster::Nodes const & ) ;
            assign_function_type assign_function_value( &::SireCluster::Nodes::operator= );
            
            Nodes_exposer.def( 
                "assign"
                , assign_function_value
                , ( bp::arg("other") )
                , bp::return_self< >()
                , "" );
        
        }
        Nodes_exposer.def( bp::self == bp::self );
        { //::SireCluster::Nodes::remove
        
            typedef void ( ::SireCluster::Nodes::*remove_function_type)( ::SireCluster::Node ) ;
            remove_function_type remove_function_value( &::SireCluster::Nodes::remove );
            
            Nodes_exposer.def( 
                "remove"
                , remove_function_value
                , ( bp::arg("node") )
                , bp::release_gil_policy()
                , "Remove the node node from this set. This doesnt abort\nthe job running on the node, but the node will be automatically\nreturned to the Cluster pool once it is destroyed.\nThis does nothing if this node isnt in this set.\n" );
        
        }
        { //::SireCluster::Nodes::removeAll
        
            typedef void ( ::SireCluster::Nodes::*removeAll_function_type)(  ) ;
            removeAll_function_type removeAll_function_value( &::SireCluster::Nodes::removeAll );
            
            Nodes_exposer.def( 
                "removeAll"
                , removeAll_function_value
                , bp::release_gil_policy()
                , "Remove all nodes from this set - this aborts any running\njobs, then disconnects from all of the backends.\nNote that this does not block" );
        
        }
        { //::SireCluster::Nodes::toString
        
            typedef ::QString ( ::SireCluster::Nodes::*toString_function_type)(  ) const;
            toString_function_type toString_function_value( &::SireCluster::Nodes::toString );
            
            Nodes_exposer.def( 
                "toString"
                , toString_function_value
                , bp::release_gil_policy()
                , "Return a string representation of these nodes" );
        
        }
        { //::SireCluster::Nodes::waitUntilAllFree
        
            typedef void ( ::SireCluster::Nodes::*waitUntilAllFree_function_type)(  ) ;
            waitUntilAllFree_function_type waitUntilAllFree_function_value( &::SireCluster::Nodes::waitUntilAllFree );
            
            Nodes_exposer.def( 
                "waitUntilAllFree"
                , waitUntilAllFree_function_value
                , bp::release_gil_policy()
                , "Wait until all of the nodes are free" );
        
        }
        { //::SireCluster::Nodes::waitUntilAllFree
        
            typedef bool ( ::SireCluster::Nodes::*waitUntilAllFree_function_type)( int ) ;
            waitUntilAllFree_function_type waitUntilAllFree_function_value( &::SireCluster::Nodes::waitUntilAllFree );
            
            Nodes_exposer.def( 
                "waitUntilAllFree"
                , waitUntilAllFree_function_value
                , ( bp::arg("timeout") )
                , bp::release_gil_policy()
                , "Wait until all of the nodes are free, or until\ntimeout milliseconds have passed - this returns\nwhether or not all of the nodes are free" );
        
        }
        Nodes_exposer.def( "__copy__", &__copy__);
        Nodes_exposer.def( "__deepcopy__", &__copy__);
        Nodes_exposer.def( "clone", &__copy__);
        Nodes_exposer.def( "__str__", &__str__< ::SireCluster::Nodes > );
        Nodes_exposer.def( "__repr__", &__str__< ::SireCluster::Nodes > );
        Nodes_exposer.def( "__len__", &__len_count< ::SireCluster::Nodes > );
    }

}
