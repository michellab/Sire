// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 2 License

#include "boost/python.hpp"
#include "Node.pypp.hpp"

namespace bp = boost::python;

#include "SireError/errors.h"

#include "frontend.h"

#include "node.h"

#include "nodes.h"

#include "promise.h"

#include "workpacket.h"

#include <QMutex>

#include <QUuid>

#include <QWaitCondition>

#include "node.h"

SireCluster::Node __copy__(const SireCluster::Node &other){ return SireCluster::Node(other); }

#include "Helpers/str.hpp"

#include "Helpers/release_gil_policy.hpp"

void register_Node_class(){

    { //::SireCluster::Node
        typedef bp::class_< SireCluster::Node > Node_exposer_t;
        Node_exposer_t Node_exposer = Node_exposer_t( "Node", "This is a Node in a cluster. A Node is a resource that can\nbe used to run WorkPackets. A Node is always part of a\nNodes scheduler object, that coordinates the WorkPackets\nthat are assigned to the nodes. Alternatively, you can\ngrab a node manually from the Nodes object and you can\nassign WorkPackets to it yourself\n\nEssentially, a Node is a means of directing WorkPackets\nto Frontends, so that they can be communicated on to\nBackends that perform the actual work.\n\nAuthor: Christopher Woods\n", bp::init< >("Null constructor") );
        bp::scope Node_scope( Node_exposer );
        Node_exposer.def( bp::init< SireCluster::Node const & >(( bp::arg("other") ), "Copy constructor") );
        { //::SireCluster::Node::UID
        
            typedef ::QUuid ( ::SireCluster::Node::*UID_function_type)(  ) ;
            UID_function_type UID_function_value( &::SireCluster::Node::UID );
            
            Node_exposer.def( 
                "UID"
                , UID_function_value
                , bp::release_gil_policy()
                , "Return the unique ID of the Node" );
        
        }
        { //::SireCluster::Node::abortJob
        
            typedef void ( ::SireCluster::Node::*abortJob_function_type)(  ) ;
            abortJob_function_type abortJob_function_value( &::SireCluster::Node::abortJob );
            
            Node_exposer.def( 
                "abortJob"
                , abortJob_function_value
                , bp::release_gil_policy()
                , "Abort any running job on this node - this does not block" );
        
        }
        { //::SireCluster::Node::forceRelease
        
            typedef void ( ::SireCluster::Node::*forceRelease_function_type)(  ) ;
            forceRelease_function_type forceRelease_function_value( &::SireCluster::Node::forceRelease );
            
            Node_exposer.def( 
                "forceRelease"
                , forceRelease_function_value
                , bp::release_gil_policy()
                , "Force the release of this node. This aborts any running\njobs on this node and returns it to the Nodes home, or\nback to the Cluster pool if this is homeless. This will\nrelease the node even if there are other references to it,\nwho may be querying or waiting for it. This is not thread-safe,\nbut may be necessary if you have lost a reference and\nyou need to send this node back" );
        
        }
        { //::SireCluster::Node::isHomeless
        
            typedef bool ( ::SireCluster::Node::*isHomeless_function_type)(  ) ;
            isHomeless_function_type isHomeless_function_value( &::SireCluster::Node::isHomeless );
            
            Node_exposer.def( 
                "isHomeless"
                , isHomeless_function_value
                , bp::release_gil_policy()
                , "Return whether or not this Node object is homeless\n(is not part of any Nodes set). A homeless node can\nfinish any job that has started, but it is not allowed\nto start any more jobs" );
        
        }
        { //::SireCluster::Node::isLocal
        
            typedef bool ( ::SireCluster::Node::*isLocal_function_type)(  ) ;
            isLocal_function_type isLocal_function_value( &::SireCluster::Node::isLocal );
            
            Node_exposer.def( 
                "isLocal"
                , isLocal_function_value
                , bp::release_gil_policy()
                , "Return whether or not this node is local to this process" );
        
        }
        { //::SireCluster::Node::isNull
        
            typedef bool ( ::SireCluster::Node::*isNull_function_type)(  ) const;
            isNull_function_type isNull_function_value( &::SireCluster::Node::isNull );
            
            Node_exposer.def( 
                "isNull"
                , isNull_function_value
                , bp::release_gil_policy()
                , "Return whether or not this node is null" );
        
        }
        { //::SireCluster::Node::nodes
        
            typedef ::SireCluster::Nodes ( ::SireCluster::Node::*nodes_function_type)(  ) ;
            nodes_function_type nodes_function_value( &::SireCluster::Node::nodes );
            
            Node_exposer.def( 
                "nodes"
                , nodes_function_value
                , bp::release_gil_policy()
                , "Return the nodes object that this node belongs to. In some rare\ncircumstances this node may be homeless, in which case\nan empty set of nodes will be returned" );
        
        }
        Node_exposer.def( bp::self != bp::self );
        { //::SireCluster::Node::operator=
        
            typedef ::SireCluster::Node & ( ::SireCluster::Node::*assign_function_type)( ::SireCluster::Node const & ) ;
            assign_function_type assign_function_value( &::SireCluster::Node::operator= );
            
            Node_exposer.def( 
                "assign"
                , assign_function_value
                , ( bp::arg("other") )
                , bp::return_self< >()
                , "" );
        
        }
        Node_exposer.def( bp::self == bp::self );
        { //::SireCluster::Node::progress
        
            typedef float ( ::SireCluster::Node::*progress_function_type)(  ) ;
            progress_function_type progress_function_value( &::SireCluster::Node::progress );
            
            Node_exposer.def( 
                "progress"
                , progress_function_value
                , bp::release_gil_policy()
                , "Return the progress of the Node on the current WorkPacket" );
        
        }
        { //::SireCluster::Node::release
        
            typedef bool ( ::SireCluster::Node::*release_function_type)(  ) ;
            release_function_type release_function_value( &::SireCluster::Node::release );
            
            Node_exposer.def( 
                "release"
                , release_function_value
                , bp::release_gil_policy()
                , "Release this node - this returns the node to its parent\nNodes object, or back to the Cluster pool if this node\nis homeless. Note that this will only return the node if this\nis the only reference to this node. This returns whether\nor not this node was returned" );
        
        }
        { //::SireCluster::Node::startJob
        
            typedef ::SireCluster::Promise ( ::SireCluster::Node::*startJob_function_type)( ::SireCluster::WorkPacket const & ) ;
            startJob_function_type startJob_function_value( &::SireCluster::Node::startJob );
            
            Node_exposer.def( 
                "startJob"
                , startJob_function_value
                , ( bp::arg("workpacket") )
                , bp::release_gil_policy()
                , "Start the job in the WorkPacket workpacket on this node\nand return a Promise that will contain the calculated\nresult. This will autodelete the node.\nThis is useful if this is the only workpacket\nthat you want to run on the node, as this will allow\nthe node to automatically be returned to the free-queue\nonce if has finished.\nThrow: SireError::unavailable_resource\n" );
        
        }
        { //::SireCluster::Node::startJob
        
            typedef ::SireCluster::Promise ( ::SireCluster::Node::*startJob_function_type)( ::SireCluster::WorkPacket const &,bool ) ;
            startJob_function_type startJob_function_value( &::SireCluster::Node::startJob );
            
            Node_exposer.def( 
                "startJob"
                , startJob_function_value
                , ( bp::arg("workpacket"), bp::arg("autodelete") )
                , bp::release_gil_policy()
                , "Start the job in the WorkPacket workpacket on this node\nand return a Promise that will contain the calculated\nresult. This will autodelete the node if autodelete\nis true. This is useful if this is the only workpacket\nthat you want to run on the node, as this will allow\nthe node to automatically be returned to the free-queue\nonce if has finished.\nThrow: SireError::unavailable_resource\n" );
        
        }
        { //::SireCluster::Node::stopJob
        
            typedef void ( ::SireCluster::Node::*stopJob_function_type)(  ) ;
            stopJob_function_type stopJob_function_value( &::SireCluster::Node::stopJob );
            
            Node_exposer.def( 
                "stopJob"
                , stopJob_function_value
                , bp::release_gil_policy()
                , "Stop any running job on this node - this does not block" );
        
        }
        { //::SireCluster::Node::toString
        
            typedef ::QString ( ::SireCluster::Node::*toString_function_type)(  ) const;
            toString_function_type toString_function_value( &::SireCluster::Node::toString );
            
            Node_exposer.def( 
                "toString"
                , toString_function_value
                , bp::release_gil_policy()
                , "Return a string representation of this node" );
        
        }
        { //::SireCluster::Node::wait
        
            typedef void ( ::SireCluster::Node::*wait_function_type)(  ) ;
            wait_function_type wait_function_value( &::SireCluster::Node::wait );
            
            Node_exposer.def( 
                "wait"
                , wait_function_value
                , bp::release_gil_policy()
                , "Wait for the Node to stop work" );
        
        }
        { //::SireCluster::Node::wait
        
            typedef bool ( ::SireCluster::Node::*wait_function_type)( int ) ;
            wait_function_type wait_function_value( &::SireCluster::Node::wait );
            
            Node_exposer.def( 
                "wait"
                , wait_function_value
                , ( bp::arg("timeout") )
                , bp::release_gil_policy()
                , "Wait for the Node to stop work (or until timeout milliseconds\nhave passed) - this returns whether or not the Node has stopped\nwork" );
        
        }
        Node_exposer.def( "__copy__", &__copy__);
        Node_exposer.def( "__deepcopy__", &__copy__);
        Node_exposer.def( "clone", &__copy__);
        Node_exposer.def( "__str__", &__str__< ::SireCluster::Node > );
        Node_exposer.def( "__repr__", &__str__< ::SireCluster::Node > );
    }

}
