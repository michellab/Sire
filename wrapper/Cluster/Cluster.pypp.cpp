// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 2 License

#include "boost/python.hpp"
#include "Cluster.pypp.hpp"

namespace bp = boost::python;

#include "SireError/errors.h"

#include "SireError/printerror.h"

#include "backend.h"

#include "cluster.h"

#include "frontend.h"

#include "nodes.h"

#include <QDebug>

#include <QElapsedTimer>

#include <QHash>

#include <QMutex>

#include <QWaitCondition>

#include "cluster.h"

SireCluster::Cluster __copy__(const SireCluster::Cluster &other){ return SireCluster::Cluster(other); }

const char* pvt_get_name(const SireCluster::Cluster&){ return "SireCluster::Cluster";}

#include "Helpers/release_gil_policy.hpp"

void register_Cluster_class(){

    { //::SireCluster::Cluster
        typedef bp::class_< SireCluster::Cluster > Cluster_exposer_t;
        Cluster_exposer_t Cluster_exposer = Cluster_exposer_t( "Cluster", "This class provides the global registry for all nodes in the cluster.\nA node is defined as a resource that can run a WorkPacket. A node\nconsists of a Backend (the object in which the WorkPacket is\nrun) and a Frontend (the object that allows the node to communicate\nwith the Backend)\n\nAuthor: Christopher Woods\n" );
        bp::scope Cluster_scope( Cluster_exposer );
        { //::SireCluster::Cluster::UIDs
        
            typedef ::QList< QUuid > ( *UIDs_function_type )(  );
            UIDs_function_type UIDs_function_value( &::SireCluster::Cluster::UIDs );
            
            Cluster_exposer.def( 
                "UIDs"
                , UIDs_function_value
                , bp::release_gil_policy()
                , "Return the list of all of the UIDs of all of the nodes\nin this entire cluster" );
        
        }
        { //::SireCluster::Cluster::getAllNodes
        
            typedef ::SireCluster::Nodes ( *getAllNodes_function_type )(  );
            getAllNodes_function_type getAllNodes_function_value( &::SireCluster::Cluster::getAllNodes );
            
            Cluster_exposer.def( 
                "getAllNodes"
                , getAllNodes_function_value
                , bp::release_gil_policy()
                , "Try to get hold of all of the nodes that are available on this\ncluster" );
        
        }
        { //::SireCluster::Cluster::getAllNodes
        
            typedef ::SireCluster::Nodes ( *getAllNodes_function_type )( int );
            getAllNodes_function_type getAllNodes_function_value( &::SireCluster::Cluster::getAllNodes );
            
            Cluster_exposer.def( 
                "getAllNodes"
                , getAllNodes_function_value
                , ( bp::arg("timeout") )
                , bp::release_gil_policy()
                , "Try to get hold of all of the nodes that are available on this\ncluster (within the specified timeout)" );
        
        }
        { //::SireCluster::Cluster::getCount
        
            typedef int ( *getCount_function_type )(  );
            getCount_function_type getCount_function_value( &::SireCluster::Cluster::getCount );
            
            Cluster_exposer.def( 
                "getCount"
                , getCount_function_value
                , bp::release_gil_policy()
                , "Return the number of processes - this is either the\nsize of the MPI group, or it is 1" );
        
        }
        { //::SireCluster::Cluster::getNode
        
            typedef ::SireCluster::Nodes ( *getNode_function_type )(  );
            getNode_function_type getNode_function_value( &::SireCluster::Cluster::getNode );
            
            Cluster_exposer.def( 
                "getNode"
                , getNode_function_value
                , bp::release_gil_policy()
                , "Return a Nodes object that contains just a single node.\nThis doesnt block - it just grabs the first available\nnode, and if there are none available then it returns\nimmediately, returning an empty Nodes object" );
        
        }
        { //::SireCluster::Cluster::getNode
        
            typedef ::SireCluster::Nodes ( *getNode_function_type )( int );
            getNode_function_type getNode_function_value( &::SireCluster::Cluster::getNode );
            
            Cluster_exposer.def( 
                "getNode"
                , getNode_function_value
                , ( bp::arg("timeout") )
                , bp::release_gil_policy()
                , "Return a Nodes object that contains just a single node.\nThis blocks until a Node is available, or until timeout\nmilliseconds has passed (use negative timeout to wait forever).\nThere are some cases where a Node is just not available, in which\ncase an empty Nodes object will be returned\n" );
        
        }
        { //::SireCluster::Cluster::getNode
        
            typedef ::SireCluster::Nodes ( *getNode_function_type )( ::QUuid const & );
            getNode_function_type getNode_function_value( &::SireCluster::Cluster::getNode );
            
            Cluster_exposer.def( 
                "getNode"
                , getNode_function_value
                , ( bp::arg("uid") )
                , bp::release_gil_policy()
                , "Return a Nodes object that contains the node with UID uid.\nThere are some cases where a Node is just not available, in which\ncase an empty Nodes object will be returned.\nThrow: SireError::unavailable_resource\n" );
        
        }
        { //::SireCluster::Cluster::getNode
        
            typedef ::SireCluster::Nodes ( *getNode_function_type )( ::QUuid const &,int );
            getNode_function_type getNode_function_value( &::SireCluster::Cluster::getNode );
            
            Cluster_exposer.def( 
                "getNode"
                , getNode_function_value
                , ( bp::arg("uid"), bp::arg("timeout") )
                , bp::release_gil_policy()
                , "Return a Nodes object that contains the node with UID uid.\nThis blocks until the Node is available, or until timeout\nmilliseconds has passed (use negative timeout to wait forever).\nThere are some cases where a Node is just not available, in which\ncase an empty Nodes object will be returned.\nThrow: SireError::unavailable_resource\n" );
        
        }
        { //::SireCluster::Cluster::getNodes
        
            typedef ::SireCluster::Nodes ( *getNodes_function_type )( int );
            getNodes_function_type getNodes_function_value( &::SireCluster::Cluster::getNodes );
            
            Cluster_exposer.def( 
                "getNodes"
                , getNodes_function_value
                , ( bp::arg("nnodes") )
                , bp::release_gil_policy()
                , "Return a Nodes object containing up to nnodes nodes. This function\nwill do its best, but you may end with less than you asked for\n(or even none at all)." );
        
        }
        { //::SireCluster::Cluster::getNodes
        
            typedef ::SireCluster::Nodes ( *getNodes_function_type )( int,int );
            getNodes_function_type getNodes_function_value( &::SireCluster::Cluster::getNodes );
            
            Cluster_exposer.def( 
                "getNodes"
                , getNodes_function_value
                , ( bp::arg("nnodes"), bp::arg("timeout") )
                , bp::release_gil_policy()
                , "Return a Nodes object containing up to nnodes nodes. This function\nwill do its best, but you may end with less than you asked for\n(or even none at all). It is a bad idea to ask for more nodes\nthan there are backends using an infinite timeout..." );
        
        }
        { //::SireCluster::Cluster::getNodes
        
            typedef ::SireCluster::Nodes ( *getNodes_function_type )( ::QList< QUuid > const & );
            getNodes_function_type getNodes_function_value( &::SireCluster::Cluster::getNodes );
            
            Cluster_exposer.def( 
                "getNodes"
                , getNodes_function_value
                , ( bp::arg("uids") )
                , bp::release_gil_policy()
                , "Return a Nodes object that contains as many of the nodes with\nUIDs from uids as possible, within the time allowed. Note that\nthis may not give you all of the nodes (it may give you none).\nThrow: SireError::unavailable_resource\n" );
        
        }
        { //::SireCluster::Cluster::getNodes
        
            typedef ::SireCluster::Nodes ( *getNodes_function_type )( ::QList< QUuid > const &,int );
            getNodes_function_type getNodes_function_value( &::SireCluster::Cluster::getNodes );
            
            Cluster_exposer.def( 
                "getNodes"
                , getNodes_function_value
                , ( bp::arg("uids"), bp::arg("timeout") )
                , bp::release_gil_policy()
                , "Return a Nodes object that contains as many of the nodes with\nUIDs from uids as possible, within the time allowed. Note that\nthis may not give you all of the nodes (it may give you none).\nThrow: SireError::unavailable_resource\n" );
        
        }
        { //::SireCluster::Cluster::getRank
        
            typedef int ( *getRank_function_type )(  );
            getRank_function_type getRank_function_value( &::SireCluster::Cluster::getRank );
            
            Cluster_exposer.def( 
                "getRank"
                , getRank_function_value
                , bp::release_gil_policy()
                , "Return the rank of the process - this is either the\nrank of this process in the MPI group, or it is 0" );
        
        }
        { //::SireCluster::Cluster::isLocal
        
            typedef bool ( *isLocal_function_type )( ::QUuid const & );
            isLocal_function_type isLocal_function_value( &::SireCluster::Cluster::isLocal );
            
            Cluster_exposer.def( 
                "isLocal"
                , isLocal_function_value
                , ( bp::arg("uid") )
                , bp::release_gil_policy()
                , "Return whether or not the backend with unique ID uid\nis local to this process" );
        
        }
        { //::SireCluster::Cluster::isRunning
        
            typedef bool ( *isRunning_function_type )(  );
            isRunning_function_type isRunning_function_value( &::SireCluster::Cluster::isRunning );
            
            Cluster_exposer.def( 
                "isRunning"
                , isRunning_function_value
                , bp::release_gil_policy()
                , "Return whether or not the cluster is running" );
        
        }
        { //::SireCluster::Cluster::localUIDs
        
            typedef ::QList< QUuid > ( *localUIDs_function_type )(  );
            localUIDs_function_type localUIDs_function_value( &::SireCluster::Cluster::localUIDs );
            
            Cluster_exposer.def( 
                "localUIDs"
                , localUIDs_function_value
                , bp::release_gil_policy()
                , "Return the list of all of the UIDs of the local nodes\n(the nodes that exist in this address space)" );
        
        }
        { //::SireCluster::Cluster::shutdown
        
            typedef void ( *shutdown_function_type )(  );
            shutdown_function_type shutdown_function_value( &::SireCluster::Cluster::shutdown );
            
            Cluster_exposer.def( 
                "shutdown"
                , shutdown_function_value
                , bp::release_gil_policy()
                , "Shutdown this cluster" );
        
        }
        { //::SireCluster::Cluster::start
        
            typedef void ( *start_function_type )( int );
            start_function_type start_function_value( &::SireCluster::Cluster::start );
            
            Cluster_exposer.def( 
                "start"
                , start_function_value
                , ( bp::arg("ppn")=(int)(1) )
                , "Start the cluster - this is like exec, but it doesnt\nblock until the cluster has been shutdown" );
        
        }
        { //::SireCluster::Cluster::supportsMPI
        
            typedef bool ( *supportsMPI_function_type )(  );
            supportsMPI_function_type supportsMPI_function_value( &::SireCluster::Cluster::supportsMPI );
            
            Cluster_exposer.def( 
                "supportsMPI"
                , supportsMPI_function_value
                , bp::release_gil_policy()
                , "Return whether or not this cluster supports MPI\n(this is true if MPI is available, and there is more than\none MPI process)" );
        
        }
        { //::SireCluster::Cluster::wait
        
            typedef void ( *wait_function_type )(  );
            wait_function_type wait_function_value( &::SireCluster::Cluster::wait );
            
            Cluster_exposer.def( 
                "wait"
                , wait_function_value
                , bp::release_gil_policy()
                , "Wait for the global cluster to stop running" );
        
        }
        Cluster_exposer.staticmethod( "UIDs" );
        Cluster_exposer.staticmethod( "getAllNodes" );
        Cluster_exposer.staticmethod( "getCount" );
        Cluster_exposer.staticmethod( "getNode" );
        Cluster_exposer.staticmethod( "getNodes" );
        Cluster_exposer.staticmethod( "getRank" );
        Cluster_exposer.staticmethod( "isLocal" );
        Cluster_exposer.staticmethod( "isRunning" );
        Cluster_exposer.staticmethod( "localUIDs" );
        Cluster_exposer.staticmethod( "shutdown" );
        Cluster_exposer.staticmethod( "start" );
        Cluster_exposer.staticmethod( "supportsMPI" );
        Cluster_exposer.staticmethod( "wait" );
        Cluster_exposer.def( "__copy__", &__copy__);
        Cluster_exposer.def( "__deepcopy__", &__copy__);
        Cluster_exposer.def( "clone", &__copy__);
        Cluster_exposer.def( "__str__", &pvt_get_name);
        Cluster_exposer.def( "__repr__", &pvt_get_name);
    }

}
