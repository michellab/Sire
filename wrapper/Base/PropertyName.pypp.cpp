// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 2 License

#include "boost/python.hpp"
#include "Helpers/clone_const_reference.hpp"
#include "PropertyName.pypp.hpp"

namespace bp = boost::python;

#include "SireStream/datastream.h"

#include "SireStream/shareddatastream.h"

#include "propertymap.h"

#include <QDebug>

#include "propertymap.h"

SireBase::PropertyName __copy__(const SireBase::PropertyName &other){ return SireBase::PropertyName(other); }

#include "Qt/qdatastream.hpp"

#include "Helpers/str.hpp"

#include "Helpers/release_gil_policy.hpp"

void register_PropertyName_class(){

    { //::SireBase::PropertyName
        typedef bp::class_< SireBase::PropertyName > PropertyName_exposer_t;
        PropertyName_exposer_t PropertyName_exposer = PropertyName_exposer_t( "PropertyName", "This class is used to store the registered name of the\nproperty (used as the offial name of the property\nby the code in the program, e.g. coordinates is the\nofficial name of the coordinates property, charges\nis the official name of the charges), the name for\nthe property assigned by the user (so the user can\nsay that the charges property is actually in the\nproperty called my charges) and an overridden\nvalue for the property that is used instead of\nthe value found in the object being queried\n(so the user can say to use a specific value of\na property)\n\nThis class is not used directly by the code, but\nis instead used as part of the Property::set( ) function,\nso that the user can write;\n\ncljff.add( mol, Property::set(charges,chgs) +\nProperty::set(ljs,ljparams) );\n\nThe PropertyMapPropertyName classes provide a kwargs\nlike interface for the C++ classes - indeed the python\nwrappers should allow code to be written like;\n\ncljff.add( mol, {charges : chgs, ljs : ljparams} )\n\nor\n\ncljff.add( mol, charges==charges, ljs==ljparams )\n\nAuthor: Christopher Woods\n", bp::init< >("Null constructor") );
        bp::scope PropertyName_scope( PropertyName_exposer );
        PropertyName_exposer.def( bp::init< char const * >(( bp::arg("source") ), "Construct a PropertyName that searches for the\nproperty using the source source") );
        PropertyName_exposer.def( bp::init< QString const & >(( bp::arg("source") ), "Construct a PropertyName that searches for the\nproperty using the source source") );
        PropertyName_exposer.def( bp::init< QString const &, SireBase::Property const & >(( bp::arg("source"), bp::arg("default_value") ), "Construct a PropertyName that searches for the property\nusing the source source, but only if that source is\nspecifically provided - otherwise the supplied default\nvalue of the property is used instead") );
        PropertyName_exposer.def( bp::init< SireBase::Property const & >(( bp::arg("value") ), "Construct a PropertyName that uses the supplied\nvalue, rather than searching for the property") );
        PropertyName_exposer.def( bp::init< SireBase::PropertyName const & >(( bp::arg("other") ), "Copy constructor") );
        { //::SireBase::PropertyName::hasDefaultValue
        
            typedef bool ( ::SireBase::PropertyName::*hasDefaultValue_function_type)(  ) const;
            hasDefaultValue_function_type hasDefaultValue_function_value( &::SireBase::PropertyName::hasDefaultValue );
            
            PropertyName_exposer.def( 
                "hasDefaultValue"
                , hasDefaultValue_function_value
                , bp::release_gil_policy()
                , "Return whether or not this has a default value" );
        
        }
        { //::SireBase::PropertyName::hasSource
        
            typedef bool ( ::SireBase::PropertyName::*hasSource_function_type)(  ) const;
            hasSource_function_type hasSource_function_value( &::SireBase::PropertyName::hasSource );
            
            PropertyName_exposer.def( 
                "hasSource"
                , hasSource_function_value
                , bp::release_gil_policy()
                , "Return whether or not the source has been set" );
        
        }
        { //::SireBase::PropertyName::hasValue
        
            typedef bool ( ::SireBase::PropertyName::*hasValue_function_type)(  ) const;
            hasValue_function_type hasValue_function_value( &::SireBase::PropertyName::hasValue );
            
            PropertyName_exposer.def( 
                "hasValue"
                , hasValue_function_value
                , bp::release_gil_policy()
                , "Return whether or not the value has been set" );
        
        }
        { //::SireBase::PropertyName::isNull
        
            typedef bool ( ::SireBase::PropertyName::*isNull_function_type)(  ) const;
            isNull_function_type isNull_function_value( &::SireBase::PropertyName::isNull );
            
            PropertyName_exposer.def( 
                "isNull"
                , isNull_function_value
                , bp::release_gil_policy()
                , "Return whether this property is null" );
        
        }
        { //::SireBase::PropertyName::none
        
            typedef ::SireBase::PropertyName ( *none_function_type )(  );
            none_function_type none_function_value( &::SireBase::PropertyName::none );
            
            PropertyName_exposer.def( 
                "none"
                , none_function_value
                , bp::release_gil_policy()
                , "Return a PropertyName that says that this property is not set" );
        
        }
        PropertyName_exposer.def( bp::self != bp::self );
        { //::SireBase::PropertyName::operator=
        
            typedef ::SireBase::PropertyName & ( ::SireBase::PropertyName::*assign_function_type)( ::SireBase::PropertyName const & ) ;
            assign_function_type assign_function_value( &::SireBase::PropertyName::operator= );
            
            PropertyName_exposer.def( 
                "assign"
                , assign_function_value
                , ( bp::arg("other") )
                , bp::return_self< >()
                , "" );
        
        }
        PropertyName_exposer.def( bp::self == bp::self );
        { //::SireBase::PropertyName::source
        
            typedef ::QString const & ( ::SireBase::PropertyName::*source_function_type)(  ) const;
            source_function_type source_function_value( &::SireBase::PropertyName::source );
            
            PropertyName_exposer.def( 
                "source"
                , source_function_value
                , bp::return_value_policy< bp::copy_const_reference >()
                , "Return the source of the property - this is only valid\nif .hasSource() is true" );
        
        }
        { //::SireBase::PropertyName::toString
        
            typedef ::QString ( ::SireBase::PropertyName::*toString_function_type)(  ) const;
            toString_function_type toString_function_value( &::SireBase::PropertyName::toString );
            
            PropertyName_exposer.def( 
                "toString"
                , toString_function_value
                , bp::release_gil_policy()
                , "Return a string representation of this propertyname" );
        
        }
        { //::SireBase::PropertyName::typeName
        
            typedef char const * ( *typeName_function_type )(  );
            typeName_function_type typeName_function_value( &::SireBase::PropertyName::typeName );
            
            PropertyName_exposer.def( 
                "typeName"
                , typeName_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireBase::PropertyName::value
        
            typedef ::SireBase::Property const & ( ::SireBase::PropertyName::*value_function_type)(  ) const;
            value_function_type value_function_value( &::SireBase::PropertyName::value );
            
            PropertyName_exposer.def( 
                "value"
                , value_function_value
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Return the value of the property - this is only valid\nif .hasValue() is true" );
        
        }
        { //::SireBase::PropertyName::what
        
            typedef char const * ( ::SireBase::PropertyName::*what_function_type)(  ) const;
            what_function_type what_function_value( &::SireBase::PropertyName::what );
            
            PropertyName_exposer.def( 
                "what"
                , what_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        PropertyName_exposer.staticmethod( "none" );
        PropertyName_exposer.staticmethod( "typeName" );
        PropertyName_exposer.def( "__copy__", &__copy__);
        PropertyName_exposer.def( "__deepcopy__", &__copy__);
        PropertyName_exposer.def( "clone", &__copy__);
        PropertyName_exposer.def( "__rlshift__", &__rlshift__QDataStream< ::SireBase::PropertyName >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        PropertyName_exposer.def( "__rrshift__", &__rrshift__QDataStream< ::SireBase::PropertyName >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        PropertyName_exposer.def_pickle(sire_pickle_suite< ::SireBase::PropertyName >());
        PropertyName_exposer.def( "__str__", &__str__< ::SireBase::PropertyName > );
        PropertyName_exposer.def( "__repr__", &__str__< ::SireBase::PropertyName > );
    }

}
