// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 2 License

#include "boost/python.hpp"
#include "SS_GTOs.pypp.hpp"

namespace bp = boost::python;

#include "SireBase/trigarray2d.h"

#include "SireError/errors.h"

#include "SireMaths/boys.h"

#include "SireMaths/maths.h"

#include "SireStream/datastream.h"

#include "SireStream/shareddatastream.h"

#include "pointcharge.h"

#include "pointdipole.h"

#include "sgto.h"

#include "sgto.h"

Squire::SS_GTOs __copy__(const Squire::SS_GTOs &other){ return Squire::SS_GTOs(other); }

const char* pvt_get_name(const Squire::SS_GTOs&){ return "Squire::SS_GTOs";}

void register_SS_GTOs_class(){

    { //::Squire::SS_GTOs
        typedef bp::class_< Squire::SS_GTOs > SS_GTOs_exposer_t;
        SS_GTOs_exposer_t SS_GTOs_exposer = SS_GTOs_exposer_t( "SS_GTOs", "This class is used to calculate integrals involving just SS pairs.\nIt is used to aid in the calculation of integrals.\n\nAuthor: Christopher Woods\n", bp::init< >("Null constructor") );
        bp::scope SS_GTOs_scope( SS_GTOs_exposer );
        SS_GTOs_exposer.def( bp::init< QVector< Squire::S_GTO > const &, QVector< SireMaths::Vector > const & >(( bp::arg("s_gtos"), bp::arg("centers") ), "Construct for the passed set of S orbitals (on the associated\ncenters)\nThrow: SireError::incompatible_error\n") );
        SS_GTOs_exposer.def( bp::init< Squire::SS_GTOs const & >(( bp::arg("other") ), "Copy constructor") );
        { //::Squire::SS_GTOs::coulomb_integral
        
            typedef ::SireMaths::TrigMatrix ( ::Squire::SS_GTOs::*coulomb_integral_function_type)( ::Squire::SS_GTOs const & ) const;
            coulomb_integral_function_type coulomb_integral_function_value( &::Squire::SS_GTOs::coulomb_integral );
            
            SS_GTOs_exposer.def( 
                "coulomb_integral"
                , coulomb_integral_function_value
                , ( bp::arg("other") )
                , "Return the coulomb integral between this set of pair of\nS orbitals and the pairs other S orbitals in other" );
        
        }
        { //::Squire::SS_GTOs::exchange_integral
        
            typedef ::SireMaths::TrigMatrix ( ::Squire::SS_GTOs::*exchange_integral_function_type)( ::Squire::SS_GTOs const & ) const;
            exchange_integral_function_type exchange_integral_function_value( &::Squire::SS_GTOs::exchange_integral );
            
            SS_GTOs_exposer.def( 
                "exchange_integral"
                , exchange_integral_function_value
                , ( bp::arg("other") )
                , "Return the exchange integral between this set of pair of\norbitals and the other set of pairs in other" );
        
        }
        { //::Squire::SS_GTOs::kinetic_integral
        
            typedef ::SireMaths::TrigMatrix ( ::Squire::SS_GTOs::*kinetic_integral_function_type)(  ) const;
            kinetic_integral_function_type kinetic_integral_function_value( &::Squire::SS_GTOs::kinetic_integral );
            
            SS_GTOs_exposer.def( 
                "kinetic_integral"
                , kinetic_integral_function_value
                , "Return the kinetic energy integral between all pairs of S orbitals in this set" );
        
        }
        { //::Squire::SS_GTOs::operator=
        
            typedef ::Squire::SS_GTOs & ( ::Squire::SS_GTOs::*assign_function_type)( ::Squire::SS_GTOs const & ) ;
            assign_function_type assign_function_value( &::Squire::SS_GTOs::operator= );
            
            SS_GTOs_exposer.def( 
                "assign"
                , assign_function_value
                , ( bp::arg("other") )
                , bp::return_self< >()
                , "" );
        
        }
        { //::Squire::SS_GTOs::overlap_integral
        
            typedef ::SireMaths::TrigMatrix ( ::Squire::SS_GTOs::*overlap_integral_function_type)(  ) const;
            overlap_integral_function_type overlap_integral_function_value( &::Squire::SS_GTOs::overlap_integral );
            
            SS_GTOs_exposer.def( 
                "overlap_integral"
                , overlap_integral_function_value
                , "Return the overlap integrals between all pairs of S orbitals in this set" );
        
        }
        { //::Squire::SS_GTOs::potential_integral
        
            typedef ::SireMaths::TrigMatrix ( ::Squire::SS_GTOs::*potential_integral_function_type)( ::QVector< Squire::PointCharge > const & ) const;
            potential_integral_function_type potential_integral_function_value( &::Squire::SS_GTOs::potential_integral );
            
            SS_GTOs_exposer.def( 
                "potential_integral"
                , potential_integral_function_value
                , ( bp::arg("C") )
                , "Return the potential energy integral of all pairs of S orbitals in this\nset with the array of point charges in C" );
        
        }
        { //::Squire::SS_GTOs::potential_integral
        
            typedef ::SireMaths::TrigMatrix ( ::Squire::SS_GTOs::*potential_integral_function_type)( ::QVector< Squire::PointCharge > const &,int ) const;
            potential_integral_function_type potential_integral_function_value( &::Squire::SS_GTOs::potential_integral );
            
            SS_GTOs_exposer.def( 
                "potential_integral"
                , potential_integral_function_value
                , ( bp::arg("C"), bp::arg("m") )
                , "Return the mth auxilliary potential energy integral of all pairs of S\norbitals in this set with the array of point charges in C" );
        
        }
        SS_GTOs_exposer.def( "__copy__", &__copy__);
        SS_GTOs_exposer.def( "__deepcopy__", &__copy__);
        SS_GTOs_exposer.def( "clone", &__copy__);
        SS_GTOs_exposer.def( "__str__", &pvt_get_name);
        SS_GTOs_exposer.def( "__repr__", &pvt_get_name);
    }

}
