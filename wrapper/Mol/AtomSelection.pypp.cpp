// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 2 License

#include "boost/python.hpp"
#include "AtomSelection.pypp.hpp"

namespace bp = boost::python;

#include "SireError/errors.h"

#include "SireMol/errors.h"

#include "SireStream/datastream.h"

#include "SireStream/shareddatastream.h"

#include "atomselection.h"

#include "moleculedata.h"

#include "moleculeinfodata.h"

#include "moleculeview.h"

#include <QDebug>

#include "atomselection.h"

SireMol::AtomSelection __copy__(const SireMol::AtomSelection &other){ return SireMol::AtomSelection(other); }

#include "Qt/qdatastream.hpp"

#include "Helpers/str.hpp"

#include "Helpers/release_gil_policy.hpp"

void register_AtomSelection_class(){

    { //::SireMol::AtomSelection
        typedef bp::class_< SireMol::AtomSelection, bp::bases< SireMol::MoleculeProperty, SireMol::MolViewProperty, SireBase::Property > > AtomSelection_exposer_t;
        AtomSelection_exposer_t AtomSelection_exposer = AtomSelection_exposer_t( "AtomSelection", "This class holds information about a selection of atoms in a Molecule.\nThe selection is held in the most memory-efficient manner possible,\nand takes advantage of the CutGroup-based layout of Molecule objects.\n\nThis is a const-class, which returns new AtomSelections that\nrepresent any change.\n\nAuthor: Christopher Woods\n", bp::init< >("Null constructor") );
        bp::scope AtomSelection_scope( AtomSelection_exposer );
        AtomSelection_exposer.def( bp::init< SireMol::MoleculeView const & >(( bp::arg("molecule") ), "Construct a selection of all of the atoms in the view\nmolecule") );
        AtomSelection_exposer.def( bp::init< SireMol::MoleculeData const & >(( bp::arg("moldata") ), "Construct a selection of all of the atoms in the\nmolecule whose data is in moldata") );
        AtomSelection_exposer.def( bp::init< SireMol::MoleculeInfoData const & >(( bp::arg("molinfo") ), "Construct a selection of all of the atoms in the\nmolecule that is described by the info object molinfo") );
        AtomSelection_exposer.def( bp::init< SireMol::AtomSelection const & >(( bp::arg("other") ), "Copy constructor") );
        { //::SireMol::AtomSelection::assertCompatibleWith
        
            typedef void ( ::SireMol::AtomSelection::*assertCompatibleWith_function_type)( ::SireMol::MoleculeData const & ) const;
            assertCompatibleWith_function_type assertCompatibleWith_function_value( &::SireMol::AtomSelection::assertCompatibleWith );
            
            AtomSelection_exposer.def( 
                "assertCompatibleWith"
                , assertCompatibleWith_function_value
                , ( bp::arg("moldata") )
                , bp::release_gil_policy()
                , "Assert that this selection is compatible with the molecule whose\ndata is in moldata\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireMol::AtomSelection::assertCompatibleWith
        
            typedef void ( ::SireMol::AtomSelection::*assertCompatibleWith_function_type)( ::SireMol::MoleculeView const & ) const;
            assertCompatibleWith_function_type assertCompatibleWith_function_value( &::SireMol::AtomSelection::assertCompatibleWith );
            
            AtomSelection_exposer.def( 
                "assertCompatibleWith"
                , assertCompatibleWith_function_value
                , ( bp::arg("molview") )
                , bp::release_gil_policy()
                , "Assert that this selection is compatible with the molecule viewed\nin molview\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireMol::AtomSelection::assertCompatibleWith
        
            typedef void ( ::SireMol::AtomSelection::*assertCompatibleWith_function_type)( ::SireMol::MoleculeInfoData const & ) const;
            assertCompatibleWith_function_type assertCompatibleWith_function_value( &::SireMol::AtomSelection::assertCompatibleWith );
            
            AtomSelection_exposer.def( 
                "assertCompatibleWith"
                , assertCompatibleWith_function_value
                , ( bp::arg("molinfo") )
                , bp::release_gil_policy()
                , "Assert that this selection is compatible with the molecule info\nin molinfo\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireMol::AtomSelection::assertCompatibleWith
        
            typedef void ( ::SireMol::AtomSelection::*assertCompatibleWith_function_type)( ::SireMol::AtomSelection const & ) const;
            assertCompatibleWith_function_type assertCompatibleWith_function_value( &::SireMol::AtomSelection::assertCompatibleWith );
            
            AtomSelection_exposer.def( 
                "assertCompatibleWith"
                , assertCompatibleWith_function_value
                , ( bp::arg("other") )
                , bp::release_gil_policy()
                , "Assert that this selection is compatible with other\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireMol::AtomSelection::assertSelected
        
            typedef void ( ::SireMol::AtomSelection::*assertSelected_function_type)( ::SireMol::AtomIdx ) const;
            assertSelected_function_type assertSelected_function_value( &::SireMol::AtomSelection::assertSelected );
            
            AtomSelection_exposer.def( 
                "assertSelected"
                , assertSelected_function_value
                , ( bp::arg("atomidx") )
                , bp::release_gil_policy()
                , "Assert that this selection contains the atom at index atomidx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::assertSelected
        
            typedef void ( ::SireMol::AtomSelection::*assertSelected_function_type)( ::SireMol::AtomID const & ) const;
            assertSelected_function_type assertSelected_function_value( &::SireMol::AtomSelection::assertSelected );
            
            AtomSelection_exposer.def( 
                "assertSelected"
                , assertSelected_function_value
                , ( bp::arg("atomid") )
                , bp::release_gil_policy()
                , "Assert that this selection contains all of the atoms identified\nby the ID atomid\nThrow: SireMol::missing_atom\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::contains
        
            typedef bool ( ::SireMol::AtomSelection::*contains_function_type)( ::SireMol::AtomIdx ) const;
            contains_function_type contains_function_value( &::SireMol::AtomSelection::contains );
            
            AtomSelection_exposer.def( 
                "contains"
                , contains_function_value
                , ( bp::arg("atomidx") )
                , bp::release_gil_policy()
                , "Return whether the atom at index atomidx is selected\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::contains
        
            typedef bool ( ::SireMol::AtomSelection::*contains_function_type)( ::SireMol::CGIdx ) const;
            contains_function_type contains_function_value( &::SireMol::AtomSelection::contains );
            
            AtomSelection_exposer.def( 
                "contains"
                , contains_function_value
                , ( bp::arg("cgidx") )
                , bp::release_gil_policy()
                , "Return whether all of the atoms in the CutGroup at\nindex cgidx have been selected\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::contains
        
            typedef bool ( ::SireMol::AtomSelection::*contains_function_type)( ::SireMol::ResIdx ) const;
            contains_function_type contains_function_value( &::SireMol::AtomSelection::contains );
            
            AtomSelection_exposer.def( 
                "contains"
                , contains_function_value
                , ( bp::arg("residx") )
                , bp::release_gil_policy()
                , "Return whether all of the atoms in the residue at\nindex residx have been selected\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::contains
        
            typedef bool ( ::SireMol::AtomSelection::*contains_function_type)( ::SireMol::ChainIdx ) const;
            contains_function_type contains_function_value( &::SireMol::AtomSelection::contains );
            
            AtomSelection_exposer.def( 
                "contains"
                , contains_function_value
                , ( bp::arg("chainidx") )
                , bp::release_gil_policy()
                , "Return whether all of the atoms in the chain at\nindex chainidx have been selected\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::contains
        
            typedef bool ( ::SireMol::AtomSelection::*contains_function_type)( ::SireMol::SegIdx ) const;
            contains_function_type contains_function_value( &::SireMol::AtomSelection::contains );
            
            AtomSelection_exposer.def( 
                "contains"
                , contains_function_value
                , ( bp::arg("segidx") )
                , bp::release_gil_policy()
                , "Return whether all of the atoms in the segments at\nindex segidx have been selected\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::contains
        
            typedef bool ( ::SireMol::AtomSelection::*contains_function_type)( ::SireMol::AtomID const & ) const;
            contains_function_type contains_function_value( &::SireMol::AtomSelection::contains );
            
            AtomSelection_exposer.def( 
                "contains"
                , contains_function_value
                , ( bp::arg("atomid") )
                , bp::release_gil_policy()
                , "Return whether all of the atoms identified by\natomid have been selected\nThrow: SireMol::missing_atom\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::contains
        
            typedef bool ( ::SireMol::AtomSelection::*contains_function_type)( ::SireMol::CGID const & ) const;
            contains_function_type contains_function_value( &::SireMol::AtomSelection::contains );
            
            AtomSelection_exposer.def( 
                "contains"
                , contains_function_value
                , ( bp::arg("cgid") )
                , bp::release_gil_policy()
                , "Return whether all of the atoms in the CutGroup(s) identified by\ncgid have been selected\nThrow: SireMol::missing_cutgroup\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::contains
        
            typedef bool ( ::SireMol::AtomSelection::*contains_function_type)( ::SireMol::ResID const & ) const;
            contains_function_type contains_function_value( &::SireMol::AtomSelection::contains );
            
            AtomSelection_exposer.def( 
                "contains"
                , contains_function_value
                , ( bp::arg("resid") )
                , bp::release_gil_policy()
                , "Return whether all of the atoms in the residue(s) identified by\nresid have been selected\nThrow: SireMol::missing_residue\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::contains
        
            typedef bool ( ::SireMol::AtomSelection::*contains_function_type)( ::SireMol::ChainID const & ) const;
            contains_function_type contains_function_value( &::SireMol::AtomSelection::contains );
            
            AtomSelection_exposer.def( 
                "contains"
                , contains_function_value
                , ( bp::arg("chainid") )
                , bp::release_gil_policy()
                , "Return whether all of the atoms in the chain(s) identified by\nchainid have been selected\nThrow: SireMol::missing_chain\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::contains
        
            typedef bool ( ::SireMol::AtomSelection::*contains_function_type)( ::SireMol::SegID const & ) const;
            contains_function_type contains_function_value( &::SireMol::AtomSelection::contains );
            
            AtomSelection_exposer.def( 
                "contains"
                , contains_function_value
                , ( bp::arg("segid") )
                , bp::release_gil_policy()
                , "Return whether all of the atoms in the segment(s) identified by\nsegid have been selected\nThrow: SireMol::missing_segment\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::contains
        
            typedef bool ( ::SireMol::AtomSelection::*contains_function_type)( ::SireMol::AtomSelection const & ) const;
            contains_function_type contains_function_value( &::SireMol::AtomSelection::contains );
            
            AtomSelection_exposer.def( 
                "contains"
                , contains_function_value
                , ( bp::arg("selection") )
                , bp::release_gil_policy()
                , "Return whether all of the atoms selected in selection are\nselected in this set\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireMol::AtomSelection::deselect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*deselect_function_type)( ::SireMol::AtomIdx ) ;
            deselect_function_type deselect_function_value( &::SireMol::AtomSelection::deselect );
            
            AtomSelection_exposer.def( 
                "deselect"
                , deselect_function_value
                , ( bp::arg("atomidx") )
                , bp::return_self< >()
                , "Deselect the atom at index atomidx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::deselect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*deselect_function_type)( ::SireMol::CGIdx ) ;
            deselect_function_type deselect_function_value( &::SireMol::AtomSelection::deselect );
            
            AtomSelection_exposer.def( 
                "deselect"
                , deselect_function_value
                , ( bp::arg("cgidx") )
                , bp::return_self< >()
                , "Deselect the CutGroup at index cgidx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::deselect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*deselect_function_type)( ::SireMol::ResIdx ) ;
            deselect_function_type deselect_function_value( &::SireMol::AtomSelection::deselect );
            
            AtomSelection_exposer.def( 
                "deselect"
                , deselect_function_value
                , ( bp::arg("residx") )
                , bp::return_self< >()
                , "Deselect the atoms in the residue at index residx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::deselect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*deselect_function_type)( ::SireMol::ChainIdx ) ;
            deselect_function_type deselect_function_value( &::SireMol::AtomSelection::deselect );
            
            AtomSelection_exposer.def( 
                "deselect"
                , deselect_function_value
                , ( bp::arg("chainidx") )
                , bp::return_self< >()
                , "Deselect all of the atoms in the chain at index chainidx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::deselect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*deselect_function_type)( ::SireMol::SegIdx ) ;
            deselect_function_type deselect_function_value( &::SireMol::AtomSelection::deselect );
            
            AtomSelection_exposer.def( 
                "deselect"
                , deselect_function_value
                , ( bp::arg("segidx") )
                , bp::return_self< >()
                , "Deselect all of the atoms in the segment at index segidx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::deselect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*deselect_function_type)( ::QSet< SireMol::AtomIdx > const & ) ;
            deselect_function_type deselect_function_value( &::SireMol::AtomSelection::deselect );
            
            AtomSelection_exposer.def( 
                "deselect"
                , deselect_function_value
                , ( bp::arg("atomidxs") )
                , bp::return_self< >()
                , "Deselect all of the atoms whose indicies are in atomidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::deselect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*deselect_function_type)( ::QSet< SireMol::CGIdx > const & ) ;
            deselect_function_type deselect_function_value( &::SireMol::AtomSelection::deselect );
            
            AtomSelection_exposer.def( 
                "deselect"
                , deselect_function_value
                , ( bp::arg("cgidxs") )
                , bp::return_self< >()
                , "Deselect all of the CutGroups whose indicies are in cgidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::deselect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*deselect_function_type)( ::QSet< SireMol::ResIdx > const & ) ;
            deselect_function_type deselect_function_value( &::SireMol::AtomSelection::deselect );
            
            AtomSelection_exposer.def( 
                "deselect"
                , deselect_function_value
                , ( bp::arg("residxs") )
                , bp::return_self< >()
                , "Deselect all of the atoms that are in the residues whose\nindicies are in residxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::deselect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*deselect_function_type)( ::QSet< SireMol::ChainIdx > const & ) ;
            deselect_function_type deselect_function_value( &::SireMol::AtomSelection::deselect );
            
            AtomSelection_exposer.def( 
                "deselect"
                , deselect_function_value
                , ( bp::arg("chainidxs") )
                , bp::return_self< >()
                , "Deselect the atoms that are in the chains whose indicies\nare in chainidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::deselect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*deselect_function_type)( ::QSet< SireMol::SegIdx > const & ) ;
            deselect_function_type deselect_function_value( &::SireMol::AtomSelection::deselect );
            
            AtomSelection_exposer.def( 
                "deselect"
                , deselect_function_value
                , ( bp::arg("segidxs") )
                , bp::return_self< >()
                , "Deselect all of the atoms in the segments whose indicies are\nin segidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::deselect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*deselect_function_type)( ::QList< SireMol::AtomIdx > const & ) ;
            deselect_function_type deselect_function_value( &::SireMol::AtomSelection::deselect );
            
            AtomSelection_exposer.def( 
                "deselect"
                , deselect_function_value
                , ( bp::arg("atomidxs") )
                , bp::return_self< >()
                , "Deselect all of the atoms whose indicies are in atomidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::deselect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*deselect_function_type)( ::QList< SireMol::CGIdx > const & ) ;
            deselect_function_type deselect_function_value( &::SireMol::AtomSelection::deselect );
            
            AtomSelection_exposer.def( 
                "deselect"
                , deselect_function_value
                , ( bp::arg("cgidxs") )
                , bp::return_self< >()
                , "Deselect all of the CutGroups whose indicies are in cgidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::deselect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*deselect_function_type)( ::QList< SireMol::ResIdx > const & ) ;
            deselect_function_type deselect_function_value( &::SireMol::AtomSelection::deselect );
            
            AtomSelection_exposer.def( 
                "deselect"
                , deselect_function_value
                , ( bp::arg("residxs") )
                , bp::return_self< >()
                , "Deselect all of the atoms that are in the residues whose\nindicies are in residxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::deselect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*deselect_function_type)( ::QList< SireMol::ChainIdx > const & ) ;
            deselect_function_type deselect_function_value( &::SireMol::AtomSelection::deselect );
            
            AtomSelection_exposer.def( 
                "deselect"
                , deselect_function_value
                , ( bp::arg("chainidxs") )
                , bp::return_self< >()
                , "Deselect the atoms that are in the chains whose indicies\nare in chainidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::deselect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*deselect_function_type)( ::QList< SireMol::SegIdx > const & ) ;
            deselect_function_type deselect_function_value( &::SireMol::AtomSelection::deselect );
            
            AtomSelection_exposer.def( 
                "deselect"
                , deselect_function_value
                , ( bp::arg("segidxs") )
                , bp::return_self< >()
                , "Deselect all of the atoms in the segments whose indicies are\nin segidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::deselect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*deselect_function_type)( ::SireMol::AtomID const & ) ;
            deselect_function_type deselect_function_value( &::SireMol::AtomSelection::deselect );
            
            AtomSelection_exposer.def( 
                "deselect"
                , deselect_function_value
                , ( bp::arg("atomid") )
                , bp::return_self< >()
                , "Deselect all of the atoms that match atomid\nThrow: SireMol::missing_atom\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::deselect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*deselect_function_type)( ::SireMol::CGID const & ) ;
            deselect_function_type deselect_function_value( &::SireMol::AtomSelection::deselect );
            
            AtomSelection_exposer.def( 
                "deselect"
                , deselect_function_value
                , ( bp::arg("cgid") )
                , bp::return_self< >()
                , "Deselect the atoms in the CutGroups that match cgid\nThrow: SireMol::missing_cutgroup\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::deselect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*deselect_function_type)( ::SireMol::ResID const & ) ;
            deselect_function_type deselect_function_value( &::SireMol::AtomSelection::deselect );
            
            AtomSelection_exposer.def( 
                "deselect"
                , deselect_function_value
                , ( bp::arg("resid") )
                , bp::return_self< >()
                , "Deselect the atoms in the residues that match resid\nThrow: SireMol::missing_residue\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::deselect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*deselect_function_type)( ::SireMol::ChainID const & ) ;
            deselect_function_type deselect_function_value( &::SireMol::AtomSelection::deselect );
            
            AtomSelection_exposer.def( 
                "deselect"
                , deselect_function_value
                , ( bp::arg("chainid") )
                , bp::return_self< >()
                , "Deselect the atoms in the chains that match chainid\nThrow: SireMol::missing_chain\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::deselect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*deselect_function_type)( ::SireMol::SegID const & ) ;
            deselect_function_type deselect_function_value( &::SireMol::AtomSelection::deselect );
            
            AtomSelection_exposer.def( 
                "deselect"
                , deselect_function_value
                , ( bp::arg("segid") )
                , bp::return_self< >()
                , "Deselect all of the atoms in the segments that match segid\nThrow: SireMol::missing_segment\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::deselect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*deselect_function_type)( ::SireMol::AtomSelection const & ) ;
            deselect_function_type deselect_function_value( &::SireMol::AtomSelection::deselect );
            
            AtomSelection_exposer.def( 
                "deselect"
                , deselect_function_value
                , ( bp::arg("selection") )
                , bp::return_self< >()
                , "Deselect all of the atoms in selection\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireMol::AtomSelection::deselectAll
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*deselectAll_function_type)(  ) ;
            deselectAll_function_type deselectAll_function_value( &::SireMol::AtomSelection::deselectAll );
            
            AtomSelection_exposer.def( 
                "deselectAll"
                , deselectAll_function_value
                , bp::return_self< >()
                , "Return a selection that has none of the atoms selected" );
        
        }
        { //::SireMol::AtomSelection::info
        
            typedef ::SireMol::MoleculeInfoData const & ( ::SireMol::AtomSelection::*info_function_type)(  ) const;
            info_function_type info_function_value( &::SireMol::AtomSelection::info );
            
            AtomSelection_exposer.def( 
                "info"
                , info_function_value
                , bp::return_value_policy< bp::copy_const_reference >()
                , "Return the info object for the molecule whose atoms\nare being selected" );
        
        }
        { //::SireMol::AtomSelection::intersect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*intersect_function_type)( ::SireMol::AtomIdx ) ;
            intersect_function_type intersect_function_value( &::SireMol::AtomSelection::intersect );
            
            AtomSelection_exposer.def( 
                "intersect"
                , intersect_function_value
                , ( bp::arg("atomidx") )
                , bp::return_self< >()
                , "Intersect this selection with the index atomidx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::intersect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*intersect_function_type)( ::SireMol::CGIdx ) ;
            intersect_function_type intersect_function_value( &::SireMol::AtomSelection::intersect );
            
            AtomSelection_exposer.def( 
                "intersect"
                , intersect_function_value
                , ( bp::arg("cgidx") )
                , bp::return_self< >()
                , "Intersect this selection with the index cgidx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::intersect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*intersect_function_type)( ::SireMol::ResIdx ) ;
            intersect_function_type intersect_function_value( &::SireMol::AtomSelection::intersect );
            
            AtomSelection_exposer.def( 
                "intersect"
                , intersect_function_value
                , ( bp::arg("residx") )
                , bp::return_self< >()
                , "Intersect this selection with the index residx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::intersect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*intersect_function_type)( ::SireMol::ChainIdx ) ;
            intersect_function_type intersect_function_value( &::SireMol::AtomSelection::intersect );
            
            AtomSelection_exposer.def( 
                "intersect"
                , intersect_function_value
                , ( bp::arg("chainidx") )
                , bp::return_self< >()
                , "Intersect this selection with the index chainidx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::intersect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*intersect_function_type)( ::SireMol::SegIdx ) ;
            intersect_function_type intersect_function_value( &::SireMol::AtomSelection::intersect );
            
            AtomSelection_exposer.def( 
                "intersect"
                , intersect_function_value
                , ( bp::arg("segidx") )
                , bp::return_self< >()
                , "Intersect this selection with the index segidx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::intersect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*intersect_function_type)( ::QSet< SireMol::AtomIdx > const & ) ;
            intersect_function_type intersect_function_value( &::SireMol::AtomSelection::intersect );
            
            AtomSelection_exposer.def( 
                "intersect"
                , intersect_function_value
                , ( bp::arg("atomidx") )
                , bp::return_self< >()
                , "Intersect this with the atoms whose indicies are in atomidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::intersect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*intersect_function_type)( ::QSet< SireMol::CGIdx > const & ) ;
            intersect_function_type intersect_function_value( &::SireMol::AtomSelection::intersect );
            
            AtomSelection_exposer.def( 
                "intersect"
                , intersect_function_value
                , ( bp::arg("cgidx") )
                , bp::return_self< >()
                , "Intersect this with the atoms in the CutGroups whose indicies\nare in cgidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::intersect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*intersect_function_type)( ::QSet< SireMol::ResIdx > const & ) ;
            intersect_function_type intersect_function_value( &::SireMol::AtomSelection::intersect );
            
            AtomSelection_exposer.def( 
                "intersect"
                , intersect_function_value
                , ( bp::arg("residx") )
                , bp::return_self< >()
                , "Intersect this with the atoms in the residues whose indicies are\nin residxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::intersect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*intersect_function_type)( ::QSet< SireMol::ChainIdx > const & ) ;
            intersect_function_type intersect_function_value( &::SireMol::AtomSelection::intersect );
            
            AtomSelection_exposer.def( 
                "intersect"
                , intersect_function_value
                , ( bp::arg("chainidx") )
                , bp::return_self< >()
                , "Intersect this with the atoms in the chains whose indicies are\nin chainidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::intersect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*intersect_function_type)( ::QSet< SireMol::SegIdx > const & ) ;
            intersect_function_type intersect_function_value( &::SireMol::AtomSelection::intersect );
            
            AtomSelection_exposer.def( 
                "intersect"
                , intersect_function_value
                , ( bp::arg("segidx") )
                , bp::return_self< >()
                , "Intersect this with the atoms in the segments whose indicies are\nin segidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::intersect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*intersect_function_type)( ::QList< SireMol::AtomIdx > const & ) ;
            intersect_function_type intersect_function_value( &::SireMol::AtomSelection::intersect );
            
            AtomSelection_exposer.def( 
                "intersect"
                , intersect_function_value
                , ( bp::arg("atomidx") )
                , bp::return_self< >()
                , "Intersect this with the atoms whose indicies are in atomidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::intersect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*intersect_function_type)( ::QList< SireMol::CGIdx > const & ) ;
            intersect_function_type intersect_function_value( &::SireMol::AtomSelection::intersect );
            
            AtomSelection_exposer.def( 
                "intersect"
                , intersect_function_value
                , ( bp::arg("cgidx") )
                , bp::return_self< >()
                , "Intersect this with the atoms in the CutGroups whose indicies\nare in cgidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::intersect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*intersect_function_type)( ::QList< SireMol::ResIdx > const & ) ;
            intersect_function_type intersect_function_value( &::SireMol::AtomSelection::intersect );
            
            AtomSelection_exposer.def( 
                "intersect"
                , intersect_function_value
                , ( bp::arg("residx") )
                , bp::return_self< >()
                , "Intersect this with the atoms in the residues whose indicies are\nin residxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::intersect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*intersect_function_type)( ::QList< SireMol::ChainIdx > const & ) ;
            intersect_function_type intersect_function_value( &::SireMol::AtomSelection::intersect );
            
            AtomSelection_exposer.def( 
                "intersect"
                , intersect_function_value
                , ( bp::arg("chainidx") )
                , bp::return_self< >()
                , "Intersect this with the atoms in the chains whose indicies are\nin chainidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::intersect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*intersect_function_type)( ::QList< SireMol::SegIdx > const & ) ;
            intersect_function_type intersect_function_value( &::SireMol::AtomSelection::intersect );
            
            AtomSelection_exposer.def( 
                "intersect"
                , intersect_function_value
                , ( bp::arg("segidx") )
                , bp::return_self< >()
                , "Intersect this with the atoms in the segments whose indicies are\nin segidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::intersect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*intersect_function_type)( ::SireMol::AtomID const & ) ;
            intersect_function_type intersect_function_value( &::SireMol::AtomSelection::intersect );
            
            AtomSelection_exposer.def( 
                "intersect"
                , intersect_function_value
                , ( bp::arg("atomid") )
                , bp::return_self< >()
                , "Intersect this set with the atoms that match\nthe ID atomid\nThrow: SireMol::missing_atom\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::intersect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*intersect_function_type)( ::SireMol::CGID const & ) ;
            intersect_function_type intersect_function_value( &::SireMol::AtomSelection::intersect );
            
            AtomSelection_exposer.def( 
                "intersect"
                , intersect_function_value
                , ( bp::arg("cgid") )
                , bp::return_self< >()
                , "Intersect this set with the atoms in the\nCutGroup(s) that match the ID cgid\nThrow: SireMol::missing_cutgroup\n" );
        
        }
        { //::SireMol::AtomSelection::intersect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*intersect_function_type)( ::SireMol::ResID const & ) ;
            intersect_function_type intersect_function_value( &::SireMol::AtomSelection::intersect );
            
            AtomSelection_exposer.def( 
                "intersect"
                , intersect_function_value
                , ( bp::arg("resid") )
                , bp::return_self< >()
                , "Intersect this set with the atoms in the\nresidue(s) that match the ID resid\nThrow: SireMol::missing_residue\n" );
        
        }
        { //::SireMol::AtomSelection::intersect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*intersect_function_type)( ::SireMol::ChainID const & ) ;
            intersect_function_type intersect_function_value( &::SireMol::AtomSelection::intersect );
            
            AtomSelection_exposer.def( 
                "intersect"
                , intersect_function_value
                , ( bp::arg("chainid") )
                , bp::return_self< >()
                , "Intersect this set with the atoms in the\nchain(s) that match the ID chainid\nThrow: SireMol::missing_chain\n" );
        
        }
        { //::SireMol::AtomSelection::intersect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*intersect_function_type)( ::SireMol::SegID const & ) ;
            intersect_function_type intersect_function_value( &::SireMol::AtomSelection::intersect );
            
            AtomSelection_exposer.def( 
                "intersect"
                , intersect_function_value
                , ( bp::arg("segid") )
                , bp::return_self< >()
                , "Intersect this set with the atoms in the\nsegment(s) that match the ID segid\nThrow: SireMol::missing_segment\n" );
        
        }
        { //::SireMol::AtomSelection::intersect
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*intersect_function_type)( ::SireMol::AtomSelection const & ) ;
            intersect_function_type intersect_function_value( &::SireMol::AtomSelection::intersect );
            
            AtomSelection_exposer.def( 
                "intersect"
                , intersect_function_value
                , ( bp::arg("selection") )
                , bp::return_self< >()
                , "Intersect this selection with other\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireMol::AtomSelection::intersects
        
            typedef bool ( ::SireMol::AtomSelection::*intersects_function_type)( ::SireMol::AtomIdx ) const;
            intersects_function_type intersects_function_value( &::SireMol::AtomSelection::intersects );
            
            AtomSelection_exposer.def( 
                "intersects"
                , intersects_function_value
                , ( bp::arg("atomidx") )
                , bp::release_gil_policy()
                , "Return whether or not this contains the atom at index atomidx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::intersects
        
            typedef bool ( ::SireMol::AtomSelection::*intersects_function_type)( ::SireMol::CGIdx ) const;
            intersects_function_type intersects_function_value( &::SireMol::AtomSelection::intersects );
            
            AtomSelection_exposer.def( 
                "intersects"
                , intersects_function_value
                , ( bp::arg("cgidx") )
                , bp::release_gil_policy()
                , "Return whether or not the CutGroup at index cgidx contains\nsome atoms that have been selected\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::intersects
        
            typedef bool ( ::SireMol::AtomSelection::*intersects_function_type)( ::SireMol::ResIdx ) const;
            intersects_function_type intersects_function_value( &::SireMol::AtomSelection::intersects );
            
            AtomSelection_exposer.def( 
                "intersects"
                , intersects_function_value
                , ( bp::arg("residx") )
                , bp::release_gil_policy()
                , "Return whether or not the residue at index residx contains\nsome atoms that have been selected\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::intersects
        
            typedef bool ( ::SireMol::AtomSelection::*intersects_function_type)( ::SireMol::ChainIdx ) const;
            intersects_function_type intersects_function_value( &::SireMol::AtomSelection::intersects );
            
            AtomSelection_exposer.def( 
                "intersects"
                , intersects_function_value
                , ( bp::arg("chainidx") )
                , bp::release_gil_policy()
                , "Return whether or not the chain at index chainidx contains\nsome atoms that have been selected\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::intersects
        
            typedef bool ( ::SireMol::AtomSelection::*intersects_function_type)( ::SireMol::SegIdx ) const;
            intersects_function_type intersects_function_value( &::SireMol::AtomSelection::intersects );
            
            AtomSelection_exposer.def( 
                "intersects"
                , intersects_function_value
                , ( bp::arg("segidx") )
                , bp::release_gil_policy()
                , "Return whether or not the segment at index segidx contains\nsome atoms that have been selected\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::intersects
        
            typedef bool ( ::SireMol::AtomSelection::*intersects_function_type)( ::SireMol::AtomID const & ) const;
            intersects_function_type intersects_function_value( &::SireMol::AtomSelection::intersects );
            
            AtomSelection_exposer.def( 
                "intersects"
                , intersects_function_value
                , ( bp::arg("atomid") )
                , bp::release_gil_policy()
                , "Return whether or not any of the atoms identified\nby atomid have been selected\nThrow: SireMol::missing_atom\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::intersects
        
            typedef bool ( ::SireMol::AtomSelection::*intersects_function_type)( ::SireMol::CGID const & ) const;
            intersects_function_type intersects_function_value( &::SireMol::AtomSelection::intersects );
            
            AtomSelection_exposer.def( 
                "intersects"
                , intersects_function_value
                , ( bp::arg("cgid") )
                , bp::release_gil_policy()
                , "Return whether or not any of the atoms in the CutGroup(s) identified\nby cgid have been selected\nThrow: SireMol::missing_cutgroup\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::intersects
        
            typedef bool ( ::SireMol::AtomSelection::*intersects_function_type)( ::SireMol::ResID const & ) const;
            intersects_function_type intersects_function_value( &::SireMol::AtomSelection::intersects );
            
            AtomSelection_exposer.def( 
                "intersects"
                , intersects_function_value
                , ( bp::arg("resid") )
                , bp::release_gil_policy()
                , "Return whether or not any of the atoms in the residue(s) identified\nby resid have been selected\nThrow: SireMol::missing_residue\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::intersects
        
            typedef bool ( ::SireMol::AtomSelection::*intersects_function_type)( ::SireMol::ChainID const & ) const;
            intersects_function_type intersects_function_value( &::SireMol::AtomSelection::intersects );
            
            AtomSelection_exposer.def( 
                "intersects"
                , intersects_function_value
                , ( bp::arg("chainid") )
                , bp::release_gil_policy()
                , "Return whether or not any of the atoms in the chain(s) identified\nby chainid have been selected\nThrow: SireMol::missing_chain\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::intersects
        
            typedef bool ( ::SireMol::AtomSelection::*intersects_function_type)( ::SireMol::SegID const & ) const;
            intersects_function_type intersects_function_value( &::SireMol::AtomSelection::intersects );
            
            AtomSelection_exposer.def( 
                "intersects"
                , intersects_function_value
                , ( bp::arg("segid") )
                , bp::release_gil_policy()
                , "Return whether or not any of the atoms in the segment(s) identified\nby segid have been selected\nThrow: SireMol::missing_segment\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::intersects
        
            typedef bool ( ::SireMol::AtomSelection::*intersects_function_type)( ::SireMol::AtomSelection const & ) const;
            intersects_function_type intersects_function_value( &::SireMol::AtomSelection::intersects );
            
            AtomSelection_exposer.def( 
                "intersects"
                , intersects_function_value
                , ( bp::arg("selection") )
                , bp::release_gil_policy()
                , "Return whether any of the atoms selected in selection\nare also selected in this set\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireMol::AtomSelection::invert
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*invert_function_type)(  ) ;
            invert_function_type invert_function_value( &::SireMol::AtomSelection::invert );
            
            AtomSelection_exposer.def( 
                "invert"
                , invert_function_value
                , bp::return_self< >()
                , "Invert this selection" );
        
        }
        { //::SireMol::AtomSelection::isAtom
        
            typedef bool ( ::SireMol::AtomSelection::*isAtom_function_type)(  ) const;
            isAtom_function_type isAtom_function_value( &::SireMol::AtomSelection::isAtom );
            
            AtomSelection_exposer.def( 
                "isAtom"
                , isAtom_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireMol::AtomSelection::isChain
        
            typedef bool ( ::SireMol::AtomSelection::*isChain_function_type)(  ) const;
            isChain_function_type isChain_function_value( &::SireMol::AtomSelection::isChain );
            
            AtomSelection_exposer.def( 
                "isChain"
                , isChain_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireMol::AtomSelection::isCompatibleWith
        
            typedef bool ( ::SireMol::AtomSelection::*isCompatibleWith_function_type)( ::SireMol::MoleculeInfoData const & ) const;
            isCompatibleWith_function_type isCompatibleWith_function_value( &::SireMol::AtomSelection::isCompatibleWith );
            
            AtomSelection_exposer.def( 
                "isCompatibleWith"
                , isCompatibleWith_function_value
                , ( bp::arg("molinfo") )
                , bp::release_gil_policy()
                , "Return whether or not this selection is compatible with the molecule info\nin molinfo" );
        
        }
        { //::SireMol::AtomSelection::isCutGroup
        
            typedef bool ( ::SireMol::AtomSelection::*isCutGroup_function_type)(  ) const;
            isCutGroup_function_type isCutGroup_function_value( &::SireMol::AtomSelection::isCutGroup );
            
            AtomSelection_exposer.def( 
                "isCutGroup"
                , isCutGroup_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireMol::AtomSelection::isEmpty
        
            typedef bool ( ::SireMol::AtomSelection::*isEmpty_function_type)(  ) const;
            isEmpty_function_type isEmpty_function_value( &::SireMol::AtomSelection::isEmpty );
            
            AtomSelection_exposer.def( 
                "isEmpty"
                , isEmpty_function_value
                , bp::release_gil_policy()
                , "Return wheter no atoms are selected" );
        
        }
        { //::SireMol::AtomSelection::isMolecule
        
            typedef bool ( ::SireMol::AtomSelection::*isMolecule_function_type)(  ) const;
            isMolecule_function_type isMolecule_function_value( &::SireMol::AtomSelection::isMolecule );
            
            AtomSelection_exposer.def( 
                "isMolecule"
                , isMolecule_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireMol::AtomSelection::isNull
        
            typedef bool ( ::SireMol::AtomSelection::*isNull_function_type)(  ) const;
            isNull_function_type isNull_function_value( &::SireMol::AtomSelection::isNull );
            
            AtomSelection_exposer.def( 
                "isNull"
                , isNull_function_value
                , bp::release_gil_policy()
                , "Return whether or not this is a null selection" );
        
        }
        { //::SireMol::AtomSelection::isResidue
        
            typedef bool ( ::SireMol::AtomSelection::*isResidue_function_type)(  ) const;
            isResidue_function_type isResidue_function_value( &::SireMol::AtomSelection::isResidue );
            
            AtomSelection_exposer.def( 
                "isResidue"
                , isResidue_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireMol::AtomSelection::isSegment
        
            typedef bool ( ::SireMol::AtomSelection::*isSegment_function_type)(  ) const;
            isSegment_function_type isSegment_function_value( &::SireMol::AtomSelection::isSegment );
            
            AtomSelection_exposer.def( 
                "isSegment"
                , isSegment_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireMol::AtomSelection::mask
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*mask_function_type)( ::SireMol::AtomIdx ) ;
            mask_function_type mask_function_value( &::SireMol::AtomSelection::mask );
            
            AtomSelection_exposer.def( 
                "mask"
                , mask_function_value
                , ( bp::arg("atomidx") )
                , bp::return_self< >()
                , "Mask this selection by the\natom at index atomidx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::mask
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*mask_function_type)( ::SireMol::CGIdx ) ;
            mask_function_type mask_function_value( &::SireMol::AtomSelection::mask );
            
            AtomSelection_exposer.def( 
                "mask"
                , mask_function_value
                , ( bp::arg("cgidx") )
                , bp::return_self< >()
                , "Mask this selection by the\nCutGroup at index cgidx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::mask
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*mask_function_type)( ::SireMol::ResIdx ) ;
            mask_function_type mask_function_value( &::SireMol::AtomSelection::mask );
            
            AtomSelection_exposer.def( 
                "mask"
                , mask_function_value
                , ( bp::arg("residx") )
                , bp::return_self< >()
                , "Mask this selection by the\nresidue at index residx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::mask
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*mask_function_type)( ::SireMol::ChainIdx ) ;
            mask_function_type mask_function_value( &::SireMol::AtomSelection::mask );
            
            AtomSelection_exposer.def( 
                "mask"
                , mask_function_value
                , ( bp::arg("chainidx") )
                , bp::return_self< >()
                , "Mask this selection by the\nchain at index chainidx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::mask
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*mask_function_type)( ::SireMol::SegIdx ) ;
            mask_function_type mask_function_value( &::SireMol::AtomSelection::mask );
            
            AtomSelection_exposer.def( 
                "mask"
                , mask_function_value
                , ( bp::arg("segidx") )
                , bp::return_self< >()
                , "Mask this selection by the\nsegment at index segidx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::mask
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*mask_function_type)( ::QSet< SireMol::AtomIdx > const & ) ;
            mask_function_type mask_function_value( &::SireMol::AtomSelection::mask );
            
            AtomSelection_exposer.def( 
                "mask"
                , mask_function_value
                , ( bp::arg("atomidx") )
                , bp::return_self< >()
                , "Mask this selection by the\nindicies are in atomidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::mask
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*mask_function_type)( ::QSet< SireMol::CGIdx > const & ) ;
            mask_function_type mask_function_value( &::SireMol::AtomSelection::mask );
            
            AtomSelection_exposer.def( 
                "mask"
                , mask_function_value
                , ( bp::arg("cgidx") )
                , bp::return_self< >()
                , "Mask this selection by the\nCutGroups whose indicies are in cgidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::mask
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*mask_function_type)( ::QSet< SireMol::ResIdx > const & ) ;
            mask_function_type mask_function_value( &::SireMol::AtomSelection::mask );
            
            AtomSelection_exposer.def( 
                "mask"
                , mask_function_value
                , ( bp::arg("residx") )
                , bp::return_self< >()
                , "Mask this selection by the\nresidues whose indicies are in residxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::mask
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*mask_function_type)( ::QSet< SireMol::ChainIdx > const & ) ;
            mask_function_type mask_function_value( &::SireMol::AtomSelection::mask );
            
            AtomSelection_exposer.def( 
                "mask"
                , mask_function_value
                , ( bp::arg("chainidx") )
                , bp::return_self< >()
                , "Mask this selection by the\nchains whose indicies are in chainidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::mask
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*mask_function_type)( ::QSet< SireMol::SegIdx > const & ) ;
            mask_function_type mask_function_value( &::SireMol::AtomSelection::mask );
            
            AtomSelection_exposer.def( 
                "mask"
                , mask_function_value
                , ( bp::arg("segidx") )
                , bp::return_self< >()
                , "Mask this selection by the\nsegments whose indicies are in segidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::mask
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*mask_function_type)( ::QList< SireMol::AtomIdx > const & ) ;
            mask_function_type mask_function_value( &::SireMol::AtomSelection::mask );
            
            AtomSelection_exposer.def( 
                "mask"
                , mask_function_value
                , ( bp::arg("atomidx") )
                , bp::return_self< >()
                , "Mask this selection by the\nindicies are in atomidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::mask
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*mask_function_type)( ::QList< SireMol::CGIdx > const & ) ;
            mask_function_type mask_function_value( &::SireMol::AtomSelection::mask );
            
            AtomSelection_exposer.def( 
                "mask"
                , mask_function_value
                , ( bp::arg("cgidx") )
                , bp::return_self< >()
                , "Mask this selection by the\nCutGroups whose indicies are in cgidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::mask
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*mask_function_type)( ::QList< SireMol::ResIdx > const & ) ;
            mask_function_type mask_function_value( &::SireMol::AtomSelection::mask );
            
            AtomSelection_exposer.def( 
                "mask"
                , mask_function_value
                , ( bp::arg("residx") )
                , bp::return_self< >()
                , "Mask this selection by the\nresidues whose indicies are in residxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::mask
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*mask_function_type)( ::QList< SireMol::ChainIdx > const & ) ;
            mask_function_type mask_function_value( &::SireMol::AtomSelection::mask );
            
            AtomSelection_exposer.def( 
                "mask"
                , mask_function_value
                , ( bp::arg("chainidx") )
                , bp::return_self< >()
                , "Mask this selection by the\nchains whose indicies are in chainidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::mask
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*mask_function_type)( ::QList< SireMol::SegIdx > const & ) ;
            mask_function_type mask_function_value( &::SireMol::AtomSelection::mask );
            
            AtomSelection_exposer.def( 
                "mask"
                , mask_function_value
                , ( bp::arg("segidx") )
                , bp::return_self< >()
                , "Mask this selection by the\nsegments whose indicies are in segidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::mask
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*mask_function_type)( ::SireMol::AtomID const & ) ;
            mask_function_type mask_function_value( &::SireMol::AtomSelection::mask );
            
            AtomSelection_exposer.def( 
                "mask"
                , mask_function_value
                , ( bp::arg("atomid") )
                , bp::return_self< >()
                , "Mask this selection by the\natoms that match the ID atomid\nThrow: SireMol::missing_atom\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::mask
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*mask_function_type)( ::SireMol::CGID const & ) ;
            mask_function_type mask_function_value( &::SireMol::AtomSelection::mask );
            
            AtomSelection_exposer.def( 
                "mask"
                , mask_function_value
                , ( bp::arg("cgid") )
                , bp::return_self< >()
                , "Mask this selection by the\nCutGroups that match the ID cgid\nThrow: SireMol::missing_cutgroup\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::mask
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*mask_function_type)( ::SireMol::ResID const & ) ;
            mask_function_type mask_function_value( &::SireMol::AtomSelection::mask );
            
            AtomSelection_exposer.def( 
                "mask"
                , mask_function_value
                , ( bp::arg("resid") )
                , bp::return_self< >()
                , "Mask this selection by the\nresidues that match the ID atomid\nThrow: SireMol::missing_residue\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::mask
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*mask_function_type)( ::SireMol::ChainID const & ) ;
            mask_function_type mask_function_value( &::SireMol::AtomSelection::mask );
            
            AtomSelection_exposer.def( 
                "mask"
                , mask_function_value
                , ( bp::arg("chainid") )
                , bp::return_self< >()
                , "Mask this selection by the\nchains that match the ID chainid\nThrow: SireMol::missing_chain\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::mask
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*mask_function_type)( ::SireMol::SegID const & ) ;
            mask_function_type mask_function_value( &::SireMol::AtomSelection::mask );
            
            AtomSelection_exposer.def( 
                "mask"
                , mask_function_value
                , ( bp::arg("segid") )
                , bp::return_self< >()
                , "Mask this selection by the\nsegments that match the ID atomid\nThrow: SireMol::missing_segments\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::mask
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*mask_function_type)( ::SireMol::AtomSelection const & ) ;
            mask_function_type mask_function_value( &::SireMol::AtomSelection::mask );
            
            AtomSelection_exposer.def( 
                "mask"
                , mask_function_value
                , ( bp::arg("selection") )
                , bp::return_self< >()
                , "Mask this selection by other\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireMol::AtomSelection::nAtoms
        
            typedef int ( ::SireMol::AtomSelection::*nAtoms_function_type)(  ) const;
            nAtoms_function_type nAtoms_function_value( &::SireMol::AtomSelection::nAtoms );
            
            AtomSelection_exposer.def( 
                "nAtoms"
                , nAtoms_function_value
                , bp::release_gil_policy()
                , "Return the total number of atoms in the molecule" );
        
        }
        { //::SireMol::AtomSelection::nChains
        
            typedef int ( ::SireMol::AtomSelection::*nChains_function_type)(  ) const;
            nChains_function_type nChains_function_value( &::SireMol::AtomSelection::nChains );
            
            AtomSelection_exposer.def( 
                "nChains"
                , nChains_function_value
                , bp::release_gil_policy()
                , "Return the total number of chains in the molecule" );
        
        }
        { //::SireMol::AtomSelection::nCutGroups
        
            typedef int ( ::SireMol::AtomSelection::*nCutGroups_function_type)(  ) const;
            nCutGroups_function_type nCutGroups_function_value( &::SireMol::AtomSelection::nCutGroups );
            
            AtomSelection_exposer.def( 
                "nCutGroups"
                , nCutGroups_function_value
                , bp::release_gil_policy()
                , "Return the total number of CutGroups in the molecule" );
        
        }
        { //::SireMol::AtomSelection::nResidues
        
            typedef int ( ::SireMol::AtomSelection::*nResidues_function_type)(  ) const;
            nResidues_function_type nResidues_function_value( &::SireMol::AtomSelection::nResidues );
            
            AtomSelection_exposer.def( 
                "nResidues"
                , nResidues_function_value
                , bp::release_gil_policy()
                , "Return the total number of residues in the molecule" );
        
        }
        { //::SireMol::AtomSelection::nSegments
        
            typedef int ( ::SireMol::AtomSelection::*nSegments_function_type)(  ) const;
            nSegments_function_type nSegments_function_value( &::SireMol::AtomSelection::nSegments );
            
            AtomSelection_exposer.def( 
                "nSegments"
                , nSegments_function_value
                , bp::release_gil_policy()
                , "Return the total number of segments in this molecule" );
        
        }
        { //::SireMol::AtomSelection::nSelected
        
            typedef int ( ::SireMol::AtomSelection::*nSelected_function_type)(  ) const;
            nSelected_function_type nSelected_function_value( &::SireMol::AtomSelection::nSelected );
            
            AtomSelection_exposer.def( 
                "nSelected"
                , nSelected_function_value
                , bp::release_gil_policy()
                , "Return the number of selected atoms" );
        
        }
        { //::SireMol::AtomSelection::nSelected
        
            typedef int ( ::SireMol::AtomSelection::*nSelected_function_type)( ::SireMol::CGIdx ) const;
            nSelected_function_type nSelected_function_value( &::SireMol::AtomSelection::nSelected );
            
            AtomSelection_exposer.def( 
                "nSelected"
                , nSelected_function_value
                , ( bp::arg("cgidx") )
                , bp::release_gil_policy()
                , "Return the number of atoms selected in the CutGroup at\nindex cgidx" );
        
        }
        { //::SireMol::AtomSelection::nSelected
        
            typedef int ( ::SireMol::AtomSelection::*nSelected_function_type)( ::SireMol::AtomIdx ) const;
            nSelected_function_type nSelected_function_value( &::SireMol::AtomSelection::nSelected );
            
            AtomSelection_exposer.def( 
                "nSelected"
                , nSelected_function_value
                , ( bp::arg("atomidx") )
                , bp::release_gil_policy()
                , "Return whether the atom at index atomidx has been selected\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::nSelected
        
            typedef int ( ::SireMol::AtomSelection::*nSelected_function_type)( ::SireMol::ResIdx ) const;
            nSelected_function_type nSelected_function_value( &::SireMol::AtomSelection::nSelected );
            
            AtomSelection_exposer.def( 
                "nSelected"
                , nSelected_function_value
                , ( bp::arg("residx") )
                , bp::release_gil_policy()
                , "Return the number of atoms from the residue at index residx\nthat have been selected\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::nSelected
        
            typedef int ( ::SireMol::AtomSelection::*nSelected_function_type)( ::SireMol::ChainIdx ) const;
            nSelected_function_type nSelected_function_value( &::SireMol::AtomSelection::nSelected );
            
            AtomSelection_exposer.def( 
                "nSelected"
                , nSelected_function_value
                , ( bp::arg("chainidx") )
                , bp::release_gil_policy()
                , "Return the number of atoms from the chain at index chainidx\nthat have been selected\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::nSelected
        
            typedef int ( ::SireMol::AtomSelection::*nSelected_function_type)( ::SireMol::SegIdx ) const;
            nSelected_function_type nSelected_function_value( &::SireMol::AtomSelection::nSelected );
            
            AtomSelection_exposer.def( 
                "nSelected"
                , nSelected_function_value
                , ( bp::arg("segidx") )
                , bp::release_gil_policy()
                , "Return the number of atoms from the segment at index segidx\nthat have been selected\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::nSelected
        
            typedef int ( ::SireMol::AtomSelection::*nSelected_function_type)( ::SireMol::CGID const & ) const;
            nSelected_function_type nSelected_function_value( &::SireMol::AtomSelection::nSelected );
            
            AtomSelection_exposer.def( 
                "nSelected"
                , nSelected_function_value
                , ( bp::arg("cgid") )
                , bp::release_gil_policy()
                , "Return the number of atoms from the CutGroups identified\nby cgid that have been selected\nThrow: SireMol::missing_cutgroup\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::nSelected
        
            typedef int ( ::SireMol::AtomSelection::*nSelected_function_type)( ::SireMol::AtomID const & ) const;
            nSelected_function_type nSelected_function_value( &::SireMol::AtomSelection::nSelected );
            
            AtomSelection_exposer.def( 
                "nSelected"
                , nSelected_function_value
                , ( bp::arg("atomid") )
                , bp::release_gil_policy()
                , "Return the number of atoms that are identified by\natomid that have been selected\nThrow: SireMol::missing_atom\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::nSelected
        
            typedef int ( ::SireMol::AtomSelection::*nSelected_function_type)( ::SireMol::ResID const & ) const;
            nSelected_function_type nSelected_function_value( &::SireMol::AtomSelection::nSelected );
            
            AtomSelection_exposer.def( 
                "nSelected"
                , nSelected_function_value
                , ( bp::arg("resid") )
                , bp::release_gil_policy()
                , "Return the number of atoms from the residues identified\nby resid that have been selected\nThrow: SireMol::missing_residue\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::nSelected
        
            typedef int ( ::SireMol::AtomSelection::*nSelected_function_type)( ::SireMol::ChainID const & ) const;
            nSelected_function_type nSelected_function_value( &::SireMol::AtomSelection::nSelected );
            
            AtomSelection_exposer.def( 
                "nSelected"
                , nSelected_function_value
                , ( bp::arg("chainid") )
                , bp::release_gil_policy()
                , "Return the number of atoms from the chain(s) identified\nby chainid that have been selected\nThrow: SireMol::missing_chain\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::nSelected
        
            typedef int ( ::SireMol::AtomSelection::*nSelected_function_type)( ::SireMol::SegID const & ) const;
            nSelected_function_type nSelected_function_value( &::SireMol::AtomSelection::nSelected );
            
            AtomSelection_exposer.def( 
                "nSelected"
                , nSelected_function_value
                , ( bp::arg("segid") )
                , bp::release_gil_policy()
                , "Return the number of atoms from the segment(s)\nidentified by segid that have been selected\nThrow: SireMol::missing_segment\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::nSelected
        
            typedef int ( ::SireMol::AtomSelection::*nSelected_function_type)( ::SireMol::AtomSelection const & ) const;
            nSelected_function_type nSelected_function_value( &::SireMol::AtomSelection::nSelected );
            
            AtomSelection_exposer.def( 
                "nSelected"
                , nSelected_function_value
                , ( bp::arg("selection") )
                , bp::release_gil_policy()
                , "Return the number of atoms from the passed selection\nthat have also been selected in this selection\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireMol::AtomSelection::nSelectedAtoms
        
            typedef int ( ::SireMol::AtomSelection::*nSelectedAtoms_function_type)(  ) const;
            nSelectedAtoms_function_type nSelectedAtoms_function_value( &::SireMol::AtomSelection::nSelectedAtoms );
            
            AtomSelection_exposer.def( 
                "nSelectedAtoms"
                , nSelectedAtoms_function_value
                , bp::release_gil_policy()
                , "Return the total number of selected atoms" );
        
        }
        { //::SireMol::AtomSelection::nSelectedChains
        
            typedef int ( ::SireMol::AtomSelection::*nSelectedChains_function_type)(  ) const;
            nSelectedChains_function_type nSelectedChains_function_value( &::SireMol::AtomSelection::nSelectedChains );
            
            AtomSelection_exposer.def( 
                "nSelectedChains"
                , nSelectedChains_function_value
                , bp::release_gil_policy()
                , "Return the number of chains that have at least one selected atom" );
        
        }
        { //::SireMol::AtomSelection::nSelectedCutGroups
        
            typedef int ( ::SireMol::AtomSelection::*nSelectedCutGroups_function_type)(  ) const;
            nSelectedCutGroups_function_type nSelectedCutGroups_function_value( &::SireMol::AtomSelection::nSelectedCutGroups );
            
            AtomSelection_exposer.def( 
                "nSelectedCutGroups"
                , nSelectedCutGroups_function_value
                , bp::release_gil_policy()
                , "Return the number of CutGroups that have at least\none selected atom" );
        
        }
        { //::SireMol::AtomSelection::nSelectedResidues
        
            typedef int ( ::SireMol::AtomSelection::*nSelectedResidues_function_type)(  ) const;
            nSelectedResidues_function_type nSelectedResidues_function_value( &::SireMol::AtomSelection::nSelectedResidues );
            
            AtomSelection_exposer.def( 
                "nSelectedResidues"
                , nSelectedResidues_function_value
                , bp::release_gil_policy()
                , "Return the number of residues that contain at\nleast one selected atom" );
        
        }
        { //::SireMol::AtomSelection::nSelectedSegments
        
            typedef int ( ::SireMol::AtomSelection::*nSelectedSegments_function_type)(  ) const;
            nSelectedSegments_function_type nSelectedSegments_function_value( &::SireMol::AtomSelection::nSelectedSegments );
            
            AtomSelection_exposer.def( 
                "nSelectedSegments"
                , nSelectedSegments_function_value
                , bp::release_gil_policy()
                , "Return the number of segments that contain at\nleast one selected atom" );
        
        }
        AtomSelection_exposer.def( bp::self != bp::self );
        { //::SireMol::AtomSelection::operator=
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*assign_function_type)( ::SireMol::AtomSelection const & ) ;
            assign_function_type assign_function_value( &::SireMol::AtomSelection::operator= );
            
            AtomSelection_exposer.def( 
                "assign"
                , assign_function_value
                , ( bp::arg("other") )
                , bp::return_self< >()
                , "" );
        
        }
        AtomSelection_exposer.def( bp::self == bp::self );
        { //::SireMol::AtomSelection::select
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*select_function_type)( ::SireMol::AtomIdx ) ;
            select_function_type select_function_value( &::SireMol::AtomSelection::select );
            
            AtomSelection_exposer.def( 
                "select"
                , select_function_value
                , ( bp::arg("atomidx") )
                , bp::return_self< >()
                , "Select the atom at index atomidx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::select
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*select_function_type)( ::SireMol::CGIdx ) ;
            select_function_type select_function_value( &::SireMol::AtomSelection::select );
            
            AtomSelection_exposer.def( 
                "select"
                , select_function_value
                , ( bp::arg("cgidx") )
                , bp::return_self< >()
                , "Select the CutGroup at index cgidx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::select
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*select_function_type)( ::SireMol::ResIdx ) ;
            select_function_type select_function_value( &::SireMol::AtomSelection::select );
            
            AtomSelection_exposer.def( 
                "select"
                , select_function_value
                , ( bp::arg("residx") )
                , bp::return_self< >()
                , "Select the atoms in the residue at index residx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::select
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*select_function_type)( ::SireMol::ChainIdx ) ;
            select_function_type select_function_value( &::SireMol::AtomSelection::select );
            
            AtomSelection_exposer.def( 
                "select"
                , select_function_value
                , ( bp::arg("chainidx") )
                , bp::return_self< >()
                , "Select all of the atoms in the chain at index chainidx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::select
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*select_function_type)( ::SireMol::SegIdx ) ;
            select_function_type select_function_value( &::SireMol::AtomSelection::select );
            
            AtomSelection_exposer.def( 
                "select"
                , select_function_value
                , ( bp::arg("segidx") )
                , bp::return_self< >()
                , "Select all of the atoms in the segment at index segidx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::select
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*select_function_type)( ::QSet< SireMol::AtomIdx > const & ) ;
            select_function_type select_function_value( &::SireMol::AtomSelection::select );
            
            AtomSelection_exposer.def( 
                "select"
                , select_function_value
                , ( bp::arg("atomidxs") )
                , bp::return_self< >()
                , "Deselect all of the atoms whose indicies are in atomidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::select
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*select_function_type)( ::QSet< SireMol::CGIdx > const & ) ;
            select_function_type select_function_value( &::SireMol::AtomSelection::select );
            
            AtomSelection_exposer.def( 
                "select"
                , select_function_value
                , ( bp::arg("cgidxs") )
                , bp::return_self< >()
                , "Select all of the CutGroups whose indicies are in cgidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::select
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*select_function_type)( ::QSet< SireMol::ResIdx > const & ) ;
            select_function_type select_function_value( &::SireMol::AtomSelection::select );
            
            AtomSelection_exposer.def( 
                "select"
                , select_function_value
                , ( bp::arg("residxs") )
                , bp::return_self< >()
                , "Select the atoms in the residues whose indicies are in residxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::select
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*select_function_type)( ::QSet< SireMol::ChainIdx > const & ) ;
            select_function_type select_function_value( &::SireMol::AtomSelection::select );
            
            AtomSelection_exposer.def( 
                "select"
                , select_function_value
                , ( bp::arg("chainidxs") )
                , bp::return_self< >()
                , "Select the atoms that are in the chains whose indicies are in chainidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::select
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*select_function_type)( ::QSet< SireMol::SegIdx > const & ) ;
            select_function_type select_function_value( &::SireMol::AtomSelection::select );
            
            AtomSelection_exposer.def( 
                "select"
                , select_function_value
                , ( bp::arg("segidxs") )
                , bp::return_self< >()
                , "Select the atoms that are in the segments whose indicies\nare in segidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::select
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*select_function_type)( ::QList< SireMol::AtomIdx > const & ) ;
            select_function_type select_function_value( &::SireMol::AtomSelection::select );
            
            AtomSelection_exposer.def( 
                "select"
                , select_function_value
                , ( bp::arg("atomidxs") )
                , bp::return_self< >()
                , "Deselect all of the atoms whose indicies are in atomidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::select
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*select_function_type)( ::QList< SireMol::CGIdx > const & ) ;
            select_function_type select_function_value( &::SireMol::AtomSelection::select );
            
            AtomSelection_exposer.def( 
                "select"
                , select_function_value
                , ( bp::arg("cgidxs") )
                , bp::return_self< >()
                , "Select all of the CutGroups whose indicies are in cgidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::select
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*select_function_type)( ::QList< SireMol::ResIdx > const & ) ;
            select_function_type select_function_value( &::SireMol::AtomSelection::select );
            
            AtomSelection_exposer.def( 
                "select"
                , select_function_value
                , ( bp::arg("residxs") )
                , bp::return_self< >()
                , "Select the atoms in the residues whose indicies are in residxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::select
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*select_function_type)( ::QList< SireMol::ChainIdx > const & ) ;
            select_function_type select_function_value( &::SireMol::AtomSelection::select );
            
            AtomSelection_exposer.def( 
                "select"
                , select_function_value
                , ( bp::arg("chainidxs") )
                , bp::return_self< >()
                , "Select the atoms that are in the chains whose indicies are in chainidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::select
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*select_function_type)( ::QList< SireMol::SegIdx > const & ) ;
            select_function_type select_function_value( &::SireMol::AtomSelection::select );
            
            AtomSelection_exposer.def( 
                "select"
                , select_function_value
                , ( bp::arg("segidxs") )
                , bp::return_self< >()
                , "Select the atoms that are in the segments whose indicies\nare in segidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::select
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*select_function_type)( ::SireMol::AtomID const & ) ;
            select_function_type select_function_value( &::SireMol::AtomSelection::select );
            
            AtomSelection_exposer.def( 
                "select"
                , select_function_value
                , ( bp::arg("atomid") )
                , bp::return_self< >()
                , "Select all of the atoms that match atomid\nThrow: SireMol::missing_atom\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::select
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*select_function_type)( ::SireMol::CGID const & ) ;
            select_function_type select_function_value( &::SireMol::AtomSelection::select );
            
            AtomSelection_exposer.def( 
                "select"
                , select_function_value
                , ( bp::arg("cgid") )
                , bp::return_self< >()
                , "Select the atoms in the CutGroups that match cgid\nThrow: SireMol::missing_cutgroup\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::select
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*select_function_type)( ::SireMol::ResID const & ) ;
            select_function_type select_function_value( &::SireMol::AtomSelection::select );
            
            AtomSelection_exposer.def( 
                "select"
                , select_function_value
                , ( bp::arg("resid") )
                , bp::return_self< >()
                , "Select the atoms in the residues that match resid\nThrow: SireMol::missing_residue\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::select
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*select_function_type)( ::SireMol::ChainID const & ) ;
            select_function_type select_function_value( &::SireMol::AtomSelection::select );
            
            AtomSelection_exposer.def( 
                "select"
                , select_function_value
                , ( bp::arg("chainid") )
                , bp::return_self< >()
                , "Select the atoms in the chains that match chainid\nThrow: SireMol::missing_chain\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::select
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*select_function_type)( ::SireMol::SegID const & ) ;
            select_function_type select_function_value( &::SireMol::AtomSelection::select );
            
            AtomSelection_exposer.def( 
                "select"
                , select_function_value
                , ( bp::arg("segid") )
                , bp::return_self< >()
                , "Select all of the atoms in the segments that match segid\nThrow: SireMol::missing_segment\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::select
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*select_function_type)( ::SireMol::AtomSelection const & ) ;
            select_function_type select_function_value( &::SireMol::AtomSelection::select );
            
            AtomSelection_exposer.def( 
                "select"
                , select_function_value
                , ( bp::arg("selection") )
                , bp::return_self< >()
                , "Select all of the atoms in selection\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireMol::AtomSelection::selectAll
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*selectAll_function_type)(  ) ;
            selectAll_function_type selectAll_function_value( &::SireMol::AtomSelection::selectAll );
            
            AtomSelection_exposer.def( 
                "selectAll"
                , selectAll_function_value
                , bp::return_self< >()
                , "Return a selection that has all of the atoms selected" );
        
        }
        { //::SireMol::AtomSelection::selectNone
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*selectNone_function_type)(  ) ;
            selectNone_function_type selectNone_function_value( &::SireMol::AtomSelection::selectNone );
            
            AtomSelection_exposer.def( 
                "selectNone"
                , selectNone_function_value
                , bp::return_self< >()
                , "Return a selection that has none of the atoms selected" );
        
        }
        { //::SireMol::AtomSelection::selectOnly
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*selectOnly_function_type)( ::SireMol::AtomIdx ) ;
            selectOnly_function_type selectOnly_function_value( &::SireMol::AtomSelection::selectOnly );
            
            AtomSelection_exposer.def( 
                "selectOnly"
                , selectOnly_function_value
                , ( bp::arg("atomidx") )
                , bp::return_self< >()
                , "Select only the atom at index atomidx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectOnly
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*selectOnly_function_type)( ::SireMol::CGIdx ) ;
            selectOnly_function_type selectOnly_function_value( &::SireMol::AtomSelection::selectOnly );
            
            AtomSelection_exposer.def( 
                "selectOnly"
                , selectOnly_function_value
                , ( bp::arg("cgidx") )
                , bp::return_self< >()
                , "Select only the CutGroup at index cgidx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectOnly
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*selectOnly_function_type)( ::SireMol::ResIdx ) ;
            selectOnly_function_type selectOnly_function_value( &::SireMol::AtomSelection::selectOnly );
            
            AtomSelection_exposer.def( 
                "selectOnly"
                , selectOnly_function_value
                , ( bp::arg("residx") )
                , bp::return_self< >()
                , "Select only the atoms in the residue at index residx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectOnly
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*selectOnly_function_type)( ::SireMol::ChainIdx ) ;
            selectOnly_function_type selectOnly_function_value( &::SireMol::AtomSelection::selectOnly );
            
            AtomSelection_exposer.def( 
                "selectOnly"
                , selectOnly_function_value
                , ( bp::arg("chainidx") )
                , bp::return_self< >()
                , "Select only the atoms that are in the chain at index chainidx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectOnly
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*selectOnly_function_type)( ::SireMol::SegIdx ) ;
            selectOnly_function_type selectOnly_function_value( &::SireMol::AtomSelection::selectOnly );
            
            AtomSelection_exposer.def( 
                "selectOnly"
                , selectOnly_function_value
                , ( bp::arg("segidx") )
                , bp::return_self< >()
                , "Select only the atoms that are in the segment at index segidx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectOnly
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*selectOnly_function_type)( ::QSet< SireMol::AtomIdx > const & ) ;
            selectOnly_function_type selectOnly_function_value( &::SireMol::AtomSelection::selectOnly );
            
            AtomSelection_exposer.def( 
                "selectOnly"
                , selectOnly_function_value
                , ( bp::arg("atomidxs") )
                , bp::return_self< >()
                , "Select only the atoms whose indicies are in atomidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectOnly
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*selectOnly_function_type)( ::QSet< SireMol::CGIdx > const & ) ;
            selectOnly_function_type selectOnly_function_value( &::SireMol::AtomSelection::selectOnly );
            
            AtomSelection_exposer.def( 
                "selectOnly"
                , selectOnly_function_value
                , ( bp::arg("cgidxs") )
                , bp::return_self< >()
                , "Select only the atoms in the CutGroups whose indicies are in cgidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectOnly
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*selectOnly_function_type)( ::QSet< SireMol::ResIdx > const & ) ;
            selectOnly_function_type selectOnly_function_value( &::SireMol::AtomSelection::selectOnly );
            
            AtomSelection_exposer.def( 
                "selectOnly"
                , selectOnly_function_value
                , ( bp::arg("residxs") )
                , bp::return_self< >()
                , "Select only the atoms that in the residues whose indicies are\nin residxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectOnly
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*selectOnly_function_type)( ::QSet< SireMol::ChainIdx > const & ) ;
            selectOnly_function_type selectOnly_function_value( &::SireMol::AtomSelection::selectOnly );
            
            AtomSelection_exposer.def( 
                "selectOnly"
                , selectOnly_function_value
                , ( bp::arg("chainidxs") )
                , bp::return_self< >()
                , "Select only the atoms that are in the chains whose indicies are\nin chainidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectOnly
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*selectOnly_function_type)( ::QSet< SireMol::SegIdx > const & ) ;
            selectOnly_function_type selectOnly_function_value( &::SireMol::AtomSelection::selectOnly );
            
            AtomSelection_exposer.def( 
                "selectOnly"
                , selectOnly_function_value
                , ( bp::arg("segidxs") )
                , bp::return_self< >()
                , "Select only the atoms in the segments whose indicies are\nin segidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectOnly
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*selectOnly_function_type)( ::QList< SireMol::AtomIdx > const & ) ;
            selectOnly_function_type selectOnly_function_value( &::SireMol::AtomSelection::selectOnly );
            
            AtomSelection_exposer.def( 
                "selectOnly"
                , selectOnly_function_value
                , ( bp::arg("atomidxs") )
                , bp::return_self< >()
                , "Select only the atoms whose indicies are in atomidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectOnly
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*selectOnly_function_type)( ::QList< SireMol::CGIdx > const & ) ;
            selectOnly_function_type selectOnly_function_value( &::SireMol::AtomSelection::selectOnly );
            
            AtomSelection_exposer.def( 
                "selectOnly"
                , selectOnly_function_value
                , ( bp::arg("cgidxs") )
                , bp::return_self< >()
                , "Select only the atoms in the CutGroups whose indicies are in cgidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectOnly
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*selectOnly_function_type)( ::QList< SireMol::ResIdx > const & ) ;
            selectOnly_function_type selectOnly_function_value( &::SireMol::AtomSelection::selectOnly );
            
            AtomSelection_exposer.def( 
                "selectOnly"
                , selectOnly_function_value
                , ( bp::arg("residxs") )
                , bp::return_self< >()
                , "Select only the atoms that in the residues whose indicies are\nin residxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectOnly
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*selectOnly_function_type)( ::QList< SireMol::ChainIdx > const & ) ;
            selectOnly_function_type selectOnly_function_value( &::SireMol::AtomSelection::selectOnly );
            
            AtomSelection_exposer.def( 
                "selectOnly"
                , selectOnly_function_value
                , ( bp::arg("chainidxs") )
                , bp::return_self< >()
                , "Select only the atoms that are in the chains whose indicies are\nin chainidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectOnly
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*selectOnly_function_type)( ::QList< SireMol::SegIdx > const & ) ;
            selectOnly_function_type selectOnly_function_value( &::SireMol::AtomSelection::selectOnly );
            
            AtomSelection_exposer.def( 
                "selectOnly"
                , selectOnly_function_value
                , ( bp::arg("segidxs") )
                , bp::return_self< >()
                , "Select only the atoms in the segments whose indicies are\nin segidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectOnly
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*selectOnly_function_type)( ::SireMol::AtomID const & ) ;
            selectOnly_function_type selectOnly_function_value( &::SireMol::AtomSelection::selectOnly );
            
            AtomSelection_exposer.def( 
                "selectOnly"
                , selectOnly_function_value
                , ( bp::arg("atomid") )
                , bp::return_self< >()
                , "Select only that atoms that match atomid\nThrow: SireMol::missing_atom\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectOnly
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*selectOnly_function_type)( ::SireMol::CGID const & ) ;
            selectOnly_function_type selectOnly_function_value( &::SireMol::AtomSelection::selectOnly );
            
            AtomSelection_exposer.def( 
                "selectOnly"
                , selectOnly_function_value
                , ( bp::arg("cgid") )
                , bp::return_self< >()
                , "Select only the atoms that are in the CutGroups that\nmatch cgid\nThrow: SireMol::missing_cutgroup\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectOnly
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*selectOnly_function_type)( ::SireMol::ResID const & ) ;
            selectOnly_function_type selectOnly_function_value( &::SireMol::AtomSelection::selectOnly );
            
            AtomSelection_exposer.def( 
                "selectOnly"
                , selectOnly_function_value
                , ( bp::arg("resid") )
                , bp::return_self< >()
                , "Select only the atoms in the residues that match resid\nThrow: SireMol::missing_residue\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectOnly
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*selectOnly_function_type)( ::SireMol::ChainID const & ) ;
            selectOnly_function_type selectOnly_function_value( &::SireMol::AtomSelection::selectOnly );
            
            AtomSelection_exposer.def( 
                "selectOnly"
                , selectOnly_function_value
                , ( bp::arg("chainid") )
                , bp::return_self< >()
                , "Select only the atoms in the chains that match chainid\nThrow: SireMol::missing_chain\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectOnly
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*selectOnly_function_type)( ::SireMol::SegID const & ) ;
            selectOnly_function_type selectOnly_function_value( &::SireMol::AtomSelection::selectOnly );
            
            AtomSelection_exposer.def( 
                "selectOnly"
                , selectOnly_function_value
                , ( bp::arg("segid") )
                , bp::return_self< >()
                , "Select only the atoms in the segments that match segid\nThrow: SireMol::missing_segment\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectOnly
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*selectOnly_function_type)( ::SireMol::AtomSelection const & ) ;
            selectOnly_function_type selectOnly_function_value( &::SireMol::AtomSelection::selectOnly );
            
            AtomSelection_exposer.def( 
                "selectOnly"
                , selectOnly_function_value
                , ( bp::arg("selection") )
                , bp::return_self< >()
                , "Select only the atoms that are selected in selection\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireMol::AtomSelection::selected
        
            typedef bool ( ::SireMol::AtomSelection::*selected_function_type)( ::SireMol::CGAtomIdx const & ) const;
            selected_function_type selected_function_value( &::SireMol::AtomSelection::selected );
            
            AtomSelection_exposer.def( 
                "selected"
                , selected_function_value
                , ( bp::arg("cgatomidx") )
                , bp::release_gil_policy()
                , "Return whether or not the atom at index cgatomidx has\nbeen selected\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selected
        
            typedef bool ( ::SireMol::AtomSelection::*selected_function_type)( ::SireMol::AtomIdx ) const;
            selected_function_type selected_function_value( &::SireMol::AtomSelection::selected );
            
            AtomSelection_exposer.def( 
                "selected"
                , selected_function_value
                , ( bp::arg("atomidx") )
                , bp::release_gil_policy()
                , "Return whether the atom at index atomidx has been selected\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selected
        
            typedef bool ( ::SireMol::AtomSelection::*selected_function_type)( ::SireMol::AtomID const & ) const;
            selected_function_type selected_function_value( &::SireMol::AtomSelection::selected );
            
            AtomSelection_exposer.def( 
                "selected"
                , selected_function_value
                , ( bp::arg("atomid") )
                , bp::release_gil_policy()
                , "Return whether any of the atom(s) identified by the ID atomid\nhave been selected\nThrow: SireMol::missing_atom\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selected
        
            typedef bool ( ::SireMol::AtomSelection::*selected_function_type)( ::SireMol::CGIdx ) const;
            selected_function_type selected_function_value( &::SireMol::AtomSelection::selected );
            
            AtomSelection_exposer.def( 
                "selected"
                , selected_function_value
                , ( bp::arg("cgidx") )
                , bp::release_gil_policy()
                , "Return whether or not any atom in the CutGroup\nat index cgidx has been selected\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selected
        
            typedef bool ( ::SireMol::AtomSelection::*selected_function_type)( ::SireMol::ResIdx ) const;
            selected_function_type selected_function_value( &::SireMol::AtomSelection::selected );
            
            AtomSelection_exposer.def( 
                "selected"
                , selected_function_value
                , ( bp::arg("residx") )
                , bp::release_gil_policy()
                , "Return whether or not any atoms in the residue\nat index residx has been selected\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selected
        
            typedef bool ( ::SireMol::AtomSelection::*selected_function_type)( ::SireMol::ChainIdx ) const;
            selected_function_type selected_function_value( &::SireMol::AtomSelection::selected );
            
            AtomSelection_exposer.def( 
                "selected"
                , selected_function_value
                , ( bp::arg("chainidx") )
                , bp::release_gil_policy()
                , "Return whether or not any atoms in the chain\nat index chainidx have been selected\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selected
        
            typedef bool ( ::SireMol::AtomSelection::*selected_function_type)( ::SireMol::SegIdx ) const;
            selected_function_type selected_function_value( &::SireMol::AtomSelection::selected );
            
            AtomSelection_exposer.def( 
                "selected"
                , selected_function_value
                , ( bp::arg("segidx") )
                , bp::release_gil_policy()
                , "Return whether or not any atoms in the segment at\nindex segidx have been selected\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selected
        
            typedef bool ( ::SireMol::AtomSelection::*selected_function_type)( ::SireMol::CGID const & ) const;
            selected_function_type selected_function_value( &::SireMol::AtomSelection::selected );
            
            AtomSelection_exposer.def( 
                "selected"
                , selected_function_value
                , ( bp::arg("cgid") )
                , bp::release_gil_policy()
                , "Return whether any atoms in the CutGroup(s) identified\nby cgid have been selected\nThrow: SireMol::missing_cutgroup\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selected
        
            typedef bool ( ::SireMol::AtomSelection::*selected_function_type)( ::SireMol::ResID const & ) const;
            selected_function_type selected_function_value( &::SireMol::AtomSelection::selected );
            
            AtomSelection_exposer.def( 
                "selected"
                , selected_function_value
                , ( bp::arg("resid") )
                , bp::release_gil_policy()
                , "Return whether any atoms in the residue(s) identified\nby resid have been selected\nThrow: SireMol::missing_residue\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selected
        
            typedef bool ( ::SireMol::AtomSelection::*selected_function_type)( ::SireMol::ChainID const & ) const;
            selected_function_type selected_function_value( &::SireMol::AtomSelection::selected );
            
            AtomSelection_exposer.def( 
                "selected"
                , selected_function_value
                , ( bp::arg("chainid") )
                , bp::release_gil_policy()
                , "Return whether any atoms in the chain(s) identified\nby chainid have been selected\nThrow: SireMol::missing_chain\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selected
        
            typedef bool ( ::SireMol::AtomSelection::*selected_function_type)( ::SireMol::SegID const & ) const;
            selected_function_type selected_function_value( &::SireMol::AtomSelection::selected );
            
            AtomSelection_exposer.def( 
                "selected"
                , selected_function_value
                , ( bp::arg("segid") )
                , bp::release_gil_policy()
                , "Return whether any atoms in the segment(s) identified\nby segid have been selected\nThrow: SireMol::missing_segment\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selected
        
            typedef bool ( ::SireMol::AtomSelection::*selected_function_type)( ::SireMol::AtomSelection const & ) const;
            selected_function_type selected_function_value( &::SireMol::AtomSelection::selected );
            
            AtomSelection_exposer.def( 
                "selected"
                , selected_function_value
                , ( bp::arg("selection") )
                , bp::release_gil_policy()
                , "Return whether or not any of the atoms selected in selection\nare also selected in this set\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireMol::AtomSelection::selectedAll
        
            typedef bool ( ::SireMol::AtomSelection::*selectedAll_function_type)(  ) const;
            selectedAll_function_type selectedAll_function_value( &::SireMol::AtomSelection::selectedAll );
            
            AtomSelection_exposer.def( 
                "selectedAll"
                , selectedAll_function_value
                , bp::release_gil_policy()
                , "Return whether or not all of the atoms are selected" );
        
        }
        { //::SireMol::AtomSelection::selectedAll
        
            typedef bool ( ::SireMol::AtomSelection::*selectedAll_function_type)( ::SireMol::AtomIdx ) const;
            selectedAll_function_type selectedAll_function_value( &::SireMol::AtomSelection::selectedAll );
            
            AtomSelection_exposer.def( 
                "selectedAll"
                , selectedAll_function_value
                , ( bp::arg("atomidx") )
                , bp::release_gil_policy()
                , "Return whether or not the atom at index atomidx is selected\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectedAll
        
            typedef bool ( ::SireMol::AtomSelection::*selectedAll_function_type)( ::SireMol::CGIdx ) const;
            selectedAll_function_type selectedAll_function_value( &::SireMol::AtomSelection::selectedAll );
            
            AtomSelection_exposer.def( 
                "selectedAll"
                , selectedAll_function_value
                , ( bp::arg("cgidx") )
                , bp::release_gil_policy()
                , "Return whether or not all of the atoms in the CutGroup\nat index cgidx have been selected\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectedAll
        
            typedef bool ( ::SireMol::AtomSelection::*selectedAll_function_type)( ::SireMol::ResIdx ) const;
            selectedAll_function_type selectedAll_function_value( &::SireMol::AtomSelection::selectedAll );
            
            AtomSelection_exposer.def( 
                "selectedAll"
                , selectedAll_function_value
                , ( bp::arg("residx") )
                , bp::release_gil_policy()
                , "Return whether or not all of the atoms in the residue\nat index residx have been selected\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectedAll
        
            typedef bool ( ::SireMol::AtomSelection::*selectedAll_function_type)( ::SireMol::ChainIdx ) const;
            selectedAll_function_type selectedAll_function_value( &::SireMol::AtomSelection::selectedAll );
            
            AtomSelection_exposer.def( 
                "selectedAll"
                , selectedAll_function_value
                , ( bp::arg("chainidx") )
                , bp::release_gil_policy()
                , "Return whether or not all of the atoms in the chain\nat index chainidx have been selected\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectedAll
        
            typedef bool ( ::SireMol::AtomSelection::*selectedAll_function_type)( ::SireMol::SegIdx ) const;
            selectedAll_function_type selectedAll_function_value( &::SireMol::AtomSelection::selectedAll );
            
            AtomSelection_exposer.def( 
                "selectedAll"
                , selectedAll_function_value
                , ( bp::arg("segidx") )
                , bp::release_gil_policy()
                , "Return whether or not all of the atoms in the segment\nat index segidx have been selected\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectedAll
        
            typedef bool ( ::SireMol::AtomSelection::*selectedAll_function_type)( ::SireMol::AtomID const & ) const;
            selectedAll_function_type selectedAll_function_value( &::SireMol::AtomSelection::selectedAll );
            
            AtomSelection_exposer.def( 
                "selectedAll"
                , selectedAll_function_value
                , ( bp::arg("atomid") )
                , bp::release_gil_policy()
                , "Return whether or not all of the atoms matching the\nID atomid have been selected\nThrow: SireMol::missing_atom\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectedAll
        
            typedef bool ( ::SireMol::AtomSelection::*selectedAll_function_type)( ::SireMol::CGID const & ) const;
            selectedAll_function_type selectedAll_function_value( &::SireMol::AtomSelection::selectedAll );
            
            AtomSelection_exposer.def( 
                "selectedAll"
                , selectedAll_function_value
                , ( bp::arg("cgid") )
                , bp::release_gil_policy()
                , "Return whether or not all of the atoms in the CutGroups matching the\nID cgid have been selected\nThrow: SireMol::missing_cutgroup\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectedAll
        
            typedef bool ( ::SireMol::AtomSelection::*selectedAll_function_type)( ::SireMol::ResID const & ) const;
            selectedAll_function_type selectedAll_function_value( &::SireMol::AtomSelection::selectedAll );
            
            AtomSelection_exposer.def( 
                "selectedAll"
                , selectedAll_function_value
                , ( bp::arg("resid") )
                , bp::release_gil_policy()
                , "Return whether or not all of the atoms in the residues matching the\nID resid have been selected\nThrow: SireMol::missing_residue\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectedAll
        
            typedef bool ( ::SireMol::AtomSelection::*selectedAll_function_type)( ::SireMol::ChainID const & ) const;
            selectedAll_function_type selectedAll_function_value( &::SireMol::AtomSelection::selectedAll );
            
            AtomSelection_exposer.def( 
                "selectedAll"
                , selectedAll_function_value
                , ( bp::arg("chainid") )
                , bp::release_gil_policy()
                , "Return whether or not all of the atoms in the chains matching the\nID atomid have been selected\nThrow: SireMol::missing_chain\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectedAll
        
            typedef bool ( ::SireMol::AtomSelection::*selectedAll_function_type)( ::SireMol::SegID const & ) const;
            selectedAll_function_type selectedAll_function_value( &::SireMol::AtomSelection::selectedAll );
            
            AtomSelection_exposer.def( 
                "selectedAll"
                , selectedAll_function_value
                , ( bp::arg("segid") )
                , bp::release_gil_policy()
                , "Return whether or not all of the atoms in the segments matching the\nID atomid have been selected\nThrow: SireMol::missing_segment\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectedAll
        
            typedef bool ( ::SireMol::AtomSelection::*selectedAll_function_type)( ::SireMol::AtomSelection const & ) const;
            selectedAll_function_type selectedAll_function_value( &::SireMol::AtomSelection::selectedAll );
            
            AtomSelection_exposer.def( 
                "selectedAll"
                , selectedAll_function_value
                , ( bp::arg("selection") )
                , bp::release_gil_policy()
                , "Return whether or not all of the atoms selected in selection\nhave also been selected in this object\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireMol::AtomSelection::selectedAllAtoms
        
            typedef bool ( ::SireMol::AtomSelection::*selectedAllAtoms_function_type)(  ) const;
            selectedAllAtoms_function_type selectedAllAtoms_function_value( &::SireMol::AtomSelection::selectedAllAtoms );
            
            AtomSelection_exposer.def( 
                "selectedAllAtoms"
                , selectedAllAtoms_function_value
                , bp::release_gil_policy()
                , "Return whether all atoms have been selected" );
        
        }
        { //::SireMol::AtomSelection::selectedAllChains
        
            typedef bool ( ::SireMol::AtomSelection::*selectedAllChains_function_type)(  ) const;
            selectedAllChains_function_type selectedAllChains_function_value( &::SireMol::AtomSelection::selectedAllChains );
            
            AtomSelection_exposer.def( 
                "selectedAllChains"
                , selectedAllChains_function_value
                , bp::release_gil_policy()
                , "Return whether all chains contain at least\none selected atom" );
        
        }
        { //::SireMol::AtomSelection::selectedAllCutGroups
        
            typedef bool ( ::SireMol::AtomSelection::*selectedAllCutGroups_function_type)(  ) const;
            selectedAllCutGroups_function_type selectedAllCutGroups_function_value( &::SireMol::AtomSelection::selectedAllCutGroups );
            
            AtomSelection_exposer.def( 
                "selectedAllCutGroups"
                , selectedAllCutGroups_function_value
                , bp::release_gil_policy()
                , "Return whether all CutGroups contain at least\none selected atom" );
        
        }
        { //::SireMol::AtomSelection::selectedAllResidues
        
            typedef bool ( ::SireMol::AtomSelection::*selectedAllResidues_function_type)(  ) const;
            selectedAllResidues_function_type selectedAllResidues_function_value( &::SireMol::AtomSelection::selectedAllResidues );
            
            AtomSelection_exposer.def( 
                "selectedAllResidues"
                , selectedAllResidues_function_value
                , bp::release_gil_policy()
                , "Return whether all residues contain at least\none selected atom" );
        
        }
        { //::SireMol::AtomSelection::selectedAllSegments
        
            typedef bool ( ::SireMol::AtomSelection::*selectedAllSegments_function_type)(  ) const;
            selectedAllSegments_function_type selectedAllSegments_function_value( &::SireMol::AtomSelection::selectedAllSegments );
            
            AtomSelection_exposer.def( 
                "selectedAllSegments"
                , selectedAllSegments_function_value
                , bp::release_gil_policy()
                , "Return whether all segments contain at least\none selected atom" );
        
        }
        { //::SireMol::AtomSelection::selectedAtoms
        
            typedef ::QVector< SireMol::AtomIdx > ( ::SireMol::AtomSelection::*selectedAtoms_function_type)(  ) const;
            selectedAtoms_function_type selectedAtoms_function_value( &::SireMol::AtomSelection::selectedAtoms );
            
            AtomSelection_exposer.def( 
                "selectedAtoms"
                , selectedAtoms_function_value
                , bp::release_gil_policy()
                , "Return the list of indicies of all of the atoms that\nhave been selected" );
        
        }
        { //::SireMol::AtomSelection::selectedAtoms
        
            typedef ::QSet< SireID::Index > ( ::SireMol::AtomSelection::*selectedAtoms_function_type)( ::SireMol::CGIdx ) const;
            selectedAtoms_function_type selectedAtoms_function_value( &::SireMol::AtomSelection::selectedAtoms );
            
            AtomSelection_exposer.def( 
                "selectedAtoms"
                , selectedAtoms_function_value
                , ( bp::arg("cgid") )
                , bp::release_gil_policy()
                , "Return the set of indicies of the atoms in the CutGroup\nat index cgidx that are selected within this CutGroup\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectedChains
        
            typedef ::QList< SireMol::ChainIdx > ( ::SireMol::AtomSelection::*selectedChains_function_type)(  ) const;
            selectedChains_function_type selectedChains_function_value( &::SireMol::AtomSelection::selectedChains );
            
            AtomSelection_exposer.def( 
                "selectedChains"
                , selectedChains_function_value
                , bp::release_gil_policy()
                , "Return the list of chains that contain at least one selected atom" );
        
        }
        { //::SireMol::AtomSelection::selectedCutGroups
        
            typedef ::QList< SireMol::CGIdx > ( ::SireMol::AtomSelection::*selectedCutGroups_function_type)(  ) const;
            selectedCutGroups_function_type selectedCutGroups_function_value( &::SireMol::AtomSelection::selectedCutGroups );
            
            AtomSelection_exposer.def( 
                "selectedCutGroups"
                , selectedCutGroups_function_value
                , bp::release_gil_policy()
                , "Return the list of indicies of CutGroups that contain at least\none selected atom" );
        
        }
        { //::SireMol::AtomSelection::selectedNone
        
            typedef bool ( ::SireMol::AtomSelection::*selectedNone_function_type)(  ) const;
            selectedNone_function_type selectedNone_function_value( &::SireMol::AtomSelection::selectedNone );
            
            AtomSelection_exposer.def( 
                "selectedNone"
                , selectedNone_function_value
                , bp::release_gil_policy()
                , "Return whether or not no atoms have been selected" );
        
        }
        { //::SireMol::AtomSelection::selectedNone
        
            typedef bool ( ::SireMol::AtomSelection::*selectedNone_function_type)( ::SireMol::AtomIdx ) const;
            selectedNone_function_type selectedNone_function_value( &::SireMol::AtomSelection::selectedNone );
            
            AtomSelection_exposer.def( 
                "selectedNone"
                , selectedNone_function_value
                , ( bp::arg("atomidx") )
                , bp::release_gil_policy()
                , "Return whether the atom at index atomidx has not been selected\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectedNone
        
            typedef bool ( ::SireMol::AtomSelection::*selectedNone_function_type)( ::SireMol::CGIdx ) const;
            selectedNone_function_type selectedNone_function_value( &::SireMol::AtomSelection::selectedNone );
            
            AtomSelection_exposer.def( 
                "selectedNone"
                , selectedNone_function_value
                , ( bp::arg("cgidx") )
                , bp::release_gil_policy()
                , "Return whether none of the atoms in the CutGroup at\nindex cgidx have been selected\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectedNone
        
            typedef bool ( ::SireMol::AtomSelection::*selectedNone_function_type)( ::SireMol::ResIdx ) const;
            selectedNone_function_type selectedNone_function_value( &::SireMol::AtomSelection::selectedNone );
            
            AtomSelection_exposer.def( 
                "selectedNone"
                , selectedNone_function_value
                , ( bp::arg("residx") )
                , bp::release_gil_policy()
                , "Return whether none of the atoms in the residue at\nindex residx have been selected\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectedNone
        
            typedef bool ( ::SireMol::AtomSelection::*selectedNone_function_type)( ::SireMol::ChainIdx ) const;
            selectedNone_function_type selectedNone_function_value( &::SireMol::AtomSelection::selectedNone );
            
            AtomSelection_exposer.def( 
                "selectedNone"
                , selectedNone_function_value
                , ( bp::arg("chainidx") )
                , bp::release_gil_policy()
                , "Return whether none of the atoms in the chain at\nindex chainidx have been selected\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectedNone
        
            typedef bool ( ::SireMol::AtomSelection::*selectedNone_function_type)( ::SireMol::SegIdx ) const;
            selectedNone_function_type selectedNone_function_value( &::SireMol::AtomSelection::selectedNone );
            
            AtomSelection_exposer.def( 
                "selectedNone"
                , selectedNone_function_value
                , ( bp::arg("segidx") )
                , bp::release_gil_policy()
                , "Return whether none of the atoms in the segment at\nindex segidx have been selected\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectedNone
        
            typedef bool ( ::SireMol::AtomSelection::*selectedNone_function_type)( ::SireMol::AtomID const & ) const;
            selectedNone_function_type selectedNone_function_value( &::SireMol::AtomSelection::selectedNone );
            
            AtomSelection_exposer.def( 
                "selectedNone"
                , selectedNone_function_value
                , ( bp::arg("atomid") )
                , bp::release_gil_policy()
                , "Return whether none of the atoms identified by atomid\nhave been selected\nThrow: SireMol::missing_atom\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectedNone
        
            typedef bool ( ::SireMol::AtomSelection::*selectedNone_function_type)( ::SireMol::CGID const & ) const;
            selectedNone_function_type selectedNone_function_value( &::SireMol::AtomSelection::selectedNone );
            
            AtomSelection_exposer.def( 
                "selectedNone"
                , selectedNone_function_value
                , ( bp::arg("cgid") )
                , bp::release_gil_policy()
                , "Return whether none of the atoms in the CutGroup(s)\nidentified by cgid have been selected\nThrow: SireMol::missing_cutgroup\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectedNone
        
            typedef bool ( ::SireMol::AtomSelection::*selectedNone_function_type)( ::SireMol::ResID const & ) const;
            selectedNone_function_type selectedNone_function_value( &::SireMol::AtomSelection::selectedNone );
            
            AtomSelection_exposer.def( 
                "selectedNone"
                , selectedNone_function_value
                , ( bp::arg("resid") )
                , bp::release_gil_policy()
                , "Return whether none of the atoms in the residue(s)\nidentified by resid have been selected\nThrow: SireMol::missing_residue\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectedNone
        
            typedef bool ( ::SireMol::AtomSelection::*selectedNone_function_type)( ::SireMol::ChainID const & ) const;
            selectedNone_function_type selectedNone_function_value( &::SireMol::AtomSelection::selectedNone );
            
            AtomSelection_exposer.def( 
                "selectedNone"
                , selectedNone_function_value
                , ( bp::arg("chainid") )
                , bp::release_gil_policy()
                , "Return whether none of the atoms in the chain(s)\nidentified by chainid have been selected\nThrow: SireMol::missing_chain\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectedNone
        
            typedef bool ( ::SireMol::AtomSelection::*selectedNone_function_type)( ::SireMol::SegID const & ) const;
            selectedNone_function_type selectedNone_function_value( &::SireMol::AtomSelection::selectedNone );
            
            AtomSelection_exposer.def( 
                "selectedNone"
                , selectedNone_function_value
                , ( bp::arg("segid") )
                , bp::release_gil_policy()
                , "Return whether none of the atoms in the segment(s)\nidentified by segid have been selected\nThrow: SireMol::missing_segment\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::selectedNone
        
            typedef bool ( ::SireMol::AtomSelection::*selectedNone_function_type)( ::SireMol::AtomSelection const & ) const;
            selectedNone_function_type selectedNone_function_value( &::SireMol::AtomSelection::selectedNone );
            
            AtomSelection_exposer.def( 
                "selectedNone"
                , selectedNone_function_value
                , ( bp::arg("selection") )
                , bp::release_gil_policy()
                , "Return whether none of the atoms selected in selection have\nbeen selected in this set\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireMol::AtomSelection::selectedResidues
        
            typedef ::QList< SireMol::ResIdx > ( ::SireMol::AtomSelection::*selectedResidues_function_type)(  ) const;
            selectedResidues_function_type selectedResidues_function_value( &::SireMol::AtomSelection::selectedResidues );
            
            AtomSelection_exposer.def( 
                "selectedResidues"
                , selectedResidues_function_value
                , bp::release_gil_policy()
                , "Return the list of residues that contain at least one selected atom" );
        
        }
        { //::SireMol::AtomSelection::selectedSegments
        
            typedef ::QList< SireMol::SegIdx > ( ::SireMol::AtomSelection::*selectedSegments_function_type)(  ) const;
            selectedSegments_function_type selectedSegments_function_value( &::SireMol::AtomSelection::selectedSegments );
            
            AtomSelection_exposer.def( 
                "selectedSegments"
                , selectedSegments_function_value
                , bp::release_gil_policy()
                , "Return the list of segments that contain at least one selected atom" );
        
        }
        { //::SireMol::AtomSelection::subtract
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*subtract_function_type)( ::SireMol::AtomIdx ) ;
            subtract_function_type subtract_function_value( &::SireMol::AtomSelection::subtract );
            
            AtomSelection_exposer.def( 
                "subtract"
                , subtract_function_value
                , ( bp::arg("atomidx") )
                , bp::return_self< >()
                , "Subtract the atom at index atomidx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::subtract
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*subtract_function_type)( ::SireMol::CGIdx ) ;
            subtract_function_type subtract_function_value( &::SireMol::AtomSelection::subtract );
            
            AtomSelection_exposer.def( 
                "subtract"
                , subtract_function_value
                , ( bp::arg("cgidx") )
                , bp::return_self< >()
                , "Subtract the atoms in the CutGroup\nat index cgidx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::subtract
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*subtract_function_type)( ::SireMol::ResIdx ) ;
            subtract_function_type subtract_function_value( &::SireMol::AtomSelection::subtract );
            
            AtomSelection_exposer.def( 
                "subtract"
                , subtract_function_value
                , ( bp::arg("residx") )
                , bp::return_self< >()
                , "Subtract the atoms in the residue\nat index residx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::subtract
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*subtract_function_type)( ::SireMol::ChainIdx ) ;
            subtract_function_type subtract_function_value( &::SireMol::AtomSelection::subtract );
            
            AtomSelection_exposer.def( 
                "subtract"
                , subtract_function_value
                , ( bp::arg("chainidx") )
                , bp::return_self< >()
                , "Subtract the atoms in the chain\nat index chainidx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::subtract
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*subtract_function_type)( ::SireMol::SegIdx ) ;
            subtract_function_type subtract_function_value( &::SireMol::AtomSelection::subtract );
            
            AtomSelection_exposer.def( 
                "subtract"
                , subtract_function_value
                , ( bp::arg("segidx") )
                , bp::return_self< >()
                , "Subtract the atoms in the segment\nat index segidx have been subtracted\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::subtract
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*subtract_function_type)( ::QSet< SireMol::AtomIdx > const & ) ;
            subtract_function_type subtract_function_value( &::SireMol::AtomSelection::subtract );
            
            AtomSelection_exposer.def( 
                "subtract"
                , subtract_function_value
                , ( bp::arg("atomidx") )
                , bp::return_self< >()
                , "Subtract the atoms whose indicies\nare in atomidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::subtract
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*subtract_function_type)( ::QSet< SireMol::CGIdx > const & ) ;
            subtract_function_type subtract_function_value( &::SireMol::AtomSelection::subtract );
            
            AtomSelection_exposer.def( 
                "subtract"
                , subtract_function_value
                , ( bp::arg("cgidx") )
                , bp::return_self< >()
                , "Subtract the atoms that\nare in the CutGroups whose indicies are in cgidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::subtract
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*subtract_function_type)( ::QSet< SireMol::ResIdx > const & ) ;
            subtract_function_type subtract_function_value( &::SireMol::AtomSelection::subtract );
            
            AtomSelection_exposer.def( 
                "subtract"
                , subtract_function_value
                , ( bp::arg("residx") )
                , bp::return_self< >()
                , "Subtract the atoms that\nare in the residues whose indicies are in residxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::subtract
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*subtract_function_type)( ::QSet< SireMol::ChainIdx > const & ) ;
            subtract_function_type subtract_function_value( &::SireMol::AtomSelection::subtract );
            
            AtomSelection_exposer.def( 
                "subtract"
                , subtract_function_value
                , ( bp::arg("chainidx") )
                , bp::return_self< >()
                , "Subtract all of the atoms that\nare in the chains whose indicies are in chainidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::subtract
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*subtract_function_type)( ::QSet< SireMol::SegIdx > const & ) ;
            subtract_function_type subtract_function_value( &::SireMol::AtomSelection::subtract );
            
            AtomSelection_exposer.def( 
                "subtract"
                , subtract_function_value
                , ( bp::arg("segidx") )
                , bp::return_self< >()
                , "Subtract all of the atoms that\nare in the segments whose indicies are in segidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::subtract
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*subtract_function_type)( ::QList< SireMol::AtomIdx > const & ) ;
            subtract_function_type subtract_function_value( &::SireMol::AtomSelection::subtract );
            
            AtomSelection_exposer.def( 
                "subtract"
                , subtract_function_value
                , ( bp::arg("atomidx") )
                , bp::return_self< >()
                , "Subtract the atoms whose indicies\nare in atomidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::subtract
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*subtract_function_type)( ::QList< SireMol::CGIdx > const & ) ;
            subtract_function_type subtract_function_value( &::SireMol::AtomSelection::subtract );
            
            AtomSelection_exposer.def( 
                "subtract"
                , subtract_function_value
                , ( bp::arg("cgidx") )
                , bp::return_self< >()
                , "Subtract the atoms that\nare in the CutGroups whose indicies are in cgidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::subtract
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*subtract_function_type)( ::QList< SireMol::ResIdx > const & ) ;
            subtract_function_type subtract_function_value( &::SireMol::AtomSelection::subtract );
            
            AtomSelection_exposer.def( 
                "subtract"
                , subtract_function_value
                , ( bp::arg("residx") )
                , bp::return_self< >()
                , "Subtract the atoms that\nare in the residues whose indicies are in residxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::subtract
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*subtract_function_type)( ::QList< SireMol::ChainIdx > const & ) ;
            subtract_function_type subtract_function_value( &::SireMol::AtomSelection::subtract );
            
            AtomSelection_exposer.def( 
                "subtract"
                , subtract_function_value
                , ( bp::arg("chainidx") )
                , bp::return_self< >()
                , "Subtract all of the atoms that\nare in the chains whose indicies are in chainidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::subtract
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*subtract_function_type)( ::QList< SireMol::SegIdx > const & ) ;
            subtract_function_type subtract_function_value( &::SireMol::AtomSelection::subtract );
            
            AtomSelection_exposer.def( 
                "subtract"
                , subtract_function_value
                , ( bp::arg("segidx") )
                , bp::return_self< >()
                , "Subtract all of the atoms that\nare in the segments whose indicies are in segidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::subtract
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*subtract_function_type)( ::SireMol::AtomID const & ) ;
            subtract_function_type subtract_function_value( &::SireMol::AtomSelection::subtract );
            
            AtomSelection_exposer.def( 
                "subtract"
                , subtract_function_value
                , ( bp::arg("atomid") )
                , bp::return_self< >()
                , "Subtract all of the atoms that\nmatch the ID atomid\nThrow: SireMol::missing_atom\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::subtract
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*subtract_function_type)( ::SireMol::CGID const & ) ;
            subtract_function_type subtract_function_value( &::SireMol::AtomSelection::subtract );
            
            AtomSelection_exposer.def( 
                "subtract"
                , subtract_function_value
                , ( bp::arg("cgid") )
                , bp::return_self< >()
                , "Subtract all of the atoms that\nare in the CutGroup(s) that match the ID cgid\nThrow: SireMol::missing_cutgroup\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::subtract
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*subtract_function_type)( ::SireMol::ResID const & ) ;
            subtract_function_type subtract_function_value( &::SireMol::AtomSelection::subtract );
            
            AtomSelection_exposer.def( 
                "subtract"
                , subtract_function_value
                , ( bp::arg("resid") )
                , bp::return_self< >()
                , "Subtract all of the atoms that\nare in the residue(s) that match the ID resid\nThrow: SireMol::missing_residue\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::subtract
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*subtract_function_type)( ::SireMol::ChainID const & ) ;
            subtract_function_type subtract_function_value( &::SireMol::AtomSelection::subtract );
            
            AtomSelection_exposer.def( 
                "subtract"
                , subtract_function_value
                , ( bp::arg("chainid") )
                , bp::return_self< >()
                , "Subtract all of the atoms that\nare in the chain(s) that match the ID resid\nThrow: SireMol::missing_residue\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::subtract
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*subtract_function_type)( ::SireMol::SegID const & ) ;
            subtract_function_type subtract_function_value( &::SireMol::AtomSelection::subtract );
            
            AtomSelection_exposer.def( 
                "subtract"
                , subtract_function_value
                , ( bp::arg("segid") )
                , bp::return_self< >()
                , "Subtract all of the atoms that\nare in the segment(s) that match the ID segid\nThrow: SireMol::missing_segment\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::subtract
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*subtract_function_type)( ::SireMol::AtomSelection const & ) ;
            subtract_function_type subtract_function_value( &::SireMol::AtomSelection::subtract );
            
            AtomSelection_exposer.def( 
                "subtract"
                , subtract_function_value
                , ( bp::arg("selection") )
                , bp::return_self< >()
                , "Subtract all of the atoms selected\nin selection\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireMol::AtomSelection::typeName
        
            typedef char const * ( *typeName_function_type )(  );
            typeName_function_type typeName_function_value( &::SireMol::AtomSelection::typeName );
            
            AtomSelection_exposer.def( 
                "typeName"
                , typeName_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireMol::AtomSelection::unite
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*unite_function_type)( ::SireMol::AtomIdx ) ;
            unite_function_type unite_function_value( &::SireMol::AtomSelection::unite );
            
            AtomSelection_exposer.def( 
                "unite"
                , unite_function_value
                , ( bp::arg("atomidx") )
                , bp::return_self< >()
                , "Unite this set with the atom at index atomidx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::unite
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*unite_function_type)( ::SireMol::CGIdx ) ;
            unite_function_type unite_function_value( &::SireMol::AtomSelection::unite );
            
            AtomSelection_exposer.def( 
                "unite"
                , unite_function_value
                , ( bp::arg("cgidx") )
                , bp::return_self< >()
                , "Unite this set with the atoms in the\nCutGroup at index cgidx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::unite
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*unite_function_type)( ::SireMol::ResIdx ) ;
            unite_function_type unite_function_value( &::SireMol::AtomSelection::unite );
            
            AtomSelection_exposer.def( 
                "unite"
                , unite_function_value
                , ( bp::arg("residx") )
                , bp::return_self< >()
                , "Unite this set with the atoms in the\nresidue at index residx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::unite
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*unite_function_type)( ::SireMol::ChainIdx ) ;
            unite_function_type unite_function_value( &::SireMol::AtomSelection::unite );
            
            AtomSelection_exposer.def( 
                "unite"
                , unite_function_value
                , ( bp::arg("chainidx") )
                , bp::return_self< >()
                , "Unite this set with the atoms in the\nchain at index chainidx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::unite
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*unite_function_type)( ::SireMol::SegIdx ) ;
            unite_function_type unite_function_value( &::SireMol::AtomSelection::unite );
            
            AtomSelection_exposer.def( 
                "unite"
                , unite_function_value
                , ( bp::arg("segidx") )
                , bp::return_self< >()
                , "Unite this set with the atoms in the\nsegment at index segidx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::unite
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*unite_function_type)( ::QSet< SireMol::AtomIdx > const & ) ;
            unite_function_type unite_function_value( &::SireMol::AtomSelection::unite );
            
            AtomSelection_exposer.def( 
                "unite"
                , unite_function_value
                , ( bp::arg("atomidx") )
                , bp::return_self< >()
                , "Unite this set with the atoms whose\nindicies are in atomidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::unite
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*unite_function_type)( ::QSet< SireMol::CGIdx > const & ) ;
            unite_function_type unite_function_value( &::SireMol::AtomSelection::unite );
            
            AtomSelection_exposer.def( 
                "unite"
                , unite_function_value
                , ( bp::arg("cgidx") )
                , bp::return_self< >()
                , "Unite this set with the atoms in the\nCutGroups whose indicies are in cgidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::unite
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*unite_function_type)( ::QSet< SireMol::ResIdx > const & ) ;
            unite_function_type unite_function_value( &::SireMol::AtomSelection::unite );
            
            AtomSelection_exposer.def( 
                "unite"
                , unite_function_value
                , ( bp::arg("residx") )
                , bp::return_self< >()
                , "Unite this set with the atoms in the\nresidues whose indicies are in residxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::unite
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*unite_function_type)( ::QSet< SireMol::ChainIdx > const & ) ;
            unite_function_type unite_function_value( &::SireMol::AtomSelection::unite );
            
            AtomSelection_exposer.def( 
                "unite"
                , unite_function_value
                , ( bp::arg("chainidx") )
                , bp::return_self< >()
                , "Unite this set with the atoms in the\nchains whose indicies are in chainidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::unite
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*unite_function_type)( ::QSet< SireMol::SegIdx > const & ) ;
            unite_function_type unite_function_value( &::SireMol::AtomSelection::unite );
            
            AtomSelection_exposer.def( 
                "unite"
                , unite_function_value
                , ( bp::arg("segidx") )
                , bp::return_self< >()
                , "Unite this set with the atoms in the\nsegments whose indicies are in segidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::unite
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*unite_function_type)( ::QList< SireMol::AtomIdx > const & ) ;
            unite_function_type unite_function_value( &::SireMol::AtomSelection::unite );
            
            AtomSelection_exposer.def( 
                "unite"
                , unite_function_value
                , ( bp::arg("atomidx") )
                , bp::return_self< >()
                , "Unite this set with the atoms whose\nindicies are in atomidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::unite
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*unite_function_type)( ::QList< SireMol::CGIdx > const & ) ;
            unite_function_type unite_function_value( &::SireMol::AtomSelection::unite );
            
            AtomSelection_exposer.def( 
                "unite"
                , unite_function_value
                , ( bp::arg("cgidx") )
                , bp::return_self< >()
                , "Unite this set with the atoms in the\nCutGroups whose indicies are in cgidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::unite
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*unite_function_type)( ::QList< SireMol::ResIdx > const & ) ;
            unite_function_type unite_function_value( &::SireMol::AtomSelection::unite );
            
            AtomSelection_exposer.def( 
                "unite"
                , unite_function_value
                , ( bp::arg("residx") )
                , bp::return_self< >()
                , "Unite this set with the atoms in the\nresidues whose indicies are in residxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::unite
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*unite_function_type)( ::QList< SireMol::ChainIdx > const & ) ;
            unite_function_type unite_function_value( &::SireMol::AtomSelection::unite );
            
            AtomSelection_exposer.def( 
                "unite"
                , unite_function_value
                , ( bp::arg("chainidx") )
                , bp::return_self< >()
                , "Unite this set with the atoms in the\nchains whose indicies are in chainidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::unite
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*unite_function_type)( ::QList< SireMol::SegIdx > const & ) ;
            unite_function_type unite_function_value( &::SireMol::AtomSelection::unite );
            
            AtomSelection_exposer.def( 
                "unite"
                , unite_function_value
                , ( bp::arg("segidx") )
                , bp::return_self< >()
                , "Unite this set with the atoms in the\nsegments whose indicies are in segidxs\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::unite
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*unite_function_type)( ::SireMol::AtomID const & ) ;
            unite_function_type unite_function_value( &::SireMol::AtomSelection::unite );
            
            AtomSelection_exposer.def( 
                "unite"
                , unite_function_value
                , ( bp::arg("atomid") )
                , bp::return_self< >()
                , "Unite this set with the atoms identified by\natomid\nThrow: SireMol::missing_atom\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AtomSelection::unite
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*unite_function_type)( ::SireMol::CGID const & ) ;
            unite_function_type unite_function_value( &::SireMol::AtomSelection::unite );
            
            AtomSelection_exposer.def( 
                "unite"
                , unite_function_value
                , ( bp::arg("cgid") )
                , bp::return_self< >()
                , "Unite this set with the atoms in the\nCutGroups identified by cgid\nThrow: SireMol::missing_cutgroup\n" );
        
        }
        { //::SireMol::AtomSelection::unite
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*unite_function_type)( ::SireMol::ResID const & ) ;
            unite_function_type unite_function_value( &::SireMol::AtomSelection::unite );
            
            AtomSelection_exposer.def( 
                "unite"
                , unite_function_value
                , ( bp::arg("resid") )
                , bp::return_self< >()
                , "Unite this set with the atoms in the\nresidues identified by resid\nThrow: SireMol::missing_residue\n" );
        
        }
        { //::SireMol::AtomSelection::unite
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*unite_function_type)( ::SireMol::ChainID const & ) ;
            unite_function_type unite_function_value( &::SireMol::AtomSelection::unite );
            
            AtomSelection_exposer.def( 
                "unite"
                , unite_function_value
                , ( bp::arg("chainid") )
                , bp::return_self< >()
                , "Unite this set with the atoms in the\nchains identified by chainid\nThrow: SireMol::missing_chain\n" );
        
        }
        { //::SireMol::AtomSelection::unite
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*unite_function_type)( ::SireMol::SegID const & ) ;
            unite_function_type unite_function_value( &::SireMol::AtomSelection::unite );
            
            AtomSelection_exposer.def( 
                "unite"
                , unite_function_value
                , ( bp::arg("segid") )
                , bp::return_self< >()
                , "Unite this set with the atoms in the\nsegments identified by segid\nThrow: SireMol::missing_segment\n" );
        
        }
        { //::SireMol::AtomSelection::unite
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*unite_function_type)( ::SireMol::AtomSelection const & ) ;
            unite_function_type unite_function_value( &::SireMol::AtomSelection::unite );
            
            AtomSelection_exposer.def( 
                "unite"
                , unite_function_value
                , ( bp::arg("selection") )
                , bp::return_self< >()
                , "Unite this set with the atoms selected\nin selection\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireMol::AtomSelection::unite
        
            typedef ::SireMol::AtomSelection & ( ::SireMol::AtomSelection::*unite_function_type)( ::QList< SireMol::AtomSelection > const & ) ;
            unite_function_type unite_function_value( &::SireMol::AtomSelection::unite );
            
            AtomSelection_exposer.def( 
                "unite"
                , unite_function_value
                , ( bp::arg("selections") )
                , bp::return_self< >()
                , "Unite this set with all of the passed selections\nThrow: SireError::incompatible_error\n" );
        
        }
        AtomSelection_exposer.staticmethod( "typeName" );
        AtomSelection_exposer.def( "__copy__", &__copy__);
        AtomSelection_exposer.def( "__deepcopy__", &__copy__);
        AtomSelection_exposer.def( "clone", &__copy__);
        AtomSelection_exposer.def( "__rlshift__", &__rlshift__QDataStream< ::SireMol::AtomSelection >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        AtomSelection_exposer.def( "__rrshift__", &__rrshift__QDataStream< ::SireMol::AtomSelection >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        AtomSelection_exposer.def_pickle(sire_pickle_suite< ::SireMol::AtomSelection >());
        AtomSelection_exposer.def( "__str__", &__str__< ::SireMol::AtomSelection > );
        AtomSelection_exposer.def( "__repr__", &__str__< ::SireMol::AtomSelection > );
    }

}
