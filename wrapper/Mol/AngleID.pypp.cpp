// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 2 License

#include "boost/python.hpp"
#include "Helpers/clone_const_reference.hpp"
#include "AngleID.pypp.hpp"

namespace bp = boost::python;

#include "SireBase/property.h"

#include "SireMaths/triangle.h"

#include "SireMaths/vector.h"

#include "SireStream/datastream.h"

#include "SireStream/shareddatastream.h"

#include "angleid.h"

#include "atomcoords.h"

#include "moleculedata.h"

#include "moleculeinfodata.h"

#include "angleid.h"

SireMol::AngleID __copy__(const SireMol::AngleID &other){ return SireMol::AngleID(other); }

#include "Qt/qdatastream.hpp"

#include "Helpers/str.hpp"

#include "Helpers/release_gil_policy.hpp"

void register_AngleID_class(){

    { //::SireMol::AngleID
        typedef bp::class_< SireMol::AngleID, bp::bases< SireID::ID > > AngleID_exposer_t;
        AngleID_exposer_t AngleID_exposer = AngleID_exposer_t( "AngleID", "This class provides a generic ID for an angle between\nthree atoms\n\nAuthor: Christopher Woods\n", bp::init< >("Null constructor") );
        bp::scope AngleID_scope( AngleID_exposer );
        AngleID_exposer.def( bp::init< SireMol::AtomID const &, SireMol::AtomID const &, SireMol::AtomID const & >(( bp::arg("atom0"), bp::arg("atom1"), bp::arg("atom2") ), "Construct a angle between the two specified atoms. The order\nis important, as this angle may be between two different\nmolecules") );
        AngleID_exposer.def( bp::init< SireMol::AngleID const & >(( bp::arg("other") ), "Copy constructor") );
        { //::SireMol::AngleID::atom0
        
            typedef ::SireMol::AtomID const & ( ::SireMol::AngleID::*atom0_function_type)(  ) const;
            atom0_function_type atom0_function_value( &::SireMol::AngleID::atom0 );
            
            AngleID_exposer.def( 
                "atom0"
                , atom0_function_value
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Return the ID of the first atom of the angle" );
        
        }
        { //::SireMol::AngleID::atom1
        
            typedef ::SireMol::AtomID const & ( ::SireMol::AngleID::*atom1_function_type)(  ) const;
            atom1_function_type atom1_function_value( &::SireMol::AngleID::atom1 );
            
            AngleID_exposer.def( 
                "atom1"
                , atom1_function_value
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Return the ID of the second atom of the angle" );
        
        }
        { //::SireMol::AngleID::atom2
        
            typedef ::SireMol::AtomID const & ( ::SireMol::AngleID::*atom2_function_type)(  ) const;
            atom2_function_type atom2_function_value( &::SireMol::AngleID::atom2 );
            
            AngleID_exposer.def( 
                "atom2"
                , atom2_function_value
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Return the ID of the third atom of the angle" );
        
        }
        { //::SireMol::AngleID::hash
        
            typedef ::uint ( ::SireMol::AngleID::*hash_function_type)(  ) const;
            hash_function_type hash_function_value( &::SireMol::AngleID::hash );
            
            AngleID_exposer.def( 
                "hash"
                , hash_function_value
                , bp::release_gil_policy()
                , "Return a hash for this ID" );
        
        }
        { //::SireMol::AngleID::isNull
        
            typedef bool ( ::SireMol::AngleID::*isNull_function_type)(  ) const;
            isNull_function_type isNull_function_value( &::SireMol::AngleID::isNull );
            
            AngleID_exposer.def( 
                "isNull"
                , isNull_function_value
                , bp::release_gil_policy()
                , "Return whether this is a null ID" );
        
        }
        { //::SireMol::AngleID::map
        
            typedef ::boost::tuples::tuple< SireMol::AtomIdx, SireMol::AtomIdx, SireMol::AtomIdx, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type > ( ::SireMol::AngleID::*map_function_type)( ::SireMol::MoleculeInfoData const & ) const;
            map_function_type map_function_value( &::SireMol::AngleID::map );
            
            AngleID_exposer.def( 
                "map"
                , map_function_value
                , ( bp::arg("molinfo") )
                , bp::release_gil_policy()
                , "Return the indicies of the three atoms in this angle - this returns\nthem in the order tuple(angle.atom0(),angle.atom1(),angle.atom2())\nThrow: SireMol::missing_atom\nThrow: SireMol::duplicate_atom\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AngleID::map
        
            typedef ::boost::tuples::tuple< SireMol::AtomIdx, SireMol::AtomIdx, SireMol::AtomIdx, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type > ( ::SireMol::AngleID::*map_function_type)( ::SireMol::MoleculeInfoData const &,::SireMol::MoleculeInfoData const &,::SireMol::MoleculeInfoData const & ) const;
            map_function_type map_function_value( &::SireMol::AngleID::map );
            
            AngleID_exposer.def( 
                "map"
                , map_function_value
                , ( bp::arg("mol0info"), bp::arg("mol1info"), bp::arg("mol2info") )
                , bp::release_gil_policy()
                , "Return the indicies of the three atoms of this angle, between the\ntwo molecules whose data is in mol0info (containing angle.atom0()),\nmol1info (containing angle.atom1()) and mol2info (containing\nangle.atom2())\nThrow: SireMol::missing_atom\nThrow: SireMol::duplicate_atom\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AngleID::mirror
        
            typedef ::SireMol::AngleID ( ::SireMol::AngleID::*mirror_function_type)(  ) const;
            mirror_function_type mirror_function_value( &::SireMol::AngleID::mirror );
            
            AngleID_exposer.def( 
                "mirror"
                , mirror_function_value
                , bp::release_gil_policy()
                , "Return the mirror of this AngleID - i.e. if this is\nAngleID(atom0, atom1, atom2), this returns\nAngleID(atom2, atom1, atom0).\nThis is useful if you know that AngleID(atom0,atom1,atom2) equals\n" );
        
        }
        AngleID_exposer.def( bp::self != bp::self );
        { //::SireMol::AngleID::operator=
        
            typedef ::SireMol::AngleID & ( ::SireMol::AngleID::*assign_function_type)( ::SireMol::AngleID const & ) ;
            assign_function_type assign_function_value( &::SireMol::AngleID::operator= );
            
            AngleID_exposer.def( 
                "assign"
                , assign_function_value
                , ( bp::arg("other") )
                , bp::return_self< >()
                , "" );
        
        }
        AngleID_exposer.def( bp::self == bp::other< SireID::ID >() );
        AngleID_exposer.def( bp::self == bp::self );
        { //::SireMol::AngleID::size
        
            typedef ::SireUnits::Dimension::Angle ( ::SireMol::AngleID::*size_function_type)( ::SireMol::MoleculeData const &,::SireBase::PropertyMap const & ) const;
            size_function_type size_function_value( &::SireMol::AngleID::size );
            
            AngleID_exposer.def( 
                "size"
                , size_function_value
                , ( bp::arg("moldata"), bp::arg("map")=SireBase::PropertyMap() )
                , "Return the size of this angle in the molecule whose data\nis in moldata, using map to find the coordinates property\nThrow: SireBase::missing_property\nThrow: SireError::invalid_cast\nThrow: SireMol::missing_atom\nThrow: SireMol::duplicate_atom\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AngleID::size
        
            typedef ::SireUnits::Dimension::Angle ( ::SireMol::AngleID::*size_function_type)( ::SireMol::MoleculeData const &,::SireMol::MoleculeData const &,::SireMol::MoleculeData const &,::SireBase::PropertyMap const & ) const;
            size_function_type size_function_value( &::SireMol::AngleID::size );
            
            AngleID_exposer.def( 
                "size"
                , size_function_value
                , ( bp::arg("mol0data"), bp::arg("mol1data"), bp::arg("mol2data"), bp::arg("map")=SireBase::PropertyMap() )
                , "Return the size of the angle between atom0() in the\nmolecule whose data is in mol0data, atom1() in the\nmolecule whose data is in mol1data and atom2() in\nthe molecule whose data is in mol2data, using map\nto the find the coordinates property the molecules\nThrow: SireBase::missing_property\nThrow: SireError::invalid_cast\nThrow: SireMol::missing_atom\nThrow: SireMol::duplicate_atom\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AngleID::size
        
            typedef ::SireUnits::Dimension::Angle ( ::SireMol::AngleID::*size_function_type)( ::SireMol::MoleculeData const &,::SireBase::PropertyMap const &,::SireMol::MoleculeData const &,::SireBase::PropertyMap const &,::SireMol::MoleculeData const &,::SireBase::PropertyMap const & ) const;
            size_function_type size_function_value( &::SireMol::AngleID::size );
            
            AngleID_exposer.def( 
                "size"
                , size_function_value
                , ( bp::arg("mol0data"), bp::arg("map0"), bp::arg("mol1data"), bp::arg("map1"), bp::arg("mol2data"), bp::arg("map2") )
                , bp::release_gil_policy()
                , "Return the size of the angle between atom0() in the\nmolecule whose data is in mol0data, atom1() in the\nmolecule whose data is in mol1data and atom2() in\nthe molecule whose data is in mol2data, using map0\nto the find the coordinates property of mol0,\nmap1 to find the coordinates property of mol1\nand map2 to find the coordinates property of mol2\nThrow: SireBase::missing_property\nThrow: SireError::invalid_cast\nThrow: SireMol::missing_atom\nThrow: SireMol::duplicate_atom\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AngleID::toString
        
            typedef ::QString ( ::SireMol::AngleID::*toString_function_type)(  ) const;
            toString_function_type toString_function_value( &::SireMol::AngleID::toString );
            
            AngleID_exposer.def( 
                "toString"
                , toString_function_value
                , bp::release_gil_policy()
                , "Return a string representation of this ID" );
        
        }
        { //::SireMol::AngleID::triangle
        
            typedef ::SireMaths::Triangle ( ::SireMol::AngleID::*triangle_function_type)( ::SireMol::MoleculeData const &,::SireBase::PropertyMap const & ) const;
            triangle_function_type triangle_function_value( &::SireMol::AngleID::triangle );
            
            AngleID_exposer.def( 
                "triangle"
                , triangle_function_value
                , ( bp::arg("moldata"), bp::arg("map")=SireBase::PropertyMap() )
                , "Return the geometric triangle formed by the three atoms\nof this angle in the molecule whose data is in moldata,\nusing map to find the coordinates property.\nThrow: SireBase::missing_property\nThrow: SireError::invalid_cast\nThrow: SireMol::missing_atom\nThrow: SireMol::duplicate_atom\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AngleID::triangle
        
            typedef ::SireMaths::Triangle ( ::SireMol::AngleID::*triangle_function_type)( ::SireMol::MoleculeData const &,::SireMol::MoleculeData const &,::SireMol::MoleculeData const &,::SireBase::PropertyMap const & ) const;
            triangle_function_type triangle_function_value( &::SireMol::AngleID::triangle );
            
            AngleID_exposer.def( 
                "triangle"
                , triangle_function_value
                , ( bp::arg("mol0data"), bp::arg("mol1data"), bp::arg("mol2data"), bp::arg("map")=SireBase::PropertyMap() )
                , "Return the geometric triangle formed by the three atoms,\natom0() in the molecule whose data is in mol0data,\natom1() from mol1data and atom2() from mol2data,\nusing map to find the coordinates property of the\nmolecules\nThrow: SireBase::missing_property\nThrow: SireError::invalid_cast\nThrow: SireMol::missing_atom\nThrow: SireMol::duplicate_atom\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AngleID::triangle
        
            typedef ::SireMaths::Triangle ( ::SireMol::AngleID::*triangle_function_type)( ::SireMol::MoleculeData const &,::SireBase::PropertyMap const &,::SireMol::MoleculeData const &,::SireBase::PropertyMap const &,::SireMol::MoleculeData const &,::SireBase::PropertyMap const & ) const;
            triangle_function_type triangle_function_value( &::SireMol::AngleID::triangle );
            
            AngleID_exposer.def( 
                "triangle"
                , triangle_function_value
                , ( bp::arg("mol0data"), bp::arg("map0"), bp::arg("mol1data"), bp::arg("map1"), bp::arg("mol2data"), bp::arg("map2") )
                , bp::release_gil_policy()
                , "Return the geometric triangle formed by the three atoms,\natom0() in the molecule whose data is in mol0data,\natom1() from mol1data and atom2() from mol2data,\nusing map0 to find the coordinates property of mol0,\nmap1 to find the coordinates property of mol1 and\nmap2 to find the coordinates property of mol2.\nThrow: SireBase::missing_property\nThrow: SireError::invalid_cast\nThrow: SireMol::missing_atom\nThrow: SireMol::duplicate_atom\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AngleID::typeName
        
            typedef char const * ( *typeName_function_type )(  );
            typeName_function_type typeName_function_value( &::SireMol::AngleID::typeName );
            
            AngleID_exposer.def( 
                "typeName"
                , typeName_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireMol::AngleID::vector
        
            typedef ::SireMaths::Vector ( ::SireMol::AngleID::*vector_function_type)( ::SireMol::MoleculeData const &,::SireBase::PropertyMap const & ) const;
            vector_function_type vector_function_value( &::SireMol::AngleID::vector );
            
            AngleID_exposer.def( 
                "vector"
                , vector_function_value
                , ( bp::arg("moldata"), bp::arg("map")=SireBase::PropertyMap() )
                , "Return the vector that is perpendicular to the plane\nformed by atoms atom0(), atom1() and atom2() in the\nmolecule whose data is in moldata, using the supplied\nproperty map to find the property that contains the\ncoordinates to be used\nThrow: SireBase::missing_property\nThrow: SireError::invalid_cast\nThrow: SireMol::missing_atom\nThrow: SireMol::duplicate_atom\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AngleID::vector
        
            typedef ::SireMaths::Vector ( ::SireMol::AngleID::*vector_function_type)( ::SireMol::MoleculeData const &,::SireMol::MoleculeData const &,::SireMol::MoleculeData const &,::SireBase::PropertyMap const & ) const;
            vector_function_type vector_function_value( &::SireMol::AngleID::vector );
            
            AngleID_exposer.def( 
                "vector"
                , vector_function_value
                , ( bp::arg("mol0data"), bp::arg("mol1data"), bp::arg("mol2data"), bp::arg("map")=SireBase::PropertyMap() )
                , "Return the vector that is perpendicular to the plane\nformed by the atoms atom0() in mol0data, atom1() in\nmol1data and atom2() in mol2data, using map to find the\ncoordinates property of the molecules\nThrow: SireBase::missing_property\nThrow: SireError::invalid_cast\nThrow: SireMol::missing_atom\nThrow: SireMol::duplicate_atom\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AngleID::vector
        
            typedef ::SireMaths::Vector ( ::SireMol::AngleID::*vector_function_type)( ::SireMol::MoleculeData const &,::SireBase::PropertyMap const &,::SireMol::MoleculeData const &,::SireBase::PropertyMap const &,::SireMol::MoleculeData const &,::SireBase::PropertyMap const & ) const;
            vector_function_type vector_function_value( &::SireMol::AngleID::vector );
            
            AngleID_exposer.def( 
                "vector"
                , vector_function_value
                , ( bp::arg("mol0data"), bp::arg("map0"), bp::arg("mol1data"), bp::arg("map1"), bp::arg("mol2data"), bp::arg("map2") )
                , bp::release_gil_policy()
                , "Return the vector that is perpendicular to the plane\nformed by the atoms atom0() in mol0data, atom1() in\nmol1data and atom2() in mol2data, using map0 to find the\ncoordinates property of mol0, map1 to find the\ncoordinates property of mol1 and map2 to find the\ncoordinates property of mol2\nThrow: SireBase::missing_property\nThrow: SireError::invalid_cast\nThrow: SireMol::missing_atom\nThrow: SireMol::duplicate_atom\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::AngleID::what
        
            typedef char const * ( ::SireMol::AngleID::*what_function_type)(  ) const;
            what_function_type what_function_value( &::SireMol::AngleID::what );
            
            AngleID_exposer.def( 
                "what"
                , what_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        AngleID_exposer.staticmethod( "typeName" );
        AngleID_exposer.def( "__copy__", &__copy__);
        AngleID_exposer.def( "__deepcopy__", &__copy__);
        AngleID_exposer.def( "clone", &__copy__);
        AngleID_exposer.def( "__rlshift__", &__rlshift__QDataStream< ::SireMol::AngleID >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        AngleID_exposer.def( "__rrshift__", &__rrshift__QDataStream< ::SireMol::AngleID >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        AngleID_exposer.def_pickle(sire_pickle_suite< ::SireMol::AngleID >());
        AngleID_exposer.def( "__str__", &__str__< ::SireMol::AngleID > );
        AngleID_exposer.def( "__repr__", &__str__< ::SireMol::AngleID > );
        AngleID_exposer.def( "__hash__", &::SireMol::AngleID::hash );
    }

}
