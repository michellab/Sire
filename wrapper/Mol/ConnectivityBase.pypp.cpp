// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 2 License

#include "boost/python.hpp"
#include "Helpers/clone_const_reference.hpp"
#include "ConnectivityBase.pypp.hpp"

namespace bp = boost::python;

#include "SireBase/errors.h"

#include "SireMol/errors.h"

#include "SireStream/datastream.h"

#include "SireStream/shareddatastream.h"

#include "angleid.h"

#include "atommatcher.h"

#include "atomselection.h"

#include "bondid.h"

#include "connectivity.h"

#include "dihedralid.h"

#include "improperid.h"

#include "moleculedata.h"

#include "moleculeinfo.h"

#include "moleculeinfodata.h"

#include "moleculeview.h"

#include "tostring.h"

#include <QDataStream>

#include <QDebug>

#include <QElapsedTimer>

#include <boost/assert.hpp>

#include "connectivity.h"

#include "Qt/qdatastream.hpp"

#include "Helpers/str.hpp"

#include "Helpers/release_gil_policy.hpp"

void register_ConnectivityBase_class(){

    { //::SireMol::ConnectivityBase
        typedef bp::class_< SireMol::ConnectivityBase, bp::bases< SireMol::MolViewProperty, SireBase::Property >, boost::noncopyable > ConnectivityBase_exposer_t;
        ConnectivityBase_exposer_t ConnectivityBase_exposer = ConnectivityBase_exposer_t( "ConnectivityBase", "The base class of Connectivity and ConnectivityEditor\n\nAuthor: Christopher Woods\n", bp::no_init );
        bp::scope ConnectivityBase_scope( ConnectivityBase_exposer );
        { //::SireMol::ConnectivityBase::areAngled
        
            typedef bool ( ::SireMol::ConnectivityBase::*areAngled_function_type)( ::SireMol::AtomIdx,::SireMol::AtomIdx ) const;
            areAngled_function_type areAngled_function_value( &::SireMol::ConnectivityBase::areAngled );
            
            ConnectivityBase_exposer.def( 
                "areAngled"
                , areAngled_function_value
                , ( bp::arg("atom0"), bp::arg("atom2") )
                , bp::release_gil_policy()
                , "Return whether or not the two atoms are angled together" );
        
        }
        { //::SireMol::ConnectivityBase::areAngled
        
            typedef bool ( ::SireMol::ConnectivityBase::*areAngled_function_type)( ::SireMol::AtomID const &,::SireMol::AtomID const & ) const;
            areAngled_function_type areAngled_function_value( &::SireMol::ConnectivityBase::areAngled );
            
            ConnectivityBase_exposer.def( 
                "areAngled"
                , areAngled_function_value
                , ( bp::arg("atom0"), bp::arg("atom2") )
                , bp::release_gil_policy()
                , "Return whether or not the two atoms are angled together" );
        
        }
        { //::SireMol::ConnectivityBase::areBonded
        
            typedef bool ( ::SireMol::ConnectivityBase::*areBonded_function_type)( ::SireMol::AtomIdx,::SireMol::AtomIdx ) const;
            areBonded_function_type areBonded_function_value( &::SireMol::ConnectivityBase::areBonded );
            
            ConnectivityBase_exposer.def( 
                "areBonded"
                , areBonded_function_value
                , ( bp::arg("atom0"), bp::arg("atom1") )
                , bp::release_gil_policy()
                , "Return whether or not the two atoms are bonded together" );
        
        }
        { //::SireMol::ConnectivityBase::areBonded
        
            typedef bool ( ::SireMol::ConnectivityBase::*areBonded_function_type)( ::SireMol::AtomID const &,::SireMol::AtomID const & ) const;
            areBonded_function_type areBonded_function_value( &::SireMol::ConnectivityBase::areBonded );
            
            ConnectivityBase_exposer.def( 
                "areBonded"
                , areBonded_function_value
                , ( bp::arg("atom0"), bp::arg("atom1") )
                , bp::release_gil_policy()
                , "Return whether or not the two atoms are bonded together" );
        
        }
        { //::SireMol::ConnectivityBase::areConnected
        
            typedef bool ( ::SireMol::ConnectivityBase::*areConnected_function_type)( ::SireMol::AtomIdx,::SireMol::AtomIdx ) const;
            areConnected_function_type areConnected_function_value( &::SireMol::ConnectivityBase::areConnected );
            
            ConnectivityBase_exposer.def( 
                "areConnected"
                , areConnected_function_value
                , ( bp::arg("atom0"), bp::arg("atom1") )
                , bp::release_gil_policy()
                , "Return whether or not the atoms at indicies atom0 and atom1\nare connected\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::ConnectivityBase::areConnected
        
            typedef bool ( ::SireMol::ConnectivityBase::*areConnected_function_type)( ::SireMol::AtomID const &,::SireMol::AtomID const & ) const;
            areConnected_function_type areConnected_function_value( &::SireMol::ConnectivityBase::areConnected );
            
            ConnectivityBase_exposer.def( 
                "areConnected"
                , areConnected_function_value
                , ( bp::arg("atom0"), bp::arg("atom1") )
                , bp::release_gil_policy()
                , "Return whether or not the atoms identified by atom0 and atom1\nare connected\nThrow: SireMol::missing_atom\nThrow: SireMol::duplicate_atom\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::ConnectivityBase::areConnected
        
            typedef bool ( ::SireMol::ConnectivityBase::*areConnected_function_type)( ::SireMol::ResIdx,::SireMol::ResIdx ) const;
            areConnected_function_type areConnected_function_value( &::SireMol::ConnectivityBase::areConnected );
            
            ConnectivityBase_exposer.def( 
                "areConnected"
                , areConnected_function_value
                , ( bp::arg("res0"), bp::arg("res1") )
                , bp::release_gil_policy()
                , "Return whether or not the residues at indicies res0 and res1\nare connected\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::ConnectivityBase::areConnected
        
            typedef bool ( ::SireMol::ConnectivityBase::*areConnected_function_type)( ::SireMol::ResID const &,::SireMol::ResID const & ) const;
            areConnected_function_type areConnected_function_value( &::SireMol::ConnectivityBase::areConnected );
            
            ConnectivityBase_exposer.def( 
                "areConnected"
                , areConnected_function_value
                , ( bp::arg("res0"), bp::arg("res1") )
                , bp::release_gil_policy()
                , "Return whether the residues identified by res0 and res1 are connected" );
        
        }
        { //::SireMol::ConnectivityBase::areConnected
        
            typedef bool ( ::SireMol::ConnectivityBase::*areConnected_function_type)( ::SireMol::CGIdx,::SireMol::CGIdx ) const;
            areConnected_function_type areConnected_function_value( &::SireMol::ConnectivityBase::areConnected );
            
            ConnectivityBase_exposer.def( 
                "areConnected"
                , areConnected_function_value
                , ( bp::arg("cg0"), bp::arg("cg1") )
                , bp::release_gil_policy()
                , "Return whether or not the CutGroups at indicies cg0 and cg1 are\nconnected" );
        
        }
        { //::SireMol::ConnectivityBase::areConnected
        
            typedef bool ( ::SireMol::ConnectivityBase::*areConnected_function_type)( ::SireMol::CGID const &,::SireMol::CGID const & ) const;
            areConnected_function_type areConnected_function_value( &::SireMol::ConnectivityBase::areConnected );
            
            ConnectivityBase_exposer.def( 
                "areConnected"
                , areConnected_function_value
                , ( bp::arg("cg0"), bp::arg("cg1") )
                , bp::release_gil_policy()
                , "Return whether or not the CutGroups at indicies cg0 and cg1 are\nconnected" );
        
        }
        { //::SireMol::ConnectivityBase::areDihedraled
        
            typedef bool ( ::SireMol::ConnectivityBase::*areDihedraled_function_type)( ::SireMol::AtomIdx,::SireMol::AtomIdx ) const;
            areDihedraled_function_type areDihedraled_function_value( &::SireMol::ConnectivityBase::areDihedraled );
            
            ConnectivityBase_exposer.def( 
                "areDihedraled"
                , areDihedraled_function_value
                , ( bp::arg("atom0"), bp::arg("atom3") )
                , bp::release_gil_policy()
                , "Return whether or not the two atoms are dihedraled together" );
        
        }
        { //::SireMol::ConnectivityBase::areDihedraled
        
            typedef bool ( ::SireMol::ConnectivityBase::*areDihedraled_function_type)( ::SireMol::AtomID const &,::SireMol::AtomID const & ) const;
            areDihedraled_function_type areDihedraled_function_value( &::SireMol::ConnectivityBase::areDihedraled );
            
            ConnectivityBase_exposer.def( 
                "areDihedraled"
                , areDihedraled_function_value
                , ( bp::arg("atom0"), bp::arg("atom3") )
                , bp::release_gil_policy()
                , "Return whether or not the two atoms are bonded together" );
        
        }
        { //::SireMol::ConnectivityBase::assertHasProperty
        
            typedef void ( ::SireMol::ConnectivityBase::*assertHasProperty_function_type)( ::SireMol::BondID const &,::SireBase::PropertyName const & ) const;
            assertHasProperty_function_type assertHasProperty_function_value( &::SireMol::ConnectivityBase::assertHasProperty );
            
            ConnectivityBase_exposer.def( 
                "assertHasProperty"
                , assertHasProperty_function_value
                , ( bp::arg("bond"), bp::arg("key") )
                , bp::release_gil_policy()
                , "Assert that the specified bond has the specified property" );
        
        }
        { //::SireMol::ConnectivityBase::connectionType
        
            typedef int ( ::SireMol::ConnectivityBase::*connectionType_function_type)( ::SireMol::AtomIdx,::SireMol::AtomIdx ) const;
            connectionType_function_type connectionType_function_value( &::SireMol::ConnectivityBase::connectionType );
            
            ConnectivityBase_exposer.def( 
                "connectionType"
                , connectionType_function_value
                , ( bp::arg("atom0"), bp::arg("atom1") )
                , bp::release_gil_policy()
                , "Return the connection type of the passed two atoms. This returns;\n" );
        
        }
        { //::SireMol::ConnectivityBase::connectionType
        
            typedef int ( ::SireMol::ConnectivityBase::*connectionType_function_type)( ::SireMol::AtomID const &,::SireMol::AtomID const & ) const;
            connectionType_function_type connectionType_function_value( &::SireMol::ConnectivityBase::connectionType );
            
            ConnectivityBase_exposer.def( 
                "connectionType"
                , connectionType_function_value
                , ( bp::arg("atom0"), bp::arg("atom1") )
                , bp::release_gil_policy()
                , "Return the connection type of the passed two atoms. This returns;\n" );
        
        }
        { //::SireMol::ConnectivityBase::connectionsTo
        
            typedef ::QSet< SireMol::AtomIdx > const & ( ::SireMol::ConnectivityBase::*connectionsTo_function_type)( ::SireMol::AtomIdx ) const;
            connectionsTo_function_type connectionsTo_function_value( &::SireMol::ConnectivityBase::connectionsTo );
            
            ConnectivityBase_exposer.def( 
                "connectionsTo"
                , connectionsTo_function_value
                , ( bp::arg("atomidx") )
                , bp::return_value_policy< bp::copy_const_reference >()
                , "Return the indicies of atoms connected to the atom at index atomidx.\nThis returns an empty set if there are no atoms connected to\nthis atom\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::ConnectivityBase::connectionsTo
        
            typedef ::QSet< SireMol::AtomIdx > const & ( ::SireMol::ConnectivityBase::*connectionsTo_function_type)( ::SireMol::AtomID const & ) const;
            connectionsTo_function_type connectionsTo_function_value( &::SireMol::ConnectivityBase::connectionsTo );
            
            ConnectivityBase_exposer.def( 
                "connectionsTo"
                , connectionsTo_function_value
                , ( bp::arg("atomid") )
                , bp::return_value_policy< bp::copy_const_reference >()
                , "Return the indicies of atoms connected to the atom identified\nby resid - this returns an empty set if there are no connections\nto this atom\nThrow: SireMol::missing_atom\nThrow: SireMol::duplicate_atom\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::ConnectivityBase::connectionsTo
        
            typedef ::QSet< SireMol::ResIdx > const & ( ::SireMol::ConnectivityBase::*connectionsTo_function_type)( ::SireMol::ResIdx ) const;
            connectionsTo_function_type connectionsTo_function_value( &::SireMol::ConnectivityBase::connectionsTo );
            
            ConnectivityBase_exposer.def( 
                "connectionsTo"
                , connectionsTo_function_value
                , ( bp::arg("residx") )
                , bp::return_value_policy< bp::copy_const_reference >()
                , "Return the indicies of the residues connected to the residue at\nindex residx. This returns an empty set if there are no residues\nconnected to this residue\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::ConnectivityBase::connectionsTo
        
            typedef ::QSet< SireMol::ResIdx > const & ( ::SireMol::ConnectivityBase::*connectionsTo_function_type)( ::SireMol::ResID const & ) const;
            connectionsTo_function_type connectionsTo_function_value( &::SireMol::ConnectivityBase::connectionsTo );
            
            ConnectivityBase_exposer.def( 
                "connectionsTo"
                , connectionsTo_function_value
                , ( bp::arg("resid") )
                , bp::return_value_policy< bp::copy_const_reference >()
                , "Return the indicies of the residues connectd to the residue\nidentified by resid. This returns an empty set if there are\nno residues connected to this residue.\nThrow: SireMol::missing_residue\nThrow: SireMol::duplicate_residue\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::ConnectivityBase::findPath
        
            typedef ::QList< SireMol::AtomIdx > ( ::SireMol::ConnectivityBase::*findPath_function_type)( ::SireMol::AtomIdx,::SireMol::AtomIdx ) const;
            findPath_function_type findPath_function_value( &::SireMol::ConnectivityBase::findPath );
            
            ConnectivityBase_exposer.def( 
                "findPath"
                , findPath_function_value
                , ( bp::arg("atom0"), bp::arg("atom1") )
                , bp::release_gil_policy()
                , "Find the shortest bonded path between two atoms. This returns an empty\nlist if there is no bonded path between these two atoms" );
        
        }
        { //::SireMol::ConnectivityBase::findPath
        
            typedef ::QList< SireMol::AtomIdx > ( ::SireMol::ConnectivityBase::*findPath_function_type)( ::SireMol::AtomIdx,::SireMol::AtomIdx,int ) const;
            findPath_function_type findPath_function_value( &::SireMol::ConnectivityBase::findPath );
            
            ConnectivityBase_exposer.def( 
                "findPath"
                , findPath_function_value
                , ( bp::arg("atom0"), bp::arg("atom1"), bp::arg("max_length") )
                , bp::release_gil_policy()
                , "Find the shortest bonded path between two atoms where the path has\na maximum length. This returns an empty list if there is no bonded\npath between these two atoms" );
        
        }
        { //::SireMol::ConnectivityBase::findPath
        
            typedef ::QList< SireMol::AtomIdx > ( ::SireMol::ConnectivityBase::*findPath_function_type)( ::SireMol::AtomID const &,::SireMol::AtomID const & ) const;
            findPath_function_type findPath_function_value( &::SireMol::ConnectivityBase::findPath );
            
            ConnectivityBase_exposer.def( 
                "findPath"
                , findPath_function_value
                , ( bp::arg("atom0"), bp::arg("atom1") )
                , bp::release_gil_policy()
                , "Return all possible bonded paths between two atoms. This returns an empty\nlist if there are no bonded paths between the two atoms" );
        
        }
        { //::SireMol::ConnectivityBase::findPath
        
            typedef ::QList< SireMol::AtomIdx > ( ::SireMol::ConnectivityBase::*findPath_function_type)( ::SireMol::AtomID const &,::SireMol::AtomID const &,int ) const;
            findPath_function_type findPath_function_value( &::SireMol::ConnectivityBase::findPath );
            
            ConnectivityBase_exposer.def( 
                "findPath"
                , findPath_function_value
                , ( bp::arg("atom0"), bp::arg("atom1"), bp::arg("max_length") )
                , bp::release_gil_policy()
                , "Return all possible bonded paths between two atoms. This returns an empty\nlist if there are no bonded paths between the two atoms where the path has\na maximum length." );
        
        }
        { //::SireMol::ConnectivityBase::findPaths
        
            typedef ::QList< QList< SireMol::AtomIdx > > ( ::SireMol::ConnectivityBase::*findPaths_function_type)( ::SireMol::AtomIdx,::SireMol::AtomIdx ) const;
            findPaths_function_type findPaths_function_value( &::SireMol::ConnectivityBase::findPaths );
            
            ConnectivityBase_exposer.def( 
                "findPaths"
                , findPaths_function_value
                , ( bp::arg("atom0"), bp::arg("atom1") )
                , bp::release_gil_policy()
                , "Return all possible bonded paths between two atoms. This returns an empty\nlist if there are no bonded paths between the two atoms" );
        
        }
        { //::SireMol::ConnectivityBase::findPaths
        
            typedef ::QList< QList< SireMol::AtomIdx > > ( ::SireMol::ConnectivityBase::*findPaths_function_type)( ::SireMol::AtomIdx,::SireMol::AtomIdx,int ) const;
            findPaths_function_type findPaths_function_value( &::SireMol::ConnectivityBase::findPaths );
            
            ConnectivityBase_exposer.def( 
                "findPaths"
                , findPaths_function_value
                , ( bp::arg("atom0"), bp::arg("atom1"), bp::arg("max_length") )
                , bp::release_gil_policy()
                , "Return all possible bonded paths between two atoms where the path has\na maximum length. This returns an empty list if there are no bonded\npaths between the two atoms" );
        
        }
        { //::SireMol::ConnectivityBase::findPaths
        
            typedef ::QList< QList< SireMol::AtomIdx > > ( ::SireMol::ConnectivityBase::*findPaths_function_type)( ::SireMol::AtomID const &,::SireMol::AtomID const & ) const;
            findPaths_function_type findPaths_function_value( &::SireMol::ConnectivityBase::findPaths );
            
            ConnectivityBase_exposer.def( 
                "findPaths"
                , findPaths_function_value
                , ( bp::arg("atom0"), bp::arg("atom1") )
                , bp::release_gil_policy()
                , "Find the shortest bonded path between two atoms. This returns an empty\nlist if there is no bonded path between these two atoms" );
        
        }
        { //::SireMol::ConnectivityBase::findPaths
        
            typedef ::QList< QList< SireMol::AtomIdx > > ( ::SireMol::ConnectivityBase::*findPaths_function_type)( ::SireMol::AtomID const &,::SireMol::AtomID const &,int ) const;
            findPaths_function_type findPaths_function_value( &::SireMol::ConnectivityBase::findPaths );
            
            ConnectivityBase_exposer.def( 
                "findPaths"
                , findPaths_function_value
                , ( bp::arg("atom0"), bp::arg("atom1"), bp::arg("max_length") )
                , bp::release_gil_policy()
                , "Find the shortest bonded path between two atoms where the path has\na maximum length. This returns an empty list if there is no bonded\npath between these two atoms" );
        
        }
        { //::SireMol::ConnectivityBase::getAngles
        
            typedef ::QList< SireMol::AngleID > ( ::SireMol::ConnectivityBase::*getAngles_function_type)(  ) const;
            getAngles_function_type getAngles_function_value( &::SireMol::ConnectivityBase::getAngles );
            
            ConnectivityBase_exposer.def( 
                "getAngles"
                , getAngles_function_value
                , bp::release_gil_policy()
                , "Return a list of angles defined by the connectivity" );
        
        }
        { //::SireMol::ConnectivityBase::getAngles
        
            typedef ::QList< SireMol::AngleID > ( ::SireMol::ConnectivityBase::*getAngles_function_type)( ::SireMol::AtomID const & ) const;
            getAngles_function_type getAngles_function_value( &::SireMol::ConnectivityBase::getAngles );
            
            ConnectivityBase_exposer.def( 
                "getAngles"
                , getAngles_function_value
                , ( bp::arg("atom0") )
                , bp::release_gil_policy()
                , "Return a list of angles defined by the connectivity that involve atom0" );
        
        }
        { //::SireMol::ConnectivityBase::getAngles
        
            typedef ::QList< SireMol::AngleID > ( ::SireMol::ConnectivityBase::*getAngles_function_type)( ::SireMol::AtomID const &,::SireMol::AtomID const & ) const;
            getAngles_function_type getAngles_function_value( &::SireMol::ConnectivityBase::getAngles );
            
            ConnectivityBase_exposer.def( 
                "getAngles"
                , getAngles_function_value
                , ( bp::arg("atom0"), bp::arg("atom1") )
                , bp::release_gil_policy()
                , "Return a list of angles defined by the connectivity that involve atom0 and atom1" );
        
        }
        { //::SireMol::ConnectivityBase::getBondMatrix
        
            typedef ::QVector< QVector< bool > > ( ::SireMol::ConnectivityBase::*getBondMatrix_function_type)( int ) const;
            getBondMatrix_function_type getBondMatrix_function_value( &::SireMol::ConnectivityBase::getBondMatrix );
            
            ConnectivityBase_exposer.def( 
                "getBondMatrix"
                , getBondMatrix_function_value
                , ( bp::arg("order") )
                , bp::release_gil_policy()
                , "Return a matrix (organised by AtomIdx) that says which atoms are bonded up to\norder order (e.g. if order is two, it returns true for each atom pair that\nare bonded together, if order is three, then true for each atom pair that are\nbonded or angled together, if order is four, then true for each atom pair\nthat are bonded, angled or dihedraled)" );
        
        }
        { //::SireMol::ConnectivityBase::getBondMatrix
        
            typedef ::QVector< QVector< bool > > ( ::SireMol::ConnectivityBase::*getBondMatrix_function_type)( int,int ) const;
            getBondMatrix_function_type getBondMatrix_function_value( &::SireMol::ConnectivityBase::getBondMatrix );
            
            ConnectivityBase_exposer.def( 
                "getBondMatrix"
                , getBondMatrix_function_value
                , ( bp::arg("start"), bp::arg("end") )
                , bp::release_gil_policy()
                , "Return a matrix (organised by AtomIdx) that says which atoms are bonded between\norder start and order end (e.g. if order is two, it returns true for each atom pair that\nare bonded together, if order is three, then true for each atom pair that are\nbonded or angled together, if order is four, then true for each atom pair\nthat are bonded, angled or dihedraled)" );
        
        }
        { //::SireMol::ConnectivityBase::getBonds
        
            typedef ::QList< SireMol::BondID > ( ::SireMol::ConnectivityBase::*getBonds_function_type)(  ) const;
            getBonds_function_type getBonds_function_value( &::SireMol::ConnectivityBase::getBonds );
            
            ConnectivityBase_exposer.def( 
                "getBonds"
                , getBonds_function_value
                , bp::release_gil_policy()
                , "Return the list of bonds present in this connectivity" );
        
        }
        { //::SireMol::ConnectivityBase::getBonds
        
            typedef ::QList< SireMol::BondID > ( ::SireMol::ConnectivityBase::*getBonds_function_type)( ::SireMol::AtomID const & ) const;
            getBonds_function_type getBonds_function_value( &::SireMol::ConnectivityBase::getBonds );
            
            ConnectivityBase_exposer.def( 
                "getBonds"
                , getBonds_function_value
                , ( bp::arg("atom") )
                , bp::release_gil_policy()
                , "Return the list of bonds in the connectivity containing atom" );
        
        }
        { //::SireMol::ConnectivityBase::getDihedrals
        
            typedef ::QList< SireMol::DihedralID > ( ::SireMol::ConnectivityBase::*getDihedrals_function_type)(  ) const;
            getDihedrals_function_type getDihedrals_function_value( &::SireMol::ConnectivityBase::getDihedrals );
            
            ConnectivityBase_exposer.def( 
                "getDihedrals"
                , getDihedrals_function_value
                , bp::release_gil_policy()
                , "Return a list of dihedrals defined by the connectivity" );
        
        }
        { //::SireMol::ConnectivityBase::getDihedrals
        
            typedef ::QList< SireMol::DihedralID > ( ::SireMol::ConnectivityBase::*getDihedrals_function_type)( ::SireMol::AtomID const & ) const;
            getDihedrals_function_type getDihedrals_function_value( &::SireMol::ConnectivityBase::getDihedrals );
            
            ConnectivityBase_exposer.def( 
                "getDihedrals"
                , getDihedrals_function_value
                , ( bp::arg("atom0") )
                , bp::release_gil_policy()
                , "Return a list of dihedrals defined by the connectivity that involve atom0" );
        
        }
        { //::SireMol::ConnectivityBase::getDihedrals
        
            typedef ::QList< SireMol::DihedralID > ( ::SireMol::ConnectivityBase::*getDihedrals_function_type)( ::SireMol::AtomID const &,::SireMol::AtomID const & ) const;
            getDihedrals_function_type getDihedrals_function_value( &::SireMol::ConnectivityBase::getDihedrals );
            
            ConnectivityBase_exposer.def( 
                "getDihedrals"
                , getDihedrals_function_value
                , ( bp::arg("atom0"), bp::arg("atom1") )
                , bp::release_gil_policy()
                , "Return a list of dihedrals defined by the connectivity that involve atom0 and atom1" );
        
        }
        { //::SireMol::ConnectivityBase::getDihedrals
        
            typedef ::QList< SireMol::DihedralID > ( ::SireMol::ConnectivityBase::*getDihedrals_function_type)( ::SireMol::AtomID const &,::SireMol::AtomID const &,::SireMol::AtomID const & ) const;
            getDihedrals_function_type getDihedrals_function_value( &::SireMol::ConnectivityBase::getDihedrals );
            
            ConnectivityBase_exposer.def( 
                "getDihedrals"
                , getDihedrals_function_value
                , ( bp::arg("atom0"), bp::arg("atom1"), bp::arg("atom2") )
                , bp::release_gil_policy()
                , "Return a list of dihedrals defined by the connectivity that involve atom0, atom1 and atom2" );
        
        }
        { //::SireMol::ConnectivityBase::hasProperty
        
            typedef bool ( ::SireMol::ConnectivityBase::*hasProperty_function_type)( ::SireMol::BondID const &,::SireBase::PropertyName const & ) const;
            hasProperty_function_type hasProperty_function_value( &::SireMol::ConnectivityBase::hasProperty );
            
            ConnectivityBase_exposer.def( 
                "hasProperty"
                , hasProperty_function_value
                , ( bp::arg("bond"), bp::arg("key") )
                , bp::release_gil_policy()
                , "Return whether the specified bond has a property at key key" );
        
        }
        { //::SireMol::ConnectivityBase::inRing
        
            typedef bool ( ::SireMol::ConnectivityBase::*inRing_function_type)( ::SireMol::AtomIdx ) const;
            inRing_function_type inRing_function_value( &::SireMol::ConnectivityBase::inRing );
            
            ConnectivityBase_exposer.def( 
                "inRing"
                , inRing_function_value
                , ( bp::arg("atom") )
                , bp::release_gil_policy()
                , "This function returns whether or not the atom is in a ring." );
        
        }
        { //::SireMol::ConnectivityBase::inRing
        
            typedef bool ( ::SireMol::ConnectivityBase::*inRing_function_type)( ::SireMol::AtomIdx,::SireMol::AtomIdx ) const;
            inRing_function_type inRing_function_value( &::SireMol::ConnectivityBase::inRing );
            
            ConnectivityBase_exposer.def( 
                "inRing"
                , inRing_function_value
                , ( bp::arg("atom0"), bp::arg("atom1") )
                , bp::release_gil_policy()
                , "This function returns whether or not the two passed atoms are connected" );
        
        }
        { //::SireMol::ConnectivityBase::inRing
        
            typedef bool ( ::SireMol::ConnectivityBase::*inRing_function_type)( ::SireMol::AtomIdx,::SireMol::AtomIdx,::SireMol::AtomIdx ) const;
            inRing_function_type inRing_function_value( &::SireMol::ConnectivityBase::inRing );
            
            ConnectivityBase_exposer.def( 
                "inRing"
                , inRing_function_value
                , ( bp::arg("atom0"), bp::arg("atom1"), bp::arg("atom2") )
                , bp::release_gil_policy()
                , "This function returns whether or not the three passed atoms are connected\nvia a ring" );
        
        }
        { //::SireMol::ConnectivityBase::inRing
        
            typedef bool ( ::SireMol::ConnectivityBase::*inRing_function_type)( ::SireMol::AtomIdx,::SireMol::AtomIdx,::SireMol::AtomIdx,::SireMol::AtomIdx ) const;
            inRing_function_type inRing_function_value( &::SireMol::ConnectivityBase::inRing );
            
            ConnectivityBase_exposer.def( 
                "inRing"
                , inRing_function_value
                , ( bp::arg("atom0"), bp::arg("atom1"), bp::arg("atom2"), bp::arg("atom3") )
                , bp::release_gil_policy()
                , "This function returns whether or not the four passed atoms are connected\nvia a same ring" );
        
        }
        { //::SireMol::ConnectivityBase::inRing
        
            typedef bool ( ::SireMol::ConnectivityBase::*inRing_function_type)( ::SireMol::AtomID const & ) const;
            inRing_function_type inRing_function_value( &::SireMol::ConnectivityBase::inRing );
            
            ConnectivityBase_exposer.def( 
                "inRing"
                , inRing_function_value
                , ( bp::arg("atom") )
                , bp::release_gil_policy()
                , "This function returns whether or not the atom is in a ring" );
        
        }
        { //::SireMol::ConnectivityBase::inRing
        
            typedef bool ( ::SireMol::ConnectivityBase::*inRing_function_type)( ::SireMol::AtomID const &,::SireMol::AtomID const & ) const;
            inRing_function_type inRing_function_value( &::SireMol::ConnectivityBase::inRing );
            
            ConnectivityBase_exposer.def( 
                "inRing"
                , inRing_function_value
                , ( bp::arg("atom0"), bp::arg("atom1") )
                , bp::release_gil_policy()
                , "This function returns whether or not the two passed atoms are connected\nvia a ring" );
        
        }
        { //::SireMol::ConnectivityBase::inRing
        
            typedef bool ( ::SireMol::ConnectivityBase::*inRing_function_type)( ::SireMol::AtomID const &,::SireMol::AtomID const &,::SireMol::AtomID const & ) const;
            inRing_function_type inRing_function_value( &::SireMol::ConnectivityBase::inRing );
            
            ConnectivityBase_exposer.def( 
                "inRing"
                , inRing_function_value
                , ( bp::arg("atom0"), bp::arg("atom1"), bp::arg("atom2") )
                , bp::release_gil_policy()
                , "This function returns whether or not the three passed atoms are connected\nvia a ring" );
        
        }
        { //::SireMol::ConnectivityBase::inRing
        
            typedef bool ( ::SireMol::ConnectivityBase::*inRing_function_type)( ::SireMol::AtomID const &,::SireMol::AtomID const &,::SireMol::AtomID const &,::SireMol::AtomID const & ) const;
            inRing_function_type inRing_function_value( &::SireMol::ConnectivityBase::inRing );
            
            ConnectivityBase_exposer.def( 
                "inRing"
                , inRing_function_value
                , ( bp::arg("atom0"), bp::arg("atom1"), bp::arg("atom2"), bp::arg("atom3") )
                , bp::release_gil_policy()
                , "This function returns whether or not the two passed atoms are connected\nvia a ring" );
        
        }
        { //::SireMol::ConnectivityBase::inRing
        
            typedef bool ( ::SireMol::ConnectivityBase::*inRing_function_type)( ::SireMol::BondID const & ) const;
            inRing_function_type inRing_function_value( &::SireMol::ConnectivityBase::inRing );
            
            ConnectivityBase_exposer.def( 
                "inRing"
                , inRing_function_value
                , ( bp::arg("bond") )
                , bp::release_gil_policy()
                , "This function returns whether or not the two atoms in the passed bond\nare both part of the same ring" );
        
        }
        { //::SireMol::ConnectivityBase::inRing
        
            typedef bool ( ::SireMol::ConnectivityBase::*inRing_function_type)( ::SireMol::AngleID const & ) const;
            inRing_function_type inRing_function_value( &::SireMol::ConnectivityBase::inRing );
            
            ConnectivityBase_exposer.def( 
                "inRing"
                , inRing_function_value
                , ( bp::arg("angle") )
                , bp::release_gil_policy()
                , "This function returns whether or not the three atoms in the passed angle\nare all part of the same ring" );
        
        }
        { //::SireMol::ConnectivityBase::inRing
        
            typedef bool ( ::SireMol::ConnectivityBase::*inRing_function_type)( ::SireMol::DihedralID const & ) const;
            inRing_function_type inRing_function_value( &::SireMol::ConnectivityBase::inRing );
            
            ConnectivityBase_exposer.def( 
                "inRing"
                , inRing_function_value
                , ( bp::arg("dihedral") )
                , bp::release_gil_policy()
                , "This function returns whether or not the four atoms in the passed dihedral\nare all part of the same ring" );
        
        }
        { //::SireMol::ConnectivityBase::info
        
            typedef ::SireMol::MoleculeInfo ( ::SireMol::ConnectivityBase::*info_function_type)(  ) const;
            info_function_type info_function_value( &::SireMol::ConnectivityBase::info );
            
            ConnectivityBase_exposer.def( 
                "info"
                , info_function_value
                , bp::release_gil_policy()
                , "Return the info object that describes the molecule for which this connectivity applies" );
        
        }
        { //::SireMol::ConnectivityBase::isCompatibleWith
        
            typedef bool ( ::SireMol::ConnectivityBase::*isCompatibleWith_function_type)( ::SireMol::MoleculeInfoData const & ) const;
            isCompatibleWith_function_type isCompatibleWith_function_value( &::SireMol::ConnectivityBase::isCompatibleWith );
            
            ConnectivityBase_exposer.def( 
                "isCompatibleWith"
                , isCompatibleWith_function_value
                , ( bp::arg("molinfo") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireMol::ConnectivityBase::nConnections
        
            typedef int ( ::SireMol::ConnectivityBase::*nConnections_function_type)(  ) const;
            nConnections_function_type nConnections_function_value( &::SireMol::ConnectivityBase::nConnections );
            
            ConnectivityBase_exposer.def( 
                "nConnections"
                , nConnections_function_value
                , bp::release_gil_policy()
                , "Return the total number of connections between atoms\nin this connectivity object" );
        
        }
        { //::SireMol::ConnectivityBase::nConnections
        
            typedef int ( ::SireMol::ConnectivityBase::*nConnections_function_type)( ::SireMol::AtomIdx ) const;
            nConnections_function_type nConnections_function_value( &::SireMol::ConnectivityBase::nConnections );
            
            ConnectivityBase_exposer.def( 
                "nConnections"
                , nConnections_function_value
                , ( bp::arg("atomidx") )
                , bp::release_gil_policy()
                , "Return the number of connections to the atom at index atomidx\nThrow: SireError::index_error\n" );
        
        }
        { //::SireMol::ConnectivityBase::nConnections
        
            typedef int ( ::SireMol::ConnectivityBase::*nConnections_function_type)( ::SireMol::AtomID const & ) const;
            nConnections_function_type nConnections_function_value( &::SireMol::ConnectivityBase::nConnections );
            
            ConnectivityBase_exposer.def( 
                "nConnections"
                , nConnections_function_value
                , ( bp::arg("atomid") )
                , bp::release_gil_policy()
                , "Return the number of connections to the atom with ID atomid\nThrow: SireMol::missing_atom\nThrow: SireMol::duplicate_atom\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::ConnectivityBase::nConnections
        
            typedef int ( ::SireMol::ConnectivityBase::*nConnections_function_type)( ::SireMol::ResIdx ) const;
            nConnections_function_type nConnections_function_value( &::SireMol::ConnectivityBase::nConnections );
            
            ConnectivityBase_exposer.def( 
                "nConnections"
                , nConnections_function_value
                , ( bp::arg("residx") )
                , bp::release_gil_policy()
                , "Return the number of connections to the residue at index residx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::ConnectivityBase::nConnections
        
            typedef int ( ::SireMol::ConnectivityBase::*nConnections_function_type)( ::SireMol::ResID const & ) const;
            nConnections_function_type nConnections_function_value( &::SireMol::ConnectivityBase::nConnections );
            
            ConnectivityBase_exposer.def( 
                "nConnections"
                , nConnections_function_value
                , ( bp::arg("resid") )
                , bp::release_gil_policy()
                , "Return the number of connections to the residue identified\nby resid\nThrow: SireMol::missing_residue\nThrow: SireMol::duplicate_residue\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::ConnectivityBase::nConnections
        
            typedef int ( ::SireMol::ConnectivityBase::*nConnections_function_type)( ::SireMol::ResIdx,::SireMol::ResIdx ) const;
            nConnections_function_type nConnections_function_value( &::SireMol::ConnectivityBase::nConnections );
            
            ConnectivityBase_exposer.def( 
                "nConnections"
                , nConnections_function_value
                , ( bp::arg("res0"), bp::arg("res1") )
                , bp::release_gil_policy()
                , "Return the number of atom connections between the residues at\nindicies res0 and res1\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::ConnectivityBase::nConnections
        
            typedef int ( ::SireMol::ConnectivityBase::*nConnections_function_type)( ::SireMol::ResID const &,::SireMol::ResID const & ) const;
            nConnections_function_type nConnections_function_value( &::SireMol::ConnectivityBase::nConnections );
            
            ConnectivityBase_exposer.def( 
                "nConnections"
                , nConnections_function_value
                , ( bp::arg("res0"), bp::arg("res1") )
                , bp::release_gil_policy()
                , "Return the number of atom connections between the residues\nidentified by res0 and res1\nThrow: SireMol::missing_residue\nThrow: SireMol::duplicate_residue\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMol::ConnectivityBase::properties
        
            typedef ::SireBase::Properties ( ::SireMol::ConnectivityBase::*properties_function_type)( ::SireMol::BondID const & ) const;
            properties_function_type properties_function_value( &::SireMol::ConnectivityBase::properties );
            
            ConnectivityBase_exposer.def( 
                "properties"
                , properties_function_value
                , ( bp::arg("bond") )
                , bp::release_gil_policy()
                , "Return the properties of the passed bond" );
        
        }
        { //::SireMol::ConnectivityBase::property
        
            typedef ::SireBase::Property const & ( ::SireMol::ConnectivityBase::*property_function_type)( ::SireMol::BondID const &,::SireBase::PropertyName const & ) const;
            property_function_type property_function_value( &::SireMol::ConnectivityBase::property );
            
            ConnectivityBase_exposer.def( 
                "property"
                , property_function_value
                , ( bp::arg("bond"), bp::arg("key") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Return the specified property of the specified bond" );
        
        }
        { //::SireMol::ConnectivityBase::property
        
            typedef ::SireBase::Property const & ( ::SireMol::ConnectivityBase::*property_function_type)( ::SireMol::BondID const &,::SireBase::PropertyName const &,::SireBase::Property const & ) const;
            property_function_type property_function_value( &::SireMol::ConnectivityBase::property );
            
            ConnectivityBase_exposer.def( 
                "property"
                , property_function_value
                , ( bp::arg("bond"), bp::arg("key"), bp::arg("default_value") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Return the specified property of the specified bond, or\ndefault_value if such a property is not defined\n" );
        
        }
        { //::SireMol::ConnectivityBase::propertyKeys
        
            typedef ::QStringList ( ::SireMol::ConnectivityBase::*propertyKeys_function_type)(  ) const;
            propertyKeys_function_type propertyKeys_function_value( &::SireMol::ConnectivityBase::propertyKeys );
            
            ConnectivityBase_exposer.def( 
                "propertyKeys"
                , propertyKeys_function_value
                , bp::release_gil_policy()
                , "Return all of the property keys for all of the bonds" );
        
        }
        { //::SireMol::ConnectivityBase::propertyKeys
        
            typedef ::QStringList ( ::SireMol::ConnectivityBase::*propertyKeys_function_type)( ::SireMol::BondID const & ) const;
            propertyKeys_function_type propertyKeys_function_value( &::SireMol::ConnectivityBase::propertyKeys );
            
            ConnectivityBase_exposer.def( 
                "propertyKeys"
                , propertyKeys_function_value
                , ( bp::arg("bond") )
                , bp::release_gil_policy()
                , "Return the property keys for the specified bond" );
        
        }
        { //::SireMol::ConnectivityBase::propertyType
        
            typedef char const * ( ::SireMol::ConnectivityBase::*propertyType_function_type)( ::SireMol::BondID const &,::SireBase::PropertyName const & ) const;
            propertyType_function_type propertyType_function_value( &::SireMol::ConnectivityBase::propertyType );
            
            ConnectivityBase_exposer.def( 
                "propertyType"
                , propertyType_function_value
                , ( bp::arg("bond"), bp::arg("key") )
                , bp::release_gil_policy()
                , "Return the type of the property for the specified bond at key key" );
        
        }
        { //::SireMol::ConnectivityBase::split
        
            typedef ::boost::tuples::tuple< SireMol::AtomSelection, SireMol::AtomSelection, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type > ( ::SireMol::ConnectivityBase::*split_function_type)( ::SireMol::AtomIdx,::SireMol::AtomIdx ) const;
            split_function_type split_function_value( &::SireMol::ConnectivityBase::split );
            
            ConnectivityBase_exposer.def( 
                "split"
                , split_function_value
                , ( bp::arg("atom0"), bp::arg("atom1") )
                , bp::release_gil_policy()
                , "Split this molecule into two parts about the atoms\n" );
        
        }
        { //::SireMol::ConnectivityBase::split
        
            typedef ::boost::tuples::tuple< SireMol::AtomSelection, SireMol::AtomSelection, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type > ( ::SireMol::ConnectivityBase::*split_function_type)( ::SireMol::AtomID const &,::SireMol::AtomID const & ) const;
            split_function_type split_function_value( &::SireMol::ConnectivityBase::split );
            
            ConnectivityBase_exposer.def( 
                "split"
                , split_function_value
                , ( bp::arg("atom0"), bp::arg("atom1") )
                , bp::release_gil_policy()
                , "Split the molecule into two parts about the bond between atom0 and atom1.\nThrow: SireMol::missing_atom\nThrow: SireMol::duplicate_atom\nThrow: SireError::invalid_index\nThrow: SireMol::ring_error\n" );
        
        }
        { //::SireMol::ConnectivityBase::split
        
            typedef ::boost::tuples::tuple< SireMol::AtomSelection, SireMol::AtomSelection, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type > ( ::SireMol::ConnectivityBase::*split_function_type)( ::SireMol::BondID const & ) const;
            split_function_type split_function_value( &::SireMol::ConnectivityBase::split );
            
            ConnectivityBase_exposer.def( 
                "split"
                , split_function_value
                , ( bp::arg("bond") )
                , bp::release_gil_policy()
                , "Split the molecule into two parts about the bond bond\nThrow: SireMol::missing_atom\nThrow: SireMol::duplicate_atom\nThrow: SireError::invalid_index\nThrow: SireMol::ring_error\n" );
        
        }
        { //::SireMol::ConnectivityBase::split
        
            typedef ::boost::tuples::tuple< SireMol::AtomSelection, SireMol::AtomSelection, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type > ( ::SireMol::ConnectivityBase::*split_function_type)( ::SireMol::AtomIdx,::SireMol::AtomIdx,::SireMol::AtomSelection const & ) const;
            split_function_type split_function_value( &::SireMol::ConnectivityBase::split );
            
            ConnectivityBase_exposer.def( 
                "split"
                , split_function_value
                , ( bp::arg("atom0"), bp::arg("atom1"), bp::arg("selected_atoms") )
                , bp::release_gil_policy()
                , "Split the selected atoms of this molecule into two parts about the atoms\n" );
        
        }
        { //::SireMol::ConnectivityBase::split
        
            typedef ::boost::tuples::tuple< SireMol::AtomSelection, SireMol::AtomSelection, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type > ( ::SireMol::ConnectivityBase::*split_function_type)( ::SireMol::AtomID const &,::SireMol::AtomID const &,::SireMol::AtomSelection const & ) const;
            split_function_type split_function_value( &::SireMol::ConnectivityBase::split );
            
            ConnectivityBase_exposer.def( 
                "split"
                , split_function_value
                , ( bp::arg("atom0"), bp::arg("atom1"), bp::arg("selected_atoms") )
                , bp::release_gil_policy()
                , "Split the selected atoms of this molecule about the atoms\natom0 and atom1\nThrow: SireMol::incompatible_error\nThrow: SireMol::missing_atom\nThrow: SireMol::duplicate_atom\nThrow: SireError::invalid_index\nThrow: SireMol::ring_error\n" );
        
        }
        { //::SireMol::ConnectivityBase::split
        
            typedef ::boost::tuples::tuple< SireMol::AtomSelection, SireMol::AtomSelection, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type > ( ::SireMol::ConnectivityBase::*split_function_type)( ::SireMol::BondID const &,::SireMol::AtomSelection const & ) const;
            split_function_type split_function_value( &::SireMol::ConnectivityBase::split );
            
            ConnectivityBase_exposer.def( 
                "split"
                , split_function_value
                , ( bp::arg("bond"), bp::arg("selected_atoms") )
                , bp::release_gil_policy()
                , "Split the selected atoms of this molecule into two parts\nabout the bond bond\nThrow: SireError::incompatible_error\nThrow: SireMol::missing_atom\nThrow: SireMol::duplicate_atom\nThrow: SireError::invalid_index\nThrow: SireMol::ring_error\n" );
        
        }
        { //::SireMol::ConnectivityBase::split
        
            typedef ::boost::tuples::tuple< SireMol::AtomSelection, SireMol::AtomSelection, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type > ( ::SireMol::ConnectivityBase::*split_function_type)( ::SireMol::AtomIdx,::SireMol::AtomIdx,::SireMol::AtomIdx ) const;
            split_function_type split_function_value( &::SireMol::ConnectivityBase::split );
            
            ConnectivityBase_exposer.def( 
                "split"
                , split_function_value
                , ( bp::arg("atom0"), bp::arg("atom1"), bp::arg("atom2") )
                , bp::release_gil_policy()
                , "Split this molecule into three parts about the atoms\natom0, atom1 and atom2.\n" );
        
        }
        { //::SireMol::ConnectivityBase::split
        
            typedef ::boost::tuples::tuple< SireMol::AtomSelection, SireMol::AtomSelection, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type > ( ::SireMol::ConnectivityBase::*split_function_type)( ::SireMol::AtomID const &,::SireMol::AtomID const &,::SireMol::AtomID const & ) const;
            split_function_type split_function_value( &::SireMol::ConnectivityBase::split );
            
            ConnectivityBase_exposer.def( 
                "split"
                , split_function_value
                , ( bp::arg("atom0"), bp::arg("atom1"), bp::arg("atom2") )
                , bp::release_gil_policy()
                , "Split the molecule into two parts based on the three supplied atoms\nThrow: SireMol::missing_atom\nThrow: SireMol::duplicate_atom\nThrow: SireError::invalid_index\nThrow: SireMol::ring_error\n" );
        
        }
        { //::SireMol::ConnectivityBase::split
        
            typedef ::boost::tuples::tuple< SireMol::AtomSelection, SireMol::AtomSelection, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type > ( ::SireMol::ConnectivityBase::*split_function_type)( ::SireMol::AngleID const & ) const;
            split_function_type split_function_value( &::SireMol::ConnectivityBase::split );
            
            ConnectivityBase_exposer.def( 
                "split"
                , split_function_value
                , ( bp::arg("angle") )
                , bp::release_gil_policy()
                , "Split the molecule into two parts based on the supplied angle\nThrow: SireMol::missing_atom\nThrow: SireMol::duplicate_atom\nThrow: SireError::invalid_index\nThrow: SireMol::ring_error\n" );
        
        }
        { //::SireMol::ConnectivityBase::split
        
            typedef ::boost::tuples::tuple< SireMol::AtomSelection, SireMol::AtomSelection, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type > ( ::SireMol::ConnectivityBase::*split_function_type)( ::SireMol::AtomIdx,::SireMol::AtomIdx,::SireMol::AtomIdx,::SireMol::AtomSelection const & ) const;
            split_function_type split_function_value( &::SireMol::ConnectivityBase::split );
            
            ConnectivityBase_exposer.def( 
                "split"
                , split_function_value
                , ( bp::arg("atom0"), bp::arg("atom1"), bp::arg("atom2"), bp::arg("selected_atoms") )
                , bp::release_gil_policy()
                , "Split the selected atoms of this molecule into three parts about the atoms\natom0, atom1 and atom2.\nNote that all three atoms must be contained in the selection or else\na missing_atom exception will be thrown\nAn exception will be thrown if it is not possible to split the molecule\nunambiguously in two, as the angle is part of a ring.\n" );
        
        }
        { //::SireMol::ConnectivityBase::split
        
            typedef ::boost::tuples::tuple< SireMol::AtomSelection, SireMol::AtomSelection, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type > ( ::SireMol::ConnectivityBase::*split_function_type)( ::SireMol::AtomID const &,::SireMol::AtomID const &,::SireMol::AtomID const &,::SireMol::AtomSelection const & ) const;
            split_function_type split_function_value( &::SireMol::ConnectivityBase::split );
            
            ConnectivityBase_exposer.def( 
                "split"
                , split_function_value
                , ( bp::arg("atom0"), bp::arg("atom1"), bp::arg("atom2"), bp::arg("selected_atoms") )
                , bp::release_gil_policy()
                , "Split the selected atoms of the molecule into two groups around the\nthree supplied atoms\nThrow: SireError::incompatible_error\nThrow: SireMol::missing_atom\nThrow: SireMol::duplicate_atom\nThrow: SireError::invalid_index\nThrow: SireMol::ring_error\n" );
        
        }
        { //::SireMol::ConnectivityBase::split
        
            typedef ::boost::tuples::tuple< SireMol::AtomSelection, SireMol::AtomSelection, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type > ( ::SireMol::ConnectivityBase::*split_function_type)( ::SireMol::AngleID const &,::SireMol::AtomSelection const & ) const;
            split_function_type split_function_value( &::SireMol::ConnectivityBase::split );
            
            ConnectivityBase_exposer.def( 
                "split"
                , split_function_value
                , ( bp::arg("angle"), bp::arg("selected_atoms") )
                , bp::release_gil_policy()
                , "Split the selected atoms selected_atoms of this molecule\ninto two parts based on the angle identified in\nangle. This splits the molecule about atom0() and atom2()\nof the angle, ignoring atom atom1().\nThrow: SireError::incompatible_error\nThrow: SireMol::missing_atom\nThrow: SireMol::duplicate_atom\nThrow: SireError::invalid_index\nThrow: SireMol::ring_error\n" );
        
        }
        { //::SireMol::ConnectivityBase::split
        
            typedef ::boost::tuples::tuple< SireMol::AtomSelection, SireMol::AtomSelection, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type > ( ::SireMol::ConnectivityBase::*split_function_type)( ::SireMol::AtomIdx,::SireMol::AtomIdx,::SireMol::AtomIdx,::SireMol::AtomIdx ) const;
            split_function_type split_function_value( &::SireMol::ConnectivityBase::split );
            
            ConnectivityBase_exposer.def( 
                "split"
                , split_function_value
                , ( bp::arg("atom0"), bp::arg("atom1"), bp::arg("atom2"), bp::arg("atom3") )
                , bp::release_gil_policy()
                , "Split this molecule into two parts based on the passed atoms.\nThis splits the molecule between atom0 and atom3, ignoring\natom1 and atom2.\nC1   C4--C5--C6\n\ \nC2    C8--C9\n  \  \nC3   C7\n\\nC10--C11\nSplitting C4,C2,C7,C10 will return\n" );
        
        }
        { //::SireMol::ConnectivityBase::split
        
            typedef ::boost::tuples::tuple< SireMol::AtomSelection, SireMol::AtomSelection, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type > ( ::SireMol::ConnectivityBase::*split_function_type)( ::SireMol::AtomID const &,::SireMol::AtomID const &,::SireMol::AtomID const &,::SireMol::AtomID const & ) const;
            split_function_type split_function_value( &::SireMol::ConnectivityBase::split );
            
            ConnectivityBase_exposer.def( 
                "split"
                , split_function_value
                , ( bp::arg("atom0"), bp::arg("atom1"), bp::arg("atom2"), bp::arg("atom3") )
                , bp::release_gil_policy()
                , "Split this molecule into two parts based on the passed atoms.\nThis splits the molecule between atom0 and atom3, ignoring\natom1 and atom2.\nThrow: SireMol::missing_atom\nThrow: SireMol::duplicate_atom\nThrow: SireError::invalid_index\nThrow: SireMol::ring_error\n" );
        
        }
        { //::SireMol::ConnectivityBase::split
        
            typedef ::boost::tuples::tuple< SireMol::AtomSelection, SireMol::AtomSelection, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type > ( ::SireMol::ConnectivityBase::*split_function_type)( ::SireMol::DihedralID const & ) const;
            split_function_type split_function_value( &::SireMol::ConnectivityBase::split );
            
            ConnectivityBase_exposer.def( 
                "split"
                , split_function_value
                , ( bp::arg("dihedral") )
                , bp::release_gil_policy()
                , "Split this molecule into two parts based on the dihedral identified in\ndihedral. This splits the molecule about atom0() and atom3()\nof the dihedral, ignoring atoms atom1() and atom2().\nThrow: SireError::incompatible_error\nThrow: SireMol::missing_atom\nThrow: SireMol::duplicate_atom\nThrow: SireError::invalid_index\nThrow: SireMol::ring_error\n" );
        
        }
        { //::SireMol::ConnectivityBase::split
        
            typedef ::boost::tuples::tuple< SireMol::AtomSelection, SireMol::AtomSelection, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type > ( ::SireMol::ConnectivityBase::*split_function_type)( ::SireMol::AtomIdx,::SireMol::AtomIdx,::SireMol::AtomIdx,::SireMol::AtomIdx,::SireMol::AtomSelection const & ) const;
            split_function_type split_function_value( &::SireMol::ConnectivityBase::split );
            
            ConnectivityBase_exposer.def( 
                "split"
                , split_function_value
                , ( bp::arg("atom0"), bp::arg("atom1"), bp::arg("atom2"), bp::arg("atom3"), bp::arg("selected_atoms") )
                , bp::release_gil_policy()
                , "Split the selected atoms of this molecule into two parts\nbased on the passed atoms.\nThis splits the molecule between atom0 and atom3, ignoring\natom1 and atom2.\nAll four atoms must be selected in selected_atoms or else\na missing_atom exception will be thrown\nC1   C4--C5--C6\n\ \nC2    C8--C9\n  \  \nC3   C7\n\\nC10--C11\nSplitting C4,C2,C7,C10 will return\n" );
        
        }
        { //::SireMol::ConnectivityBase::split
        
            typedef ::boost::tuples::tuple< SireMol::AtomSelection, SireMol::AtomSelection, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type > ( ::SireMol::ConnectivityBase::*split_function_type)( ::SireMol::AtomID const &,::SireMol::AtomID const &,::SireMol::AtomID const &,::SireMol::AtomID const &,::SireMol::AtomSelection const & ) const;
            split_function_type split_function_value( &::SireMol::ConnectivityBase::split );
            
            ConnectivityBase_exposer.def( 
                "split"
                , split_function_value
                , ( bp::arg("atom0"), bp::arg("atom1"), bp::arg("atom2"), bp::arg("atom3"), bp::arg("selected_atoms") )
                , bp::release_gil_policy()
                , "Split the selected atoms selected_atoms of this molecule\ninto two parts based on the passed atoms. This splits\nthe molecule between atom0 and atom3, ignoring atom1 and\natom2.\nThrow: SireError::incompatible_error\nThrow: SireMol::missing_atom\nThrow: SireMol::duplicate_atom\nThrow: SireError::invalid_index\nThrow: SireMol::ring_error\n" );
        
        }
        { //::SireMol::ConnectivityBase::split
        
            typedef ::boost::tuples::tuple< SireMol::AtomSelection, SireMol::AtomSelection, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type > ( ::SireMol::ConnectivityBase::*split_function_type)( ::SireMol::DihedralID const &,::SireMol::AtomSelection const & ) const;
            split_function_type split_function_value( &::SireMol::ConnectivityBase::split );
            
            ConnectivityBase_exposer.def( 
                "split"
                , split_function_value
                , ( bp::arg("dihedral"), bp::arg("selected_atoms") )
                , bp::release_gil_policy()
                , "Split the selected atoms selected_atoms of this molecule\ninto two parts based on the dihedral identified in\ndihedral. This splits the molecule about atom0() and atom3()\nof the dihedral, ignoring atoms atom1() and atom2().\nThrow: SireError::incompatible_error\nThrow: SireMol::missing_atom\nThrow: SireMol::duplicate_atom\nThrow: SireError::invalid_index\nThrow: SireMol::ring_error\n" );
        
        }
        { //::SireMol::ConnectivityBase::split
        
            typedef ::boost::tuples::tuple< SireMol::AtomSelection, SireMol::AtomSelection, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type > ( ::SireMol::ConnectivityBase::*split_function_type)( ::SireMol::ImproperID const & ) const;
            split_function_type split_function_value( &::SireMol::ConnectivityBase::split );
            
            ConnectivityBase_exposer.def( 
                "split"
                , split_function_value
                , ( bp::arg("improper") )
                , bp::release_gil_policy()
                , "Split this molecule into two parts based on the improper angle\nidentified by improper. This splits the molecule about\nbond between atom0() and atom1() of the improper\nThrow: SireMol::missing_atom\nThrow: SireMol::duplicate_atom\nThrow: SireError::invalid_index\nThrow: SireMol::ring_error\n" );
        
        }
        { //::SireMol::ConnectivityBase::split
        
            typedef ::boost::tuples::tuple< SireMol::AtomSelection, SireMol::AtomSelection, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type > ( ::SireMol::ConnectivityBase::*split_function_type)( ::SireMol::ImproperID const &,::SireMol::AtomSelection const & ) const;
            split_function_type split_function_value( &::SireMol::ConnectivityBase::split );
            
            ConnectivityBase_exposer.def( 
                "split"
                , split_function_value
                , ( bp::arg("improper"), bp::arg("selected_atoms") )
                , bp::release_gil_policy()
                , "Split the selected atoms in selected_atoms in this molecule\ninto two parts based on the improper angle\nidentified by improper. This splits the molecule about\nbond between atom0() and atom1() of the improper\nThrow: SireError::incompatible_error\nThrow: SireMol::missing_atom\nThrow: SireMol::duplicate_atom\nThrow: SireError::invalid_index\nThrow: SireMol::ring_error\n" );
        
        }
        { //::SireMol::ConnectivityBase::toCONECT
        
            typedef ::QString ( ::SireMol::ConnectivityBase::*toCONECT_function_type)( int ) const;
            toCONECT_function_type toCONECT_function_value( &::SireMol::ConnectivityBase::toCONECT );
            
            ConnectivityBase_exposer.def( 
                "toCONECT"
                , toCONECT_function_value
                , ( bp::arg("offset")=(int)(0) )
                , "Return a PDB format CONECT record for this connectivity object." );
        
        }
        { //::SireMol::ConnectivityBase::toString
        
            typedef ::QString ( ::SireMol::ConnectivityBase::*toString_function_type)(  ) const;
            toString_function_type toString_function_value( &::SireMol::ConnectivityBase::toString );
            
            ConnectivityBase_exposer.def( 
                "toString"
                , toString_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireMol::ConnectivityBase::typeName
        
            typedef char const * ( *typeName_function_type )(  );
            typeName_function_type typeName_function_value( &::SireMol::ConnectivityBase::typeName );
            
            ConnectivityBase_exposer.def( 
                "typeName"
                , typeName_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        ConnectivityBase_exposer.staticmethod( "typeName" );
        ConnectivityBase_exposer.def( "__rlshift__", &__rlshift__QDataStream< ::SireMol::ConnectivityBase >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        ConnectivityBase_exposer.def( "__rrshift__", &__rrshift__QDataStream< ::SireMol::ConnectivityBase >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        ConnectivityBase_exposer.def_pickle(sire_pickle_suite< ::SireMol::ConnectivityBase >());
        ConnectivityBase_exposer.def( "__str__", &__str__< ::SireMol::ConnectivityBase > );
        ConnectivityBase_exposer.def( "__repr__", &__str__< ::SireMol::ConnectivityBase > );
    }

}
