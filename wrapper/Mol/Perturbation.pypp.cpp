// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 2 License

#include "boost/python.hpp"
#include "Perturbation.pypp.hpp"

namespace bp = boost::python;

#include "SireCAS/identities.h"

#include "SireCAS/values.h"

#include "SireStream/datastream.h"

#include "SireStream/shareddatastream.h"

#include "core.h"

#include "geometryperturbation.h"

#include "molecule.h"

#include "moleditor.h"

#include "mover.hpp"

#include "perturbation.h"

#include "perturbation.h"

#include "Qt/qdatastream.hpp"

#include "Helpers/str.hpp"

#include "Helpers/release_gil_policy.hpp"

void register_Perturbation_class(){

    { //::SireMol::Perturbation
        typedef bp::class_< SireMol::Perturbation, bp::bases< SireBase::Property >, boost::noncopyable > Perturbation_exposer_t;
        Perturbation_exposer_t Perturbation_exposer = Perturbation_exposer_t( "Perturbation", "This is the base class of all perturbation objects. A Perturbation\nis a rule for changing a property of a molecule with respect\nto a driving (reaction) coordinate. Perturbations can be used\nto implement single topology free energy calculations\n\nAuthor: Christopher Woods\n", bp::no_init );
        bp::scope Perturbation_scope( Perturbation_exposer );
        { //::SireMol::Perturbation::children
        
            typedef ::QList< SireBase::PropPtr< SireMol::Perturbation > > ( ::SireMol::Perturbation::*children_function_type)(  ) const;
            children_function_type children_function_value( &::SireMol::Perturbation::children );
            
            Perturbation_exposer.def( 
                "children"
                , children_function_value
                , bp::release_gil_policy()
                , "Return all of the child perturbations that make up\nthis perturbation" );
        
        }
        { //::SireMol::Perturbation::defaultFunction
        
            typedef ::SireCAS::Expression const & ( *defaultFunction_function_type )(  );
            defaultFunction_function_type defaultFunction_function_value( &::SireMol::Perturbation::defaultFunction );
            
            Perturbation_exposer.def( 
                "defaultFunction"
                , defaultFunction_function_value
                , bp::return_value_policy< bp::copy_const_reference >()
                , "Return the default mapping equation for the perturbations - this\nlinearly maps from the initial values at lambda=0 to the\nfinal value at lambda=1" );
        
        }
        { //::SireMol::Perturbation::mappingFunction
        
            typedef ::SireCAS::Expression const & ( ::SireMol::Perturbation::*mappingFunction_function_type)(  ) const;
            mappingFunction_function_type mappingFunction_function_value( &::SireMol::Perturbation::mappingFunction );
            
            Perturbation_exposer.def( 
                "mappingFunction"
                , mappingFunction_function_value
                , bp::return_value_policy< bp::copy_const_reference >()
                , "Return the equation used to control the mapping from the\nthe initial value (represented using symbols().initial()) to\nthe final value (represented using symbols().final()) as a\nfunction of the reaction coordinate (which is normally\nrepresented using symbols().lambda())" );
        
        }
        { //::SireMol::Perturbation::null
        
            typedef ::SireMol::NullPerturbation const & ( *null_function_type )(  );
            null_function_type null_function_value( &::SireMol::Perturbation::null );
            
            Perturbation_exposer.def( 
                "null"
                , null_function_value
                , bp::return_value_policy< bp::copy_const_reference >()
                , "" );
        
        }
        { //::SireMol::Perturbation::perturb
        
            typedef ::SireMol::Molecule ( ::SireMol::Perturbation::*perturb_function_type)( ::SireMol::Molecule const &,::SireCAS::Values const & ) const;
            perturb_function_type perturb_function_value( &::SireMol::Perturbation::perturb );
            
            Perturbation_exposer.def( 
                "perturb"
                , perturb_function_value
                , ( bp::arg("molecule"), bp::arg("values") )
                , bp::release_gil_policy()
                , "Perturb the passed molecule, returning the result\nThrow: SireBase::missing_property\nThrow: SireError::invalid_cast\nThrow: SireError:incompatible_error\n" );
        
        }
        { //::SireMol::Perturbation::propertyMap
        
            typedef ::SireBase::PropertyMap const & ( ::SireMol::Perturbation::*propertyMap_function_type)(  ) const;
            propertyMap_function_type propertyMap_function_value( &::SireMol::Perturbation::propertyMap );
            
            Perturbation_exposer.def( 
                "propertyMap"
                , propertyMap_function_value
                , bp::return_value_policy< bp::copy_const_reference >()
                , "Return the property map used to find the properties used,\nand affected by this perturbation" );
        
        }
        { //::SireMol::Perturbation::recreate
        
            typedef ::SireMol::PerturbationPtr ( ::SireMol::Perturbation::*recreate_function_type)(  ) const;
            recreate_function_type recreate_function_value( &::SireMol::Perturbation::recreate );
            
            Perturbation_exposer.def( 
                "recreate"
                , recreate_function_value
                , bp::release_gil_policy()
                , "Recreate this perturbation - this has the same effect as .clone()" );
        
        }
        { //::SireMol::Perturbation::recreate
        
            typedef ::SireMol::PerturbationPtr ( ::SireMol::Perturbation::*recreate_function_type)( ::SireCAS::Expression const & ) const;
            recreate_function_type recreate_function_value( &::SireMol::Perturbation::recreate );
            
            Perturbation_exposer.def( 
                "recreate"
                , recreate_function_value
                , ( bp::arg("mapping_function") )
                , bp::release_gil_policy()
                , "Recreate this perturbation, replacing its current mapping function\nwith mapping_function" );
        
        }
        { //::SireMol::Perturbation::recreate
        
            typedef ::SireMol::PerturbationPtr ( ::SireMol::Perturbation::*recreate_function_type)( ::SireBase::PropertyMap const & ) const;
            recreate_function_type recreate_function_value( &::SireMol::Perturbation::recreate );
            
            Perturbation_exposer.def( 
                "recreate"
                , recreate_function_value
                , ( bp::arg("map") )
                , bp::release_gil_policy()
                , "Recreate this perturbation, replacing the current property map with map" );
        
        }
        { //::SireMol::Perturbation::recreate
        
            typedef ::SireMol::PerturbationPtr ( ::SireMol::Perturbation::*recreate_function_type)( ::SireCAS::Expression const &,::SireBase::PropertyMap const & ) const;
            recreate_function_type recreate_function_value( &::SireMol::Perturbation::recreate );
            
            Perturbation_exposer.def( 
                "recreate"
                , recreate_function_value
                , ( bp::arg("mapping_function"), bp::arg("map") )
                , bp::release_gil_policy()
                , "Recreate this perturbation, replacing both the mapping function and\nthe property map" );
        
        }
        { //::SireMol::Perturbation::requiredProperties
        
            typedef ::QSet< QString > ( ::SireMol::Perturbation::*requiredProperties_function_type)(  ) const;
            requiredProperties_function_type requiredProperties_function_value( &::SireMol::Perturbation::requiredProperties );
            
            Perturbation_exposer.def( 
                "requiredProperties"
                , requiredProperties_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireMol::Perturbation::requiredSymbols
        
            typedef ::QSet< SireCAS::Symbol > ( ::SireMol::Perturbation::*requiredSymbols_function_type)(  ) const;
            requiredSymbols_function_type requiredSymbols_function_value( &::SireMol::Perturbation::requiredSymbols );
            
            Perturbation_exposer.def( 
                "requiredSymbols"
                , requiredSymbols_function_value
                , bp::release_gil_policy()
                , "Return all of the symbols that need to be supplied\nto the mapping function (i.e. ignoring symbols().initial()\nand symbols().final() )" );
        
        }
        { //::SireMol::Perturbation::substitute
        
            typedef ::SireMol::PerturbationPtr ( ::SireMol::Perturbation::*substitute_function_type)( ::SireCAS::Symbol const &,::SireCAS::Symbol const & ) const;
            substitute_function_type substitute_function_value( &::SireMol::Perturbation::substitute );
            
            Perturbation_exposer.def( 
                "substitute"
                , substitute_function_value
                , ( bp::arg("old_symbol"), bp::arg("new_symbol") )
                , bp::release_gil_policy()
                , "Substitute the symbol old_symbol with the symbol new_symbol\nin all of the mapping functions used by this perturbation. This is\nuseful if, for example, you want to switch from using\nlambda to control the perturbation to using alpha, e.g.\n" );
        
        }
        { //::SireMol::Perturbation::substitute
        
            typedef ::SireMol::PerturbationPtr ( ::SireMol::Perturbation::*substitute_function_type)( ::SireCAS::Identities const & ) const;
            substitute_function_type substitute_function_value( &::SireMol::Perturbation::substitute );
            
            Perturbation_exposer.def( 
                "substitute"
                , substitute_function_value
                , ( bp::arg("identities") )
                , bp::release_gil_policy()
                , "Substitute the identities in identities in all of the mapping functions\nused by this perturbation. This is useful if, for example, you want to\nswitch from using lambda to control the perturbation to using alpha, e.g.\n" );
        
        }
        { //::SireMol::Perturbation::symbols
        
            typedef ::SireMol::PerturbationSymbols const & ( *symbols_function_type )(  );
            symbols_function_type symbols_function_value( &::SireMol::Perturbation::symbols );
            
            Perturbation_exposer.def( 
                "symbols"
                , symbols_function_value
                , bp::return_value_policy< bp::copy_const_reference >()
                , "Return the symbols object that contains the symbols used\nby the mapping equation" );
        
        }
        { //::SireMol::Perturbation::typeName
        
            typedef char const * ( *typeName_function_type )(  );
            typeName_function_type typeName_function_value( &::SireMol::Perturbation::typeName );
            
            Perturbation_exposer.def( 
                "typeName"
                , typeName_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireMol::Perturbation::wouldChange
        
            typedef bool ( ::SireMol::Perturbation::*wouldChange_function_type)( ::SireMol::Molecule const &,::SireCAS::Values const & ) const;
            wouldChange_function_type wouldChange_function_value( &::SireMol::Perturbation::wouldChange );
            
            Perturbation_exposer.def( 
                "wouldChange"
                , wouldChange_function_value
                , ( bp::arg("molecule"), bp::arg("values") )
                , bp::release_gil_policy()
                , "" );
        
        }
        Perturbation_exposer.staticmethod( "defaultFunction" );
        Perturbation_exposer.staticmethod( "null" );
        Perturbation_exposer.staticmethod( "symbols" );
        Perturbation_exposer.staticmethod( "typeName" );
        Perturbation_exposer.def( "__rlshift__", &__rlshift__QDataStream< ::SireMol::Perturbation >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        Perturbation_exposer.def( "__rrshift__", &__rrshift__QDataStream< ::SireMol::Perturbation >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        Perturbation_exposer.def_pickle(sire_pickle_suite< ::SireMol::Perturbation >());
        Perturbation_exposer.def( "__str__", &__str__< ::SireMol::Perturbation > );
        Perturbation_exposer.def( "__repr__", &__str__< ::SireMol::Perturbation > );
    }

}
