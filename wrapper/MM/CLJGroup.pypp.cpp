// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 2 License

#include "boost/python.hpp"
#include "CLJGroup.pypp.hpp"

namespace bp = boost::python;

#include "SireError/errors.h"

#include "SireStream/datastream.h"

#include "SireStream/shareddatastream.h"

#include "cljgroup.h"

#include <QElapsedTimer>

#include "cljgroup.h"

SireMM::CLJGroup __copy__(const SireMM::CLJGroup &other){ return SireMM::CLJGroup(other); }

#include "Qt/qdatastream.hpp"

#include "Helpers/str.hpp"

void register_CLJGroup_class(){

    { //::SireMM::CLJGroup
        typedef bp::class_< SireMM::CLJGroup > CLJGroup_exposer_t;
        CLJGroup_exposer_t CLJGroup_exposer = CLJGroup_exposer_t( "CLJGroup", "This class holds and manages a group of molecules that have been\nadded to a CLJBoxes object.\n\nAuthor: Christopher Woods\n", bp::init< >("Null constructor") );
        bp::scope CLJGroup_scope( CLJGroup_exposer );
        CLJGroup_exposer.def( bp::init< SireMM::CLJAtoms::ID_SOURCE >(( bp::arg("id_source") ), "Construct, suppling the name of the molecule group and the source of the\nCLJAtoms ID_SOURCE property (e.g. USE_MOLNUM for intermolecular forcefields or\nUSE_ATOMNUM for intramolecular forcefields)") );
        CLJGroup_exposer.def( bp::init< SireMM::CLJExtractor::EXTRACT_SOURCE >(( bp::arg("extract_source") ), "Construct specifying how the atoms will be extracted from the molecule") );
        CLJGroup_exposer.def( bp::init< SireMM::CLJAtoms::ID_SOURCE, SireMM::CLJExtractor::EXTRACT_SOURCE >(( bp::arg("id_source"), bp::arg("extract_source") ), "Construct, suppling the name of the molecule group and the source of the\nCLJAtoms ID_SOURCE property (e.g. USE_MOLNUM for intermolecular forcefields or\nUSE_ATOMNUM for intramolecular forcefields), and also specifying if we are going\nto split molecules by cutgroup, residue or molecule, (normally best to\nextract by cutgroup unless you know that all molecules are going to be small)") );
        CLJGroup_exposer.def( bp::init< SireMM::CLJGroup const & >(( bp::arg("other") ), "Copy constructor") );
        { //::SireMM::CLJGroup::accept
        
            typedef void ( ::SireMM::CLJGroup::*accept_function_type)(  ) ;
            accept_function_type accept_function_value( &::SireMM::CLJGroup::accept );
            
            CLJGroup_exposer.def( 
                "accept"
                , accept_function_value
                , "Accept all of the changes in the group. This will ensure that\nall deltas have been removed and all of the atoms are correctly\nadded to the CLJBoxes boxes" );
        
        }
        { //::SireMM::CLJGroup::add
        
            typedef void ( ::SireMM::CLJGroup::*add_function_type)( ::SireMol::MoleculeView const &,::SireBase::PropertyMap const & ) ;
            add_function_type add_function_value( &::SireMM::CLJGroup::add );
            
            CLJGroup_exposer.def( 
                "add"
                , add_function_value
                , ( bp::arg("molview"), bp::arg("map")=SireBase::PropertyMap() )
                , "Add the passed molecule to this group" );
        
        }
        { //::SireMM::CLJGroup::add
        
            typedef void ( ::SireMM::CLJGroup::*add_function_type)( ::SireMol::Molecules const &,::SireBase::PropertyMap const & ) ;
            add_function_type add_function_value( &::SireMM::CLJGroup::add );
            
            CLJGroup_exposer.def( 
                "add"
                , add_function_value
                , ( bp::arg("molecules"), bp::arg("map")=SireBase::PropertyMap() )
                , "Add all of the passed molecules to this group" );
        
        }
        { //::SireMM::CLJGroup::add
        
            typedef void ( ::SireMM::CLJGroup::*add_function_type)( ::SireMol::MoleculeGroup const &,::SireBase::PropertyMap const & ) ;
            add_function_type add_function_value( &::SireMM::CLJGroup::add );
            
            CLJGroup_exposer.def( 
                "add"
                , add_function_value
                , ( bp::arg("molgroup"), bp::arg("map")=SireBase::PropertyMap() )
                , "Add all of the passed molecules to this group" );
        
        }
        { //::SireMM::CLJGroup::boxLength
        
            typedef ::SireUnits::Dimension::Length ( ::SireMM::CLJGroup::*boxLength_function_type)(  ) const;
            boxLength_function_type boxLength_function_value( &::SireMM::CLJGroup::boxLength );
            
            CLJGroup_exposer.def( 
                "boxLength"
                , boxLength_function_value
                , "Return the size of the box used by CLJBoxes to partition space" );
        
        }
        { //::SireMM::CLJGroup::changedAtoms
        
            typedef ::SireMM::CLJAtoms ( ::SireMM::CLJGroup::*changedAtoms_function_type)(  ) const;
            changedAtoms_function_type changedAtoms_function_value( &::SireMM::CLJGroup::changedAtoms );
            
            CLJGroup_exposer.def( 
                "changedAtoms"
                , changedAtoms_function_value
                , "Return the set of all atoms that have changed since the last\ntime accept() was called. This will return an empty set if\nthe workspace was told to mustRecalculateFromScratch()" );
        
        }
        { //::SireMM::CLJGroup::changedMolecules
        
            typedef ::SireMol::Molecules ( ::SireMM::CLJGroup::*changedMolecules_function_type)(  ) const;
            changedMolecules_function_type changedMolecules_function_value( &::SireMM::CLJGroup::changedMolecules );
            
            CLJGroup_exposer.def( 
                "changedMolecules"
                , changedMolecules_function_value
                , "Return all of the molecules that have changed since the last time\nthis CLJGroup was accepted" );
        
        }
        { //::SireMM::CLJGroup::cljBoxes
        
            typedef ::SireMM::CLJBoxes const & ( ::SireMM::CLJGroup::*cljBoxes_function_type)(  ) const;
            cljBoxes_function_type cljBoxes_function_value( &::SireMM::CLJGroup::cljBoxes );
            
            CLJGroup_exposer.def( 
                "cljBoxes"
                , cljBoxes_function_value
                , bp::return_value_policy< bp::copy_const_reference >()
                , "" );
        
        }
        { //::SireMM::CLJGroup::isEmpty
        
            typedef bool ( ::SireMM::CLJGroup::*isEmpty_function_type)(  ) const;
            isEmpty_function_type isEmpty_function_value( &::SireMM::CLJGroup::isEmpty );
            
            CLJGroup_exposer.def( 
                "isEmpty"
                , isEmpty_function_value
                , "" );
        
        }
        { //::SireMM::CLJGroup::isSingleIDChange
        
            typedef bool ( ::SireMM::CLJGroup::*isSingleIDChange_function_type)(  ) const;
            isSingleIDChange_function_type isSingleIDChange_function_value( &::SireMM::CLJGroup::isSingleIDChange );
            
            CLJGroup_exposer.def( 
                "isSingleIDChange"
                , isSingleIDChange_function_value
                , "Return whether or not the changes since the last time accept()\nwas called all change parts of a molecule that all have the same\nID. If they do, then we only need to use changedAtoms() in the\ndelta energy calculation as the changed atoms dont interact with\neach other. Otherwise, we need mergeChanges() to get the changedAtoms\ntogether with oldAtoms and newAtoms, so that we can calculate the\nchange in energy within changedAtoms() itself as well" );
        
        }
        { //::SireMM::CLJGroup::mapForMolecule
        
            typedef ::SireBase::PropertyMap ( ::SireMM::CLJGroup::*mapForMolecule_function_type)( ::SireMol::MolNum ) const;
            mapForMolecule_function_type mapForMolecule_function_value( &::SireMM::CLJGroup::mapForMolecule );
            
            CLJGroup_exposer.def( 
                "mapForMolecule"
                , mapForMolecule_function_value
                , ( bp::arg("molnum") )
                , "Return the property map used for the molecule with number molnum" );
        
        }
        { //::SireMM::CLJGroup::mergeChanges
        
            typedef ::boost::tuples::tuple< SireMM::CLJAtoms, SireMM::CLJAtoms, SireMM::CLJAtoms, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type > ( ::SireMM::CLJGroup::*mergeChanges_function_type)(  ) const;
            mergeChanges_function_type mergeChanges_function_value( &::SireMM::CLJGroup::mergeChanges );
            
            CLJGroup_exposer.def( 
                "mergeChanges"
                , mergeChanges_function_value
                , "Return a tuple of (changedAtoms(),oldAtoms(),newAtoms()). This is\nneeded if more than a single ID group has changed and thus we\nneed to calculate the change in interaction within changedAtoms" );
        
        }
        { //::SireMM::CLJGroup::molecules
        
            typedef ::SireMol::Molecules ( ::SireMM::CLJGroup::*molecules_function_type)(  ) const;
            molecules_function_type molecules_function_value( &::SireMM::CLJGroup::molecules );
            
            CLJGroup_exposer.def( 
                "molecules"
                , molecules_function_value
                , "Return the current version of all of the molecules in this group" );
        
        }
        { //::SireMM::CLJGroup::mustReallyRecalculateFromScratch
        
            typedef void ( ::SireMM::CLJGroup::*mustReallyRecalculateFromScratch_function_type)(  ) ;
            mustReallyRecalculateFromScratch_function_type mustReallyRecalculateFromScratch_function_value( &::SireMM::CLJGroup::mustReallyRecalculateFromScratch );
            
            CLJGroup_exposer.def( 
                "mustReallyRecalculateFromScratch"
                , mustReallyRecalculateFromScratch_function_value
                , "Tell the group that calculations will be made completely from scratch,\nand to also re-extract all of the molecules" );
        
        }
        { //::SireMM::CLJGroup::mustRecalculateFromScratch
        
            typedef void ( ::SireMM::CLJGroup::*mustRecalculateFromScratch_function_type)(  ) ;
            mustRecalculateFromScratch_function_type mustRecalculateFromScratch_function_value( &::SireMM::CLJGroup::mustRecalculateFromScratch );
            
            CLJGroup_exposer.def( 
                "mustRecalculateFromScratch"
                , mustRecalculateFromScratch_function_value
                , "Tell the group that calculations will be made completely from scratch,\nso there is no need to maintain a delta" );
        
        }
        { //::SireMM::CLJGroup::nChangedMolecules
        
            typedef int ( ::SireMM::CLJGroup::*nChangedMolecules_function_type)(  ) const;
            nChangedMolecules_function_type nChangedMolecules_function_value( &::SireMM::CLJGroup::nChangedMolecules );
            
            CLJGroup_exposer.def( 
                "nChangedMolecules"
                , nChangedMolecules_function_value
                , "Return the number of molecules that have changed since the\nlast time this CLJGroup was accepted" );
        
        }
        { //::SireMM::CLJGroup::needsAccepting
        
            typedef bool ( ::SireMM::CLJGroup::*needsAccepting_function_type)(  ) const;
            needsAccepting_function_type needsAccepting_function_value( &::SireMM::CLJGroup::needsAccepting );
            
            CLJGroup_exposer.def( 
                "needsAccepting"
                , needsAccepting_function_value
                , "Return whether or not this group needs to be accepted" );
        
        }
        { //::SireMM::CLJGroup::newAtoms
        
            typedef ::SireMM::CLJAtoms ( ::SireMM::CLJGroup::*newAtoms_function_type)(  ) const;
            newAtoms_function_type newAtoms_function_value( &::SireMM::CLJGroup::newAtoms );
            
            CLJGroup_exposer.def( 
                "newAtoms"
                , newAtoms_function_value
                , "Return the set of all of the new atoms that have changed\nsince the last time accept() was called. This, plus the\nnegative of oldAtoms() will equal changedAtoms()" );
        
        }
        { //::SireMM::CLJGroup::oldAtoms
        
            typedef ::SireMM::CLJAtoms ( ::SireMM::CLJGroup::*oldAtoms_function_type)(  ) const;
            oldAtoms_function_type oldAtoms_function_value( &::SireMM::CLJGroup::oldAtoms );
            
            CLJGroup_exposer.def( 
                "oldAtoms"
                , oldAtoms_function_value
                , "Return the set of all of the old atoms that have changed\nsince the last time accept() was called. The negative\nof this plus newAtoms() will equal changedAtoms()" );
        
        }
        CLJGroup_exposer.def( bp::self != bp::self );
        { //::SireMM::CLJGroup::operator=
        
            typedef ::SireMM::CLJGroup & ( ::SireMM::CLJGroup::*assign_function_type)( ::SireMM::CLJGroup const & ) ;
            assign_function_type assign_function_value( &::SireMM::CLJGroup::operator= );
            
            CLJGroup_exposer.def( 
                "assign"
                , assign_function_value
                , ( bp::arg("other") )
                , bp::return_self< >()
                , "" );
        
        }
        CLJGroup_exposer.def( bp::self == bp::self );
        { //::SireMM::CLJGroup::recalculatingFromScratch
        
            typedef bool ( ::SireMM::CLJGroup::*recalculatingFromScratch_function_type)(  ) const;
            recalculatingFromScratch_function_type recalculatingFromScratch_function_value( &::SireMM::CLJGroup::recalculatingFromScratch );
            
            CLJGroup_exposer.def( 
                "recalculatingFromScratch"
                , recalculatingFromScratch_function_value
                , "" );
        
        }
        { //::SireMM::CLJGroup::remove
        
            typedef void ( ::SireMM::CLJGroup::*remove_function_type)( ::SireMol::MoleculeView const & ) ;
            remove_function_type remove_function_value( &::SireMM::CLJGroup::remove );
            
            CLJGroup_exposer.def( 
                "remove"
                , remove_function_value
                , ( bp::arg("molview") )
                , "Remove the molecule view molview" );
        
        }
        { //::SireMM::CLJGroup::remove
        
            typedef void ( ::SireMM::CLJGroup::*remove_function_type)( ::SireMol::Molecules const & ) ;
            remove_function_type remove_function_value( &::SireMM::CLJGroup::remove );
            
            CLJGroup_exposer.def( 
                "remove"
                , remove_function_value
                , ( bp::arg("molecules") )
                , "Remove all of the molecules in molecules from this group" );
        
        }
        { //::SireMM::CLJGroup::remove
        
            typedef void ( ::SireMM::CLJGroup::*remove_function_type)( ::SireMol::MoleculeGroup const & ) ;
            remove_function_type remove_function_value( &::SireMM::CLJGroup::remove );
            
            CLJGroup_exposer.def( 
                "remove"
                , remove_function_value
                , ( bp::arg("molecules") )
                , "Remove all of the molecules in molecules from this group" );
        
        }
        { //::SireMM::CLJGroup::remove
        
            typedef void ( ::SireMM::CLJGroup::*remove_function_type)( ::SireMol::MolNum ) ;
            remove_function_type remove_function_value( &::SireMM::CLJGroup::remove );
            
            CLJGroup_exposer.def( 
                "remove"
                , remove_function_value
                , ( bp::arg("molnum") )
                , "Remove the molecule with number molnum from this group" );
        
        }
        { //::SireMM::CLJGroup::removeAll
        
            typedef void ( ::SireMM::CLJGroup::*removeAll_function_type)(  ) ;
            removeAll_function_type removeAll_function_value( &::SireMM::CLJGroup::removeAll );
            
            CLJGroup_exposer.def( 
                "removeAll"
                , removeAll_function_value
                , "Remove all molecules from this group" );
        
        }
        { //::SireMM::CLJGroup::setBoxLength
        
            typedef void ( ::SireMM::CLJGroup::*setBoxLength_function_type)( ::SireUnits::Dimension::Length ) ;
            setBoxLength_function_type setBoxLength_function_value( &::SireMM::CLJGroup::setBoxLength );
            
            CLJGroup_exposer.def( 
                "setBoxLength"
                , setBoxLength_function_value
                , ( bp::arg("box_length") )
                , "Set the size of the box used by CLJBoxes to partition space" );
        
        }
        { //::SireMM::CLJGroup::toString
        
            typedef ::QString ( ::SireMM::CLJGroup::*toString_function_type)(  ) const;
            toString_function_type toString_function_value( &::SireMM::CLJGroup::toString );
            
            CLJGroup_exposer.def( 
                "toString"
                , toString_function_value
                , "" );
        
        }
        { //::SireMM::CLJGroup::typeName
        
            typedef char const * ( *typeName_function_type )(  );
            typeName_function_type typeName_function_value( &::SireMM::CLJGroup::typeName );
            
            CLJGroup_exposer.def( 
                "typeName"
                , typeName_function_value
                , "" );
        
        }
        { //::SireMM::CLJGroup::update
        
            typedef void ( ::SireMM::CLJGroup::*update_function_type)( ::SireMol::MoleculeView const & ) ;
            update_function_type update_function_value( &::SireMM::CLJGroup::update );
            
            CLJGroup_exposer.def( 
                "update"
                , update_function_value
                , ( bp::arg("molview") )
                , "Update the molecule in this group to match the version of the molecule molview" );
        
        }
        { //::SireMM::CLJGroup::update
        
            typedef void ( ::SireMM::CLJGroup::*update_function_type)( ::SireMol::Molecules const & ) ;
            update_function_type update_function_value( &::SireMM::CLJGroup::update );
            
            CLJGroup_exposer.def( 
                "update"
                , update_function_value
                , ( bp::arg("molecules") )
                , "Update all of the molecules in this group that are in molecules to match\nthe version held in molecules" );
        
        }
        { //::SireMM::CLJGroup::update
        
            typedef void ( ::SireMM::CLJGroup::*update_function_type)( ::SireMol::MoleculeGroup const & ) ;
            update_function_type update_function_value( &::SireMM::CLJGroup::update );
            
            CLJGroup_exposer.def( 
                "update"
                , update_function_value
                , ( bp::arg("molecules") )
                , "Update all of the molecules in this group that are in molecules to match\nthe version held in molecules" );
        
        }
        { //::SireMM::CLJGroup::updatedConnectedGroup
        
            typedef void ( ::SireMM::CLJGroup::*updatedConnectedGroup_function_type)(  ) ;
            updatedConnectedGroup_function_type updatedConnectedGroup_function_value( &::SireMM::CLJGroup::updatedConnectedGroup );
            
            CLJGroup_exposer.def( 
                "updatedConnectedGroup"
                , updatedConnectedGroup_function_value
                , "Tell this CLJGroup that atoms in a connected group have been\nupdated. This tells the CLJGroup to remove some of the caching\nthat is used to improve performance, as this caching could cause\nenergy errors when using deltas generated from other CLJGroups" );
        
        }
        { //::SireMM::CLJGroup::what
        
            typedef char const * ( ::SireMM::CLJGroup::*what_function_type)(  ) const;
            what_function_type what_function_value( &::SireMM::CLJGroup::what );
            
            CLJGroup_exposer.def( 
                "what"
                , what_function_value
                , "" );
        
        }
        CLJGroup_exposer.staticmethod( "typeName" );
        CLJGroup_exposer.def( "__copy__", &__copy__);
        CLJGroup_exposer.def( "__deepcopy__", &__copy__);
        CLJGroup_exposer.def( "clone", &__copy__);
        CLJGroup_exposer.def( "__rlshift__", &__rlshift__QDataStream< ::SireMM::CLJGroup >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        CLJGroup_exposer.def( "__rrshift__", &__rrshift__QDataStream< ::SireMM::CLJGroup >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        CLJGroup_exposer.def( "__setstate__", &__setstate__base64< ::SireMM::CLJGroup > );
        CLJGroup_exposer.def( "__getstate__", &__getstate__base64< ::SireMM::CLJGroup > );
        CLJGroup_exposer.def( "__str__", &__str__< ::SireMM::CLJGroup > );
        CLJGroup_exposer.def( "__repr__", &__str__< ::SireMM::CLJGroup > );
    }

}
