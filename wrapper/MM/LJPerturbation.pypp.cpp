// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 2 License

#include "boost/python.hpp"
#include "LJPerturbation.pypp.hpp"

namespace bp = boost::python;

#include "SireCAS/identities.h"

#include "SireCAS/values.h"

#include "SireMol/molecule.h"

#include "SireMol/moleditor.h"

#include "SireMol/mover.hpp"

#include "SireStream/datastream.h"

#include "SireStream/shareddatastream.h"

#include "atomljs.h"

#include "ljperturbation.h"

#include "ljperturbation.h"

SireMM::LJPerturbation __copy__(const SireMM::LJPerturbation &other){ return SireMM::LJPerturbation(other); }

#include "Qt/qdatastream.hpp"

#include "Helpers/str.hpp"

void register_LJPerturbation_class(){

    { //::SireMM::LJPerturbation
        typedef bp::class_< SireMM::LJPerturbation, bp::bases< SireMol::Perturbation, SireBase::Property > > LJPerturbation_exposer_t;
        LJPerturbation_exposer_t LJPerturbation_exposer = LJPerturbation_exposer_t( "LJPerturbation", "", bp::init< bp::optional< SireBase::PropertyMap const & > >(( bp::arg("map")=SireBase::PropertyMap() ), "Constructor - this creates a LJ perturbation that\nperturbs from LJs in initial_LJ to LJs in\nfinal_LJ, placing the current LJs in LJ,\nand using Perturbation::defaultEquation() to map the\nsigma and epsilon values of the LJ.") );
        bp::scope LJPerturbation_scope( LJPerturbation_exposer );
        bp::enum_< SireMM::LJPerturbation::MapType>("MapType")
            .value("MAP_SIGMA_AND_EPSILON", SireMM::LJPerturbation::MAP_SIGMA_AND_EPSILON)
            .value("MAP_RMIN_AND_EPSILON", SireMM::LJPerturbation::MAP_RMIN_AND_EPSILON)
            .value("MAP_A_AND_B", SireMM::LJPerturbation::MAP_A_AND_B)
            .export_values()
            ;
        LJPerturbation_exposer.def( bp::init< SireMM::LJPerturbation::MapType, bp::optional< SireBase::PropertyMap const & > >(( bp::arg("maptype"), bp::arg("map")=SireBase::PropertyMap() ), "Construct, using the passed map to find the properties used\nby this perturbation") );
        LJPerturbation_exposer.def( bp::init< SireCAS::Expression const &, bp::optional< SireBase::PropertyMap const & > >(( bp::arg("mapping_function"), bp::arg("map")=SireBase::PropertyMap() ), "Construct, using the passed map to find the properties used\nby this perturbation and the passed mapping function to map\nthe LJs between the states") );
        LJPerturbation_exposer.def( bp::init< SireCAS::Expression const &, SireMM::LJPerturbation::MapType, bp::optional< SireBase::PropertyMap const & > >(( bp::arg("mapping_function"), bp::arg("maptype"), bp::arg("map")=SireBase::PropertyMap() ), "Construct, using the passed map to find the properties used\nby this perturbation and the passed mapping function to map\nthe LJs between the states") );
        LJPerturbation_exposer.def( bp::init< SireCAS::Expression const &, SireCAS::Expression const &, bp::optional< SireBase::PropertyMap const & > >(( bp::arg("sigma_mapping_function"), bp::arg("epsilon_mapping_function"), bp::arg("map")=SireBase::PropertyMap() ), "Construct, using the passed map to find the properties used\nby this perturbation and the passed mapping function to map\nthe LJs between the states") );
        LJPerturbation_exposer.def( bp::init< SireCAS::Expression const &, SireCAS::Expression const &, SireMM::LJPerturbation::MapType, bp::optional< SireBase::PropertyMap const & > >(( bp::arg("sigma_mapping_function"), bp::arg("epsilon_mapping_function"), bp::arg("maptype"), bp::arg("map")=SireBase::PropertyMap() ), "Construct, using the passed map to find the properties used\nby this perturbation and the passed mapping function to map\nthe LJs between the states") );
        LJPerturbation_exposer.def( bp::init< SireMM::LJPerturbation const & >(( bp::arg("other") ), "Copy constructor") );
        { //::SireMM::LJPerturbation::A_MappingFunction
        
            typedef ::SireCAS::Expression const & ( ::SireMM::LJPerturbation::*A_MappingFunction_function_type)(  ) const;
            A_MappingFunction_function_type A_MappingFunction_function_value( &::SireMM::LJPerturbation::A_MappingFunction );
            
            LJPerturbation_exposer.def( 
                "A_MappingFunction"
                , A_MappingFunction_function_value
                , bp::return_value_policy< bp::copy_const_reference >()
                , "Return the function used to map A\nThrow: SireError::invalid_state\n" );
        
        }
        { //::SireMM::LJPerturbation::B_MappingFunction
        
            typedef ::SireCAS::Expression const & ( ::SireMM::LJPerturbation::*B_MappingFunction_function_type)(  ) const;
            B_MappingFunction_function_type B_MappingFunction_function_value( &::SireMM::LJPerturbation::B_MappingFunction );
            
            LJPerturbation_exposer.def( 
                "B_MappingFunction"
                , B_MappingFunction_function_value
                , bp::return_value_policy< bp::copy_const_reference >()
                , "Return the function used to map B\nThrow: SireError::invalid_state\n" );
        
        }
        { //::SireMM::LJPerturbation::epsilonMappingFunction
        
            typedef ::SireCAS::Expression const & ( ::SireMM::LJPerturbation::*epsilonMappingFunction_function_type)(  ) const;
            epsilonMappingFunction_function_type epsilonMappingFunction_function_value( &::SireMM::LJPerturbation::epsilonMappingFunction );
            
            LJPerturbation_exposer.def( 
                "epsilonMappingFunction"
                , epsilonMappingFunction_function_value
                , bp::return_value_policy< bp::copy_const_reference >()
                , "Return the function used to map epsilon\nThrow: SireError::invalid_state\n" );
        
        }
        { //::SireMM::LJPerturbation::mapAB
        
            typedef bool ( ::SireMM::LJPerturbation::*mapAB_function_type)(  ) const;
            mapAB_function_type mapAB_function_value( &::SireMM::LJPerturbation::mapAB );
            
            LJPerturbation_exposer.def( 
                "mapAB"
                , mapAB_function_value
                , "Return whether or not this maps A and B" );
        
        }
        { //::SireMM::LJPerturbation::mapRMinEpsilon
        
            typedef bool ( ::SireMM::LJPerturbation::*mapRMinEpsilon_function_type)(  ) const;
            mapRMinEpsilon_function_type mapRMinEpsilon_function_value( &::SireMM::LJPerturbation::mapRMinEpsilon );
            
            LJPerturbation_exposer.def( 
                "mapRMinEpsilon"
                , mapRMinEpsilon_function_value
                , "Return whether or not this maps r_min and epsilon" );
        
        }
        { //::SireMM::LJPerturbation::mapSigmaEpsilon
        
            typedef bool ( ::SireMM::LJPerturbation::*mapSigmaEpsilon_function_type)(  ) const;
            mapSigmaEpsilon_function_type mapSigmaEpsilon_function_value( &::SireMM::LJPerturbation::mapSigmaEpsilon );
            
            LJPerturbation_exposer.def( 
                "mapSigmaEpsilon"
                , mapSigmaEpsilon_function_value
                , "Return whether or not this maps sigma and epsilon" );
        
        }
        { //::SireMM::LJPerturbation::mappingFunction
        
            typedef ::SireCAS::Expression const & ( ::SireMM::LJPerturbation::*mappingFunction_function_type)(  ) const;
            mappingFunction_function_type mappingFunction_function_value( &::SireMM::LJPerturbation::mappingFunction );
            
            LJPerturbation_exposer.def( 
                "mappingFunction"
                , mappingFunction_function_value
                , bp::return_value_policy< bp::copy_const_reference >()
                , "Return the mapping function\nThrow: SireError::invalid_state\n" );
        
        }
        LJPerturbation_exposer.def( bp::self != bp::self );
        { //::SireMM::LJPerturbation::operator=
        
            typedef ::SireMM::LJPerturbation & ( ::SireMM::LJPerturbation::*assign_function_type)( ::SireMM::LJPerturbation const & ) ;
            assign_function_type assign_function_value( &::SireMM::LJPerturbation::operator= );
            
            LJPerturbation_exposer.def( 
                "assign"
                , assign_function_value
                , ( bp::arg("other") )
                , bp::return_self< >()
                , "" );
        
        }
        LJPerturbation_exposer.def( bp::self == bp::self );
        { //::SireMM::LJPerturbation::rMinMappingFunction
        
            typedef ::SireCAS::Expression const & ( ::SireMM::LJPerturbation::*rMinMappingFunction_function_type)(  ) const;
            rMinMappingFunction_function_type rMinMappingFunction_function_value( &::SireMM::LJPerturbation::rMinMappingFunction );
            
            LJPerturbation_exposer.def( 
                "rMinMappingFunction"
                , rMinMappingFunction_function_value
                , bp::return_value_policy< bp::copy_const_reference >()
                , "Return the function used to map r_min\nThrow: SireError::invalid_state\n" );
        
        }
        { //::SireMM::LJPerturbation::recreate
        
            typedef ::SireMol::PerturbationPtr ( ::SireMM::LJPerturbation::*recreate_function_type)( ::SireCAS::Expression const & ) const;
            recreate_function_type recreate_function_value( &::SireMM::LJPerturbation::recreate );
            
            LJPerturbation_exposer.def( 
                "recreate"
                , recreate_function_value
                , ( bp::arg("mapping_function") )
                , "" );
        
        }
        { //::SireMM::LJPerturbation::recreate
        
            typedef ::SireMol::PerturbationPtr ( ::SireMM::LJPerturbation::*recreate_function_type)( ::SireCAS::Expression const &,::SireBase::PropertyMap const & ) const;
            recreate_function_type recreate_function_value( &::SireMM::LJPerturbation::recreate );
            
            LJPerturbation_exposer.def( 
                "recreate"
                , recreate_function_value
                , ( bp::arg("mapping_function"), bp::arg("map") )
                , "" );
        
        }
        { //::SireMM::LJPerturbation::requiredProperties
        
            typedef ::QSet< QString > ( ::SireMM::LJPerturbation::*requiredProperties_function_type)(  ) const;
            requiredProperties_function_type requiredProperties_function_value( &::SireMM::LJPerturbation::requiredProperties );
            
            LJPerturbation_exposer.def( 
                "requiredProperties"
                , requiredProperties_function_value
                , "Return the properties required or changed by this perturbation" );
        
        }
        { //::SireMM::LJPerturbation::sigmaMappingFunction
        
            typedef ::SireCAS::Expression const & ( ::SireMM::LJPerturbation::*sigmaMappingFunction_function_type)(  ) const;
            sigmaMappingFunction_function_type sigmaMappingFunction_function_value( &::SireMM::LJPerturbation::sigmaMappingFunction );
            
            LJPerturbation_exposer.def( 
                "sigmaMappingFunction"
                , sigmaMappingFunction_function_value
                , bp::return_value_policy< bp::copy_const_reference >()
                , "Return the function used to map sigma\nThrow: SireError::invalid_state\n" );
        
        }
        { //::SireMM::LJPerturbation::substitute
        
            typedef ::SireMol::PerturbationPtr ( ::SireMM::LJPerturbation::*substitute_function_type)( ::SireCAS::Identities const & ) const;
            substitute_function_type substitute_function_value( &::SireMM::LJPerturbation::substitute );
            
            LJPerturbation_exposer.def( 
                "substitute"
                , substitute_function_value
                , ( bp::arg("identities") )
                , "Substitute the identities in identities in all of the mapping functions\nused by this perturbation. This is useful if, for example, you want to\nswitch from using lambda to control the perturbation to using alpha, e.g.\n" );
        
        }
        { //::SireMM::LJPerturbation::toString
        
            typedef ::QString ( ::SireMM::LJPerturbation::*toString_function_type)(  ) const;
            toString_function_type toString_function_value( &::SireMM::LJPerturbation::toString );
            
            LJPerturbation_exposer.def( 
                "toString"
                , toString_function_value
                , "Return a string representation of this perturbation" );
        
        }
        { //::SireMM::LJPerturbation::typeName
        
            typedef char const * ( *typeName_function_type )(  );
            typeName_function_type typeName_function_value( &::SireMM::LJPerturbation::typeName );
            
            LJPerturbation_exposer.def( 
                "typeName"
                , typeName_function_value
                , "" );
        
        }
        { //::SireMM::LJPerturbation::wouldChange
        
            typedef bool ( ::SireMM::LJPerturbation::*wouldChange_function_type)( ::SireMol::Molecule const &,::SireCAS::Values const & ) const;
            wouldChange_function_type wouldChange_function_value( &::SireMM::LJPerturbation::wouldChange );
            
            LJPerturbation_exposer.def( 
                "wouldChange"
                , wouldChange_function_value
                , ( bp::arg("molecule"), bp::arg("values") )
                , "Return whether or not this perturbation with the passed values would\nchange the molecule molecule" );
        
        }
        LJPerturbation_exposer.staticmethod( "typeName" );
        LJPerturbation_exposer.def( "__copy__", &__copy__);
        LJPerturbation_exposer.def( "__deepcopy__", &__copy__);
        LJPerturbation_exposer.def( "clone", &__copy__);
        LJPerturbation_exposer.def( "__rlshift__", &__rlshift__QDataStream< ::SireMM::LJPerturbation >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        LJPerturbation_exposer.def( "__rrshift__", &__rrshift__QDataStream< ::SireMM::LJPerturbation >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        LJPerturbation_exposer.def( "__str__", &__str__< ::SireMM::LJPerturbation > );
        LJPerturbation_exposer.def( "__repr__", &__str__< ::SireMM::LJPerturbation > );
    }

}
