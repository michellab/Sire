// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 2 License

#include "boost/python.hpp"
#include "TrigMatrix.pypp.hpp"

namespace bp = boost::python;

#include "SireBase/array2d.hpp"

#include "SireError/errors.h"

#include "SireStream/datastream.h"

#include "SireStream/shareddatastream.h"

#include "matrix.h"

#include "nmatrix.h"

#include "nvector.h"

#include "sire_blas.h"

#include "sire_lapack.h"

#include "trigmatrix.h"

#include "vector.h"

#include "trigmatrix.h"

SireMaths::TrigMatrix __copy__(const SireMaths::TrigMatrix &other){ return SireMaths::TrigMatrix(other); }

#include "Qt/qdatastream.hpp"

#include "Helpers/str.hpp"

#include "Helpers/release_gil_policy.hpp"

#include "Helpers/len.hpp"

void register_TrigMatrix_class(){

    { //::SireMaths::TrigMatrix
        typedef bp::class_< SireMaths::TrigMatrix > TrigMatrix_exposer_t;
        TrigMatrix_exposer_t TrigMatrix_exposer = TrigMatrix_exposer_t( "TrigMatrix", "This is a dense, double, general NN 2-dimensional\ntriangular matrix, with m[i,j] == m[j,i].\n\nOnly the upper diagonal half of the matrix is stored,\nin a packed format, which is not suitable for\nBLAS or LAPACK functions (a conversion to a NMatrix\nhas to be performed first)\n\nThe data is implicitly shared (copy on write), so\ncopying a matrix is very fast.\n0 1 2 3 4\nMatrix =  0  a b c d e \    m[i,j] == m[j,i]\n1 | b f g h i |\n2 | c g j k l |    dimension == n == 5\n3 | d h k m n |\n4 \ e i l n o\n\nThis is stored in memory as;\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\nv == [ a b c d e f g h i j k l m n o ]\n\na == 0  (15-15), f == 5 (15-10), j == 9 (15-6), m == 12 (15-3), o == 14 (15-1)\n\nso m[i,j] == v[ S(n) - S(n-i) + j - i ]   if i >= j or\nm[j,i]                       if j < i\n\nwhere S(k) == Sum_1^k (k) == (k^2 + k)2\n\nS(1) == 1, S(2) == 3, S(3) == 6, S(4) == 10, S(5) == 15\n\nm[0,1] == b   v[15 - 15 + 1 - 0 ] == v[1] == b\nm[3,2] == k   m[3,2] == m[2,3] == v[15 - 6 + 3 - 2] == v[10] == k\nm[4,4] == o   v[15 - 1 + 4 - 4 ] == v[14] == o\n\nSimplified expression is m[i,j] = v[12 (-i - i^2 + 2 j + 2 i n)]\n\nAuthor: Christopher Woods\n", bp::init< >("Null constructor") );
        bp::scope TrigMatrix_scope( TrigMatrix_exposer );
        TrigMatrix_exposer.def( bp::init< int >(( bp::arg("dimension") ), "Construct a matrix with dimension dimensiondimension\nThe values in the matrix are not initialised") );
        TrigMatrix_exposer.def( bp::init< int, double >(( bp::arg("dimension"), bp::arg("initial_value") ), "Construct a matrix with dimension dimensiondimension\nThe values in the matrix are initialised to initial_value") );
        TrigMatrix_exposer.def( bp::init< SireMaths::NMatrix const &, bp::optional< bool > >(( bp::arg("matrix"), bp::arg("take_upper")=(bool)(true) ), "Construct from the passed Matrix - if take_upper is true,\nthen the upper right diagonal is copied - otherwise the\nlower left diagonal is taken") );
        TrigMatrix_exposer.def( bp::init< SireMaths::TrigMatrix const & >(( bp::arg("other") ), "Copy constructor") );
        { //::SireMaths::TrigMatrix::assertNColumns
        
            typedef void ( ::SireMaths::TrigMatrix::*assertNColumns_function_type)( int ) const;
            assertNColumns_function_type assertNColumns_function_value( &::SireMaths::TrigMatrix::assertNColumns );
            
            TrigMatrix_exposer.def( 
                "assertNColumns"
                , assertNColumns_function_value
                , ( bp::arg("ncolumns") )
                , bp::release_gil_policy()
                , "Assert that this matrix has ncolumns columns\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireMaths::TrigMatrix::assertNRows
        
            typedef void ( ::SireMaths::TrigMatrix::*assertNRows_function_type)( int ) const;
            assertNRows_function_type assertNRows_function_value( &::SireMaths::TrigMatrix::assertNRows );
            
            TrigMatrix_exposer.def( 
                "assertNRows"
                , assertNRows_function_value
                , ( bp::arg("nrows") )
                , bp::release_gil_policy()
                , "Assert that this matrix has nrows rows\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireMaths::TrigMatrix::assertSquare
        
            typedef void ( ::SireMaths::TrigMatrix::*assertSquare_function_type)(  ) const;
            assertSquare_function_type assertSquare_function_value( &::SireMaths::TrigMatrix::assertSquare );
            
            TrigMatrix_exposer.def( 
                "assertSquare"
                , assertSquare_function_value
                , bp::release_gil_policy()
                , "Assert that this is a square matrix - it definitely is" );
        
        }
        { //::SireMaths::TrigMatrix::assertValidColumn
        
            typedef void ( ::SireMaths::TrigMatrix::*assertValidColumn_function_type)( int ) const;
            assertValidColumn_function_type assertValidColumn_function_value( &::SireMaths::TrigMatrix::assertValidColumn );
            
            TrigMatrix_exposer.def( 
                "assertValidColumn"
                , assertValidColumn_function_value
                , ( bp::arg("j") )
                , bp::release_gil_policy()
                , "Assert that there is an jth column\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMaths::TrigMatrix::assertValidIndex
        
            typedef void ( ::SireMaths::TrigMatrix::*assertValidIndex_function_type)( int,int ) const;
            assertValidIndex_function_type assertValidIndex_function_value( &::SireMaths::TrigMatrix::assertValidIndex );
            
            TrigMatrix_exposer.def( 
                "assertValidIndex"
                , assertValidIndex_function_value
                , ( bp::arg("i"), bp::arg("j") )
                , bp::release_gil_policy()
                , "Assert that the index [i,j] is valid for this matrix\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMaths::TrigMatrix::assertValidRow
        
            typedef void ( ::SireMaths::TrigMatrix::*assertValidRow_function_type)( int ) const;
            assertValidRow_function_type assertValidRow_function_value( &::SireMaths::TrigMatrix::assertValidRow );
            
            TrigMatrix_exposer.def( 
                "assertValidRow"
                , assertValidRow_function_value
                , ( bp::arg("i") )
                , bp::release_gil_policy()
                , "Assert that there is an ith row\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMaths::TrigMatrix::checkedOffset
        
            typedef int ( ::SireMaths::TrigMatrix::*checkedOffset_function_type)( int,int ) const;
            checkedOffset_function_type checkedOffset_function_value( &::SireMaths::TrigMatrix::checkedOffset );
            
            TrigMatrix_exposer.def( 
                "checkedOffset"
                , checkedOffset_function_value
                , ( bp::arg("i"), bp::arg("j") )
                , bp::release_gil_policy()
                , "Calculate the offset in the 1D array of the value\nat index [i,j]\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMaths::TrigMatrix::column
        
            typedef ::SireMaths::NVector ( ::SireMaths::TrigMatrix::*column_function_type)( int ) const;
            column_function_type column_function_value( &::SireMaths::TrigMatrix::column );
            
            TrigMatrix_exposer.def( 
                "column"
                , column_function_value
                , ( bp::arg("j") )
                , bp::release_gil_policy()
                , "Return a vector containing the contents of the jth column\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMaths::TrigMatrix::count
        
            typedef int ( ::SireMaths::TrigMatrix::*count_function_type)(  ) const;
            count_function_type count_function_value( &::SireMaths::TrigMatrix::count );
            
            TrigMatrix_exposer.def( 
                "count"
                , count_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireMaths::TrigMatrix::determinant
        
            typedef double ( ::SireMaths::TrigMatrix::*determinant_function_type)(  ) const;
            determinant_function_type determinant_function_value( &::SireMaths::TrigMatrix::determinant );
            
            TrigMatrix_exposer.def( 
                "determinant"
                , determinant_function_value
                , bp::release_gil_policy()
                , "Return the determinant of this matrix\nThis uses LAPACK under the hood, for speed\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireMaths::TrigMatrix::diagonal
        
            typedef ::SireMaths::NVector ( ::SireMaths::TrigMatrix::*diagonal_function_type)(  ) const;
            diagonal_function_type diagonal_function_value( &::SireMaths::TrigMatrix::diagonal );
            
            TrigMatrix_exposer.def( 
                "diagonal"
                , diagonal_function_value
                , bp::release_gil_policy()
                , "Return a vector containing the diagonal of this matrix - this is only\nvalid for a square matrix\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireMaths::TrigMatrix::diagonalise
        
            typedef ::std::pair< SireMaths::NVector, SireMaths::NMatrix > ( ::SireMaths::TrigMatrix::*diagonalise_function_type)(  ) const;
            diagonalise_function_type diagonalise_function_value( &::SireMaths::TrigMatrix::diagonalise );
            
            TrigMatrix_exposer.def( 
                "diagonalise"
                , diagonalise_function_value
                , bp::release_gil_policy()
                , "Return the eigenvalues and eigenvectors of this matrix. This\nuses LAPACK under the hood for speed\nThrow: SireError::incompatible_error\nThrow: SireMaths::domain_error\n" );
        
        }
        { //::SireMaths::TrigMatrix::fullTranspose
        
            typedef ::SireMaths::TrigMatrix ( ::SireMaths::TrigMatrix::*fullTranspose_function_type)(  ) const;
            fullTranspose_function_type fullTranspose_function_value( &::SireMaths::TrigMatrix::fullTranspose );
            
            TrigMatrix_exposer.def( 
                "fullTranspose"
                , fullTranspose_function_value
                , bp::release_gil_policy()
                , "Fully transpose the data of this matrix - again, this does nothing" );
        
        }
        { //::SireMaths::TrigMatrix::inverse
        
            typedef ::SireMaths::TrigMatrix ( ::SireMaths::TrigMatrix::*inverse_function_type)(  ) const;
            inverse_function_type inverse_function_value( &::SireMaths::TrigMatrix::inverse );
            
            TrigMatrix_exposer.def( 
                "inverse"
                , inverse_function_value
                , bp::release_gil_policy()
                , "Return the inverse of this matrix\nThis uses LAPACK under the hood, for speed\nThrow: SireError::incompatible_error\nThrow: SireMaths::domain_error\n" );
        
        }
        { //::SireMaths::TrigMatrix::isTransposed
        
            typedef bool ( ::SireMaths::TrigMatrix::*isTransposed_function_type)(  ) const;
            isTransposed_function_type isTransposed_function_value( &::SireMaths::TrigMatrix::isTransposed );
            
            TrigMatrix_exposer.def( 
                "isTransposed"
                , isTransposed_function_value
                , bp::release_gil_policy()
                , "Return whether or not this is a transposed matrix (data\nis stored in row-major order rather than column-major order)" );
        
        }
        { //::SireMaths::TrigMatrix::memory
        
            typedef ::QVector< double > ( ::SireMaths::TrigMatrix::*memory_function_type)(  ) const;
            memory_function_type memory_function_value( &::SireMaths::TrigMatrix::memory );
            
            TrigMatrix_exposer.def( 
                "memory"
                , memory_function_value
                , bp::release_gil_policy()
                , "Return the QVector containing the memory of this Matrix" );
        
        }
        { //::SireMaths::TrigMatrix::nColumns
        
            typedef int ( ::SireMaths::TrigMatrix::*nColumns_function_type)(  ) const;
            nColumns_function_type nColumns_function_value( &::SireMaths::TrigMatrix::nColumns );
            
            TrigMatrix_exposer.def( 
                "nColumns"
                , nColumns_function_value
                , bp::release_gil_policy()
                , "Return the number of columns in this matrix" );
        
        }
        { //::SireMaths::TrigMatrix::nRows
        
            typedef int ( ::SireMaths::TrigMatrix::*nRows_function_type)(  ) const;
            nRows_function_type nRows_function_value( &::SireMaths::TrigMatrix::nRows );
            
            TrigMatrix_exposer.def( 
                "nRows"
                , nRows_function_value
                , bp::release_gil_policy()
                , "Return the number of rows in this matrix" );
        
        }
        { //::SireMaths::TrigMatrix::offset
        
            typedef int ( ::SireMaths::TrigMatrix::*offset_function_type)( int,int ) const;
            offset_function_type offset_function_value( &::SireMaths::TrigMatrix::offset );
            
            TrigMatrix_exposer.def( 
                "offset"
                , offset_function_value
                , ( bp::arg("i"), bp::arg("j") )
                , bp::release_gil_policy()
                , "" );
        
        }
        TrigMatrix_exposer.def( bp::self != bp::self );
        { //::SireMaths::TrigMatrix::operator()
        
            typedef double const & ( ::SireMaths::TrigMatrix::*__call___function_type)( int,int ) const;
            __call___function_type __call___function_value( &::SireMaths::TrigMatrix::operator() );
            
            TrigMatrix_exposer.def( 
                "__call__"
                , __call___function_value
                , ( bp::arg("i"), bp::arg("j") )
                , bp::return_value_policy< bp::copy_const_reference >()
                , "" );
        
        }
        TrigMatrix_exposer.def( bp::self * bp::self );
        TrigMatrix_exposer.def( bp::self * bp::other< double >() );
        TrigMatrix_exposer.def( bp::self * bp::other< SireMaths::NVector >() );
        TrigMatrix_exposer.def( bp::self * bp::other< SireMaths::Vector >() );
        TrigMatrix_exposer.def( bp::self + bp::self );
        TrigMatrix_exposer.def( -bp::self );
        TrigMatrix_exposer.def( bp::self - bp::self );
        TrigMatrix_exposer.def( bp::self / bp::self );
        TrigMatrix_exposer.def( bp::self / bp::other< double >() );
        { //::SireMaths::TrigMatrix::operator=
        
            typedef ::SireMaths::TrigMatrix & ( ::SireMaths::TrigMatrix::*assign_function_type)( ::SireMaths::TrigMatrix const & ) ;
            assign_function_type assign_function_value( &::SireMaths::TrigMatrix::operator= );
            
            TrigMatrix_exposer.def( 
                "assign"
                , assign_function_value
                , ( bp::arg("other") )
                , bp::return_self< >()
                , "" );
        
        }
        TrigMatrix_exposer.def( bp::self == bp::self );
        { //::SireMaths::TrigMatrix::redimension
        
            typedef void ( ::SireMaths::TrigMatrix::*redimension_function_type)( int ) ;
            redimension_function_type redimension_function_value( &::SireMaths::TrigMatrix::redimension );
            
            TrigMatrix_exposer.def( 
                "redimension"
                , redimension_function_value
                , ( bp::arg("dimension") )
                , bp::release_gil_policy()
                , "Redimension this matrix to have dimension rows and dimension\ncolumns. The contents of this matrix are undefined after\nthis redimension. This function will only reallocate\nmemory if there is not enough memory allocated to store\nthe new matrix. Use this function if you want to use\nthe same piece of memory over and over again for lots\nof different size matricies - just create a matrix with\nthe maximum dimension, then call this redimension function\nwhenever you want to change. It is very fast, as it just\nupdates the internal record of the size of the matrix" );
        
        }
        { //::SireMaths::TrigMatrix::row
        
            typedef ::SireMaths::NVector ( ::SireMaths::TrigMatrix::*row_function_type)( int ) const;
            row_function_type row_function_value( &::SireMaths::TrigMatrix::row );
            
            TrigMatrix_exposer.def( 
                "row"
                , row_function_value
                , ( bp::arg("i") )
                , bp::release_gil_policy()
                , "Return a vector containing the contents of the ith row\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMaths::TrigMatrix::set
        
            typedef void ( ::SireMaths::TrigMatrix::*set_function_type)( int,int,double ) ;
            set_function_type set_function_value( &::SireMaths::TrigMatrix::set );
            
            TrigMatrix_exposer.def( 
                "set"
                , set_function_value
                , ( bp::arg("i"), bp::arg("j"), bp::arg("value") )
                , bp::release_gil_policy()
                , "Set the value of [i,j] (and [j,i]) to value\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMaths::TrigMatrix::setAll
        
            typedef void ( ::SireMaths::TrigMatrix::*setAll_function_type)( double ) ;
            setAll_function_type setAll_function_value( &::SireMaths::TrigMatrix::setAll );
            
            TrigMatrix_exposer.def( 
                "setAll"
                , setAll_function_value
                , ( bp::arg("value") )
                , bp::release_gil_policy()
                , "Set all entries in the matrix to the value value" );
        
        }
        { //::SireMaths::TrigMatrix::setColumn
        
            typedef void ( ::SireMaths::TrigMatrix::*setColumn_function_type)( int,double ) ;
            setColumn_function_type setColumn_function_value( &::SireMaths::TrigMatrix::setColumn );
            
            TrigMatrix_exposer.def( 
                "setColumn"
                , setColumn_function_value
                , ( bp::arg("j"), bp::arg("value") )
                , bp::release_gil_policy()
                , "Set the values of all data in the column j to value\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMaths::TrigMatrix::setColumn
        
            typedef void ( ::SireMaths::TrigMatrix::*setColumn_function_type)( int,::SireMaths::NVector const & ) ;
            setColumn_function_type setColumn_function_value( &::SireMaths::TrigMatrix::setColumn );
            
            TrigMatrix_exposer.def( 
                "setColumn"
                , setColumn_function_value
                , ( bp::arg("j"), bp::arg("column") )
                , bp::release_gil_policy()
                , "Copy the vector column to column j\nThrow: SireError::invalid_index\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireMaths::TrigMatrix::setRow
        
            typedef void ( ::SireMaths::TrigMatrix::*setRow_function_type)( int,double ) ;
            setRow_function_type setRow_function_value( &::SireMaths::TrigMatrix::setRow );
            
            TrigMatrix_exposer.def( 
                "setRow"
                , setRow_function_value
                , ( bp::arg("i"), bp::arg("value") )
                , bp::release_gil_policy()
                , "Set the values of all data in the row i to value\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireMaths::TrigMatrix::setRow
        
            typedef void ( ::SireMaths::TrigMatrix::*setRow_function_type)( int,::SireMaths::NVector const & ) ;
            setRow_function_type setRow_function_value( &::SireMaths::TrigMatrix::setRow );
            
            TrigMatrix_exposer.def( 
                "setRow"
                , setRow_function_value
                , ( bp::arg("i"), bp::arg("row") )
                , bp::release_gil_policy()
                , "Copy the vector row to row i\nThrow: SireError::invalid_index\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireMaths::TrigMatrix::size
        
            typedef int ( ::SireMaths::TrigMatrix::*size_function_type)(  ) const;
            size_function_type size_function_value( &::SireMaths::TrigMatrix::size );
            
            TrigMatrix_exposer.def( 
                "size"
                , size_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireMaths::TrigMatrix::toString
        
            typedef ::QString ( ::SireMaths::TrigMatrix::*toString_function_type)(  ) const;
            toString_function_type toString_function_value( &::SireMaths::TrigMatrix::toString );
            
            TrigMatrix_exposer.def( 
                "toString"
                , toString_function_value
                , bp::release_gil_policy()
                , "Return a string representation of this matrix" );
        
        }
        { //::SireMaths::TrigMatrix::trace
        
            typedef double ( ::SireMaths::TrigMatrix::*trace_function_type)(  ) const;
            trace_function_type trace_function_value( &::SireMaths::TrigMatrix::trace );
            
            TrigMatrix_exposer.def( 
                "trace"
                , trace_function_value
                , bp::release_gil_policy()
                , "Return the trace of this matrix - this is only valid for a square matrix\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireMaths::TrigMatrix::transpose
        
            typedef ::SireMaths::TrigMatrix ( ::SireMaths::TrigMatrix::*transpose_function_type)(  ) const;
            transpose_function_type transpose_function_value( &::SireMaths::TrigMatrix::transpose );
            
            TrigMatrix_exposer.def( 
                "transpose"
                , transpose_function_value
                , bp::release_gil_policy()
                , "Return the transpose of this matrix. This is fast, as it doesnt\nactually have to do anything" );
        
        }
        { //::SireMaths::TrigMatrix::typeName
        
            typedef char const * ( *typeName_function_type )(  );
            typeName_function_type typeName_function_value( &::SireMaths::TrigMatrix::typeName );
            
            TrigMatrix_exposer.def( 
                "typeName"
                , typeName_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireMaths::TrigMatrix::what
        
            typedef char const * ( ::SireMaths::TrigMatrix::*what_function_type)(  ) const;
            what_function_type what_function_value( &::SireMaths::TrigMatrix::what );
            
            TrigMatrix_exposer.def( 
                "what"
                , what_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        TrigMatrix_exposer.staticmethod( "typeName" );
        TrigMatrix_exposer.def( "__copy__", &__copy__);
        TrigMatrix_exposer.def( "__deepcopy__", &__copy__);
        TrigMatrix_exposer.def( "clone", &__copy__);
        TrigMatrix_exposer.def( "__rlshift__", &__rlshift__QDataStream< ::SireMaths::TrigMatrix >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        TrigMatrix_exposer.def( "__rrshift__", &__rrshift__QDataStream< ::SireMaths::TrigMatrix >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        TrigMatrix_exposer.def_pickle(sire_pickle_suite< ::SireMaths::TrigMatrix >());
        TrigMatrix_exposer.def( "__str__", &__str__< ::SireMaths::TrigMatrix > );
        TrigMatrix_exposer.def( "__repr__", &__str__< ::SireMaths::TrigMatrix > );
        TrigMatrix_exposer.def( "__len__", &__len_size< ::SireMaths::TrigMatrix > );
    }

}
