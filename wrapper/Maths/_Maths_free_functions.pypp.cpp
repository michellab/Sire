// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 2 License

#include "boost/python.hpp"
#include "_Maths_free_functions.pypp.hpp"

namespace bp = boost::python;

#include "gamma.h"

#include <cmath>

#include <gsl/gsl_sf_gamma.h>

#include "gamma.h"

#include "gamma.h"

#include <cmath>

#include <gsl/gsl_sf_gamma.h>

#include "gamma.h"

#include "SireError/errors.h"

#include "SireMaths/accumulator.h"

#include "SireMaths/align.h"

#include "SireStream/datastream.h"

#include "align.h"

#include "tostring.h"

#include <QElapsedTimer>

#include <gsl/gsl_blas.h>

#include <gsl/gsl_linalg.h>

#include <gsl/gsl_matrix.h>

#include <gsl/gsl_vector.h>

#include "align.h"

#include "SireError/errors.h"

#include "boys.h"

#include "gamma.h"

#include <QDebug>

#include <cmath>

#include "boys.h"

#include "SireError/errors.h"

#include "boys.h"

#include "gamma.h"

#include <QDebug>

#include <cmath>

#include "boys.h"

#include "SireError/errors.h"

#include "linearap.h"

#include "nmatrix.h"

#include "tostring.h"

#include <QDebug>

#include <limits>

#include "linearap.h"

#include "SireError/errors.h"

#include "linearap.h"

#include "nmatrix.h"

#include "tostring.h"

#include <QDebug>

#include <limits>

#include "linearap.h"

#include "gamma.h"

#include <cmath>

#include <gsl/gsl_sf_gamma.h>

#include "gamma.h"

#include "gamma.h"

#include <cmath>

#include <gsl/gsl_sf_gamma.h>

#include "gamma.h"

#include "SireError/errors.h"

#include "SireMaths/accumulator.h"

#include "SireMaths/align.h"

#include "SireStream/datastream.h"

#include "align.h"

#include "tostring.h"

#include <QElapsedTimer>

#include <gsl/gsl_blas.h>

#include <gsl/gsl_linalg.h>

#include <gsl/gsl_matrix.h>

#include <gsl/gsl_vector.h>

#include "align.h"

#include "SireError/errors.h"

#include "SireMaths/accumulator.h"

#include "SireMaths/align.h"

#include "SireStream/datastream.h"

#include "align.h"

#include "tostring.h"

#include <QElapsedTimer>

#include <gsl/gsl_blas.h>

#include <gsl/gsl_linalg.h>

#include <gsl/gsl_matrix.h>

#include <gsl/gsl_vector.h>

#include "align.h"

#include "SireError/errors.h"

#include "SireMaths/accumulator.h"

#include "SireMaths/align.h"

#include "SireStream/datastream.h"

#include "align.h"

#include "tostring.h"

#include <QElapsedTimer>

#include <gsl/gsl_blas.h>

#include <gsl/gsl_linalg.h>

#include <gsl/gsl_matrix.h>

#include <gsl/gsl_vector.h>

#include "align.h"

#include "SireError/errors.h"

#include "linearap.h"

#include "nmatrix.h"

#include "tostring.h"

#include <QDebug>

#include <limits>

#include "linearap.h"

#include "gamma.h"

#include <cmath>

#include <gsl/gsl_sf_gamma.h>

#include "gamma.h"

#include "gamma.h"

#include <cmath>

#include <gsl/gsl_sf_gamma.h>

#include "gamma.h"

#include "SireError/errors.h"

#include "SireMaths/accumulator.h"

#include "SireMaths/align.h"

#include "SireStream/datastream.h"

#include "align.h"

#include "tostring.h"

#include <QElapsedTimer>

#include <gsl/gsl_blas.h>

#include <gsl/gsl_linalg.h>

#include <gsl/gsl_matrix.h>

#include <gsl/gsl_vector.h>

#include "align.h"

#include "SireError/errors.h"

#include "SireMaths/accumulator.h"

#include "SireMaths/align.h"

#include "SireStream/datastream.h"

#include "align.h"

#include "tostring.h"

#include <QElapsedTimer>

#include <gsl/gsl_blas.h>

#include <gsl/gsl_linalg.h>

#include <gsl/gsl_matrix.h>

#include <gsl/gsl_vector.h>

#include "align.h"

#include "SireError/errors.h"

#include "boys.h"

#include "gamma.h"

#include <QDebug>

#include <cmath>

#include "boys.h"

#include "SireError/errors.h"

#include "boys.h"

#include "gamma.h"

#include <QDebug>

#include <cmath>

#include "boys.h"

#include "rotate.h"

#include "rotate.h"

#include "SireError/errors.h"

#include "linearap.h"

#include "nmatrix.h"

#include "tostring.h"

#include <QDebug>

#include <limits>

#include "linearap.h"

#include "SireMaths/vectorproperty.h"

#include "SireStream/datastream.h"

#include "SireStream/shareddatastream.h"

#include "vectorproperty.h"

#include "vectorproperty.h"

#include "SireMaths/vectorproperty.h"

#include "SireStream/datastream.h"

#include "SireStream/shareddatastream.h"

#include "vectorproperty.h"

#include "vectorproperty.h"

#include "SireMaths/vectorproperty.h"

#include "SireStream/datastream.h"

#include "SireStream/shareddatastream.h"

#include "vectorproperty.h"

#include "vectorproperty.h"

void register_free_functions(){

    { //::SireMaths::Gamma
    
        typedef double ( *Gamma_function_type )( double,double );
        Gamma_function_type Gamma_function_value( &::SireMaths::Gamma );
        
        bp::def( 
            "Gamma"
            , Gamma_function_value
            , ( bp::arg("alpha"), bp::arg("x") ) );
    
    }

    { //::SireMaths::Gamma
    
        typedef double ( *Gamma_function_type )( double );
        Gamma_function_type Gamma_function_value( &::SireMaths::Gamma );
        
        bp::def( 
            "Gamma"
            , Gamma_function_value
            , ( bp::arg("alpha") ) );
    
    }

    { //::SireMaths::align
    
        typedef ::QVector< SireMaths::Vector > ( *align_function_type )( ::QVector< SireMaths::Vector > const &,::QVector< SireMaths::Vector > const &,bool );
        align_function_type align_function_value( &::SireMaths::align );
        
        bp::def( 
            "align"
            , align_function_value
            , ( bp::arg("p"), bp::arg("q"), bp::arg("fit")=(bool)(true) ) );
    
    }

    { //::SireMaths::boys
    
        typedef double ( *boys_function_type )( int,double );
        boys_function_type boys_function_value( &::SireMaths::boys );
        
        bp::def( 
            "boys"
            , boys_function_value
            , ( bp::arg("m"), bp::arg("x") ) );
    
    }

    { //::SireMaths::boys
    
        typedef double ( *boys_function_type )( double,double );
        boys_function_type boys_function_value( &::SireMaths::boys );
        
        bp::def( 
            "boys"
            , boys_function_value
            , ( bp::arg("m"), bp::arg("x") ) );
    
    }

    { //::SireMaths::brute_force_linear_assignment
    
        typedef ::QVector< int > ( *brute_force_linear_assignment_function_type )( ::SireMaths::NMatrix const & );
        brute_force_linear_assignment_function_type brute_force_linear_assignment_function_value( &::SireMaths::brute_force_linear_assignment );
        
        bp::def( 
            "brute_force_linear_assignment"
            , brute_force_linear_assignment_function_value
            , ( bp::arg("costs") ) );
    
    }

    { //::SireMaths::calculate_total_cost
    
        typedef double ( *calculate_total_cost_function_type )( ::SireMaths::NMatrix const &,::QVector< int > const & );
        calculate_total_cost_function_type calculate_total_cost_function_value( &::SireMaths::calculate_total_cost );
        
        bp::def( 
            "calculate_total_cost"
            , calculate_total_cost_function_value
            , ( bp::arg("costs"), bp::arg("rows_to_columns") ) );
    
    }

    { //::SireMaths::gamma
    
        typedef double ( *gamma_function_type )( double,double );
        gamma_function_type gamma_function_value( &::SireMaths::gamma );
        
        bp::def( 
            "gamma"
            , gamma_function_value
            , ( bp::arg("alpha"), bp::arg("x") ) );
    
    }

    { //::SireMaths::gamma
    
        typedef double ( *gamma_function_type )( double );
        gamma_function_type gamma_function_value( &::SireMaths::gamma );
        
        bp::def( 
            "gamma"
            , gamma_function_value
            , ( bp::arg("alpha") ) );
    
    }

    { //::SireMaths::getAlignment
    
        typedef ::SireMaths::Transform ( *getAlignment_function_type )( ::QVector< SireMaths::Vector > const &,::QVector< SireMaths::Vector > const &,bool );
        getAlignment_function_type getAlignment_function_value( &::SireMaths::getAlignment );
        
        bp::def( 
            "getAlignment"
            , getAlignment_function_value
            , ( bp::arg("p"), bp::arg("q"), bp::arg("fit")=(bool)(true) ) );
    
    }

    { //::SireMaths::getCentroid
    
        typedef ::SireMaths::Vector ( *getCentroid_function_type )( ::QVector< SireMaths::Vector > const &,int );
        getCentroid_function_type getCentroid_function_value( &::SireMaths::getCentroid );
        
        bp::def( 
            "getCentroid"
            , getCentroid_function_value
            , ( bp::arg("p"), bp::arg("n")=(int)(-0x00000000000000001) ) );
    
    }

    { //::SireMaths::getRMSD
    
        typedef double ( *getRMSD_function_type )( ::QVector< SireMaths::Vector > const &,::QVector< SireMaths::Vector > const &,int );
        getRMSD_function_type getRMSD_function_value( &::SireMaths::getRMSD );
        
        bp::def( 
            "getRMSD"
            , getRMSD_function_value
            , ( bp::arg("p"), bp::arg("q"), bp::arg("n")=(int)(-0x00000000000000001) ) );
    
    }

    { //::SireMaths::get_lowest_total_cost
    
        typedef double ( *get_lowest_total_cost_function_type )( ::SireMaths::NMatrix const & );
        get_lowest_total_cost_function_type get_lowest_total_cost_function_value( &::SireMaths::get_lowest_total_cost );
        
        bp::def( 
            "get_lowest_total_cost"
            , get_lowest_total_cost_function_value
            , ( bp::arg("costs") ) );
    
    }

    { //::SireMaths::incomplete_gamma_higher
    
        typedef double ( *incomplete_gamma_higher_function_type )( double,double );
        incomplete_gamma_higher_function_type incomplete_gamma_higher_function_value( &::SireMaths::incomplete_gamma_higher );
        
        bp::def( 
            "incomplete_gamma_higher"
            , incomplete_gamma_higher_function_value
            , ( bp::arg("alpha"), bp::arg("x") ) );
    
    }

    { //::SireMaths::incomplete_gamma_lower
    
        typedef double ( *incomplete_gamma_lower_function_type )( double,double );
        incomplete_gamma_lower_function_type incomplete_gamma_lower_function_value( &::SireMaths::incomplete_gamma_lower );
        
        bp::def( 
            "incomplete_gamma_lower"
            , incomplete_gamma_lower_function_value
            , ( bp::arg("alpha"), bp::arg("x") ) );
    
    }

    { //::SireMaths::kabasch
    
        typedef ::SireMaths::Matrix ( *kabasch_function_type )( ::QVector< SireMaths::Vector > const &,::QVector< SireMaths::Vector > const & );
        kabasch_function_type kabasch_function_value( &::SireMaths::kabasch );
        
        bp::def( 
            "kabasch"
            , kabasch_function_value
            , ( bp::arg("p"), bp::arg("q") ) );
    
    }

    { //::SireMaths::kabaschFit
    
        typedef ::SireMaths::Transform ( *kabaschFit_function_type )( ::QVector< SireMaths::Vector > const &,::QVector< SireMaths::Vector > const & );
        kabaschFit_function_type kabaschFit_function_value( &::SireMaths::kabaschFit );
        
        bp::def( 
            "kabaschFit"
            , kabaschFit_function_value
            , ( bp::arg("p"), bp::arg("q") ) );
    
    }

    { //::SireMaths::multi_boys
    
        typedef ::QVector< double > ( *multi_boys_function_type )( double,int,int );
        multi_boys_function_type multi_boys_function_value( &::SireMaths::multi_boys );
        
        bp::def( 
            "multi_boys"
            , multi_boys_function_value
            , ( bp::arg("x"), bp::arg("n"), bp::arg("start") ) );
    
    }

    { //::SireMaths::multi_boys
    
        typedef ::QVector< double > ( *multi_boys_function_type )( double,int );
        multi_boys_function_type multi_boys_function_value( &::SireMaths::multi_boys );
        
        bp::def( 
            "multi_boys"
            , multi_boys_function_value
            , ( bp::arg("x"), bp::arg("n") ) );
    
    }

    { //::SireMaths::rotate
    
        typedef ::SireMaths::Vector ( *rotate_function_type )( ::SireMaths::Vector const &,::SireMaths::Matrix const &,::SireMaths::Vector const & );
        rotate_function_type rotate_function_value( &::SireMaths::rotate );
        
        bp::def( 
            "rotate"
            , rotate_function_value
            , ( bp::arg("input"), bp::arg("rotmat"), bp::arg("point") ) );
    
    }

    { //::SireMaths::solve_linear_assignment
    
        typedef ::QVector< int > ( *solve_linear_assignment_function_type )( ::SireMaths::NMatrix const &,bool );
        solve_linear_assignment_function_type solve_linear_assignment_function_value( &::SireMaths::solve_linear_assignment );
        
        bp::def( 
            "solve_linear_assignment"
            , solve_linear_assignment_function_value
            , ( bp::arg("costs"), bp::arg("check_result")=(bool)(false) ) );
    
    }

    { //::SireMaths::wrap
    
        typedef ::SireBase::PropertyPtr ( *wrap_function_type )( ::QList< SireMaths::Vector > const & );
        wrap_function_type wrap_function_value( &::SireMaths::wrap );
        
        bp::def( 
            "wrap"
            , wrap_function_value
            , ( bp::arg("vector") ) );
    
    }

    { //::SireMaths::wrap
    
        typedef ::SireBase::PropertyPtr ( *wrap_function_type )( ::QVector< SireMaths::Vector > const & );
        wrap_function_type wrap_function_value( &::SireMaths::wrap );
        
        bp::def( 
            "wrap"
            , wrap_function_value
            , ( bp::arg("vector") ) );
    
    }

    { //::SireMaths::wrap
    
        typedef ::SireBase::PropertyPtr ( *wrap_function_type )( ::SireMaths::Vector const & );
        wrap_function_type wrap_function_value( &::SireMaths::wrap );
        
        bp::def( 
            "wrap"
            , wrap_function_value
            , ( bp::arg("vector") ) );
    
    }

}
