// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 2 License

#include "boost/python.hpp"
#include "MultiFixed.pypp.hpp"

namespace bp = boost::python;

#include "SireError/errors.h"

#include "SireMaths/multifixed.h"

#include "multifixed.h"

#include <QDebug>

#include "multifixed.h"

#include "multifloat.h"

#include "multiint.h"

SireMaths::MultiFixed __copy__(const SireMaths::MultiFixed &other){ return SireMaths::MultiFixed(other); }

#include "Helpers/str.hpp"

#include "Helpers/len.hpp"

void register_MultiFixed_class(){

    { //::SireMaths::MultiFixed
        typedef bp::class_< SireMaths::MultiFixed > MultiFixed_exposer_t;
        MultiFixed_exposer_t MultiFixed_exposer = MultiFixed_exposer_t( "MultiFixed", "This class provides a vector of fixed point numbers which\nis built to complement MultiFloat. The number of fixed point\nnumbers in the vector is equal to the number of floats in MultiFloat.\n\nNote that this is a 64bit balanced fixed point representation,\ni.e. 32bits of precision are available both before and after\nthe decimal point (so about 9 significant figures on both sides,\nnote that the minus sign takes one of the bits before the decimal point).\n\nNote also that there are no functions that let you retrieve\nindividual fixed point numbers from this vector. Fixed point\nnumbers will automatically be converted tofrom doubles when\nreturned to the user.\n\nAuthor: Christopher Woods\n", bp::init< >("Constructor - all of the elements are set to zero") );
        bp::scope MultiFixed_scope( MultiFixed_exposer );
        MultiFixed_exposer.def( bp::init< double >(( bp::arg("value") ), "Construct such that all elements are equal to value") );
        MultiFixed_exposer.def( bp::init< double const *, int >(( bp::arg("array"), bp::arg("size") ), "Construct from the passed array. If size is greater than MultiFixed::size()\nthen an error will be raised. If size is less than MultiFixed::size() then\nthis vector will be padded with zeroes") );
        MultiFixed_exposer.def( bp::init< QVector< double > const & >(( bp::arg("array") ), "Construct from the passed array. If size is greater than MultiFixed::size()\nthen an error will be raised. If size is less than MultiFixed::size() then\nthis vector will be padded with zeroes") );
        MultiFixed_exposer.def( bp::init< SireMaths::MultiFloat const & >(( bp::arg("value") ), "Construct from the passed MultiFloat") );
        MultiFixed_exposer.def( bp::init< SireMaths::MultiFixed const & >(( bp::arg("other") ), "Copy constructor") );
        { //::SireMaths::MultiFixed::compareEqual
        
            typedef ::SireMaths::MultiFixed ( ::SireMaths::MultiFixed::*compareEqual_function_type)( ::SireMaths::MultiFixed const & ) const;
            compareEqual_function_type compareEqual_function_value( &::SireMaths::MultiFixed::compareEqual );
            
            MultiFixed_exposer.def( 
                "compareEqual"
                , compareEqual_function_value
                , ( bp::arg("other") )
                , "Compare each element of the two vectors. Return 0x00000000000000000 if\nthe element is not equal, 0x1111111111111111 if they are" );
        
        }
        { //::SireMaths::MultiFixed::compareGreater
        
            typedef ::SireMaths::MultiFixed ( ::SireMaths::MultiFixed::*compareGreater_function_type)( ::SireMaths::MultiFixed const & ) const;
            compareGreater_function_type compareGreater_function_value( &::SireMaths::MultiFixed::compareGreater );
            
            MultiFixed_exposer.def( 
                "compareGreater"
                , compareGreater_function_value
                , ( bp::arg("other") )
                , "Compare each element for greater" );
        
        }
        { //::SireMaths::MultiFixed::compareGreaterEqual
        
            typedef ::SireMaths::MultiFixed ( ::SireMaths::MultiFixed::*compareGreaterEqual_function_type)( ::SireMaths::MultiFixed const & ) const;
            compareGreaterEqual_function_type compareGreaterEqual_function_value( &::SireMaths::MultiFixed::compareGreaterEqual );
            
            MultiFixed_exposer.def( 
                "compareGreaterEqual"
                , compareGreaterEqual_function_value
                , ( bp::arg("other") )
                , "Compare each element for greater or equal" );
        
        }
        { //::SireMaths::MultiFixed::compareLess
        
            typedef ::SireMaths::MultiFixed ( ::SireMaths::MultiFixed::*compareLess_function_type)( ::SireMaths::MultiFixed const & ) const;
            compareLess_function_type compareLess_function_value( &::SireMaths::MultiFixed::compareLess );
            
            MultiFixed_exposer.def( 
                "compareLess"
                , compareLess_function_value
                , ( bp::arg("other") )
                , "Compare each element for less" );
        
        }
        { //::SireMaths::MultiFixed::compareLessEqual
        
            typedef ::SireMaths::MultiFixed ( ::SireMaths::MultiFixed::*compareLessEqual_function_type)( ::SireMaths::MultiFixed const & ) const;
            compareLessEqual_function_type compareLessEqual_function_value( &::SireMaths::MultiFixed::compareLessEqual );
            
            MultiFixed_exposer.def( 
                "compareLessEqual"
                , compareLessEqual_function_value
                , ( bp::arg("other") )
                , "Compare each element for less or equal" );
        
        }
        { //::SireMaths::MultiFixed::compareNotEqual
        
            typedef ::SireMaths::MultiFixed ( ::SireMaths::MultiFixed::*compareNotEqual_function_type)( ::SireMaths::MultiFixed const & ) const;
            compareNotEqual_function_type compareNotEqual_function_value( &::SireMaths::MultiFixed::compareNotEqual );
            
            MultiFixed_exposer.def( 
                "compareNotEqual"
                , compareNotEqual_function_value
                , ( bp::arg("other") )
                , "Compare each element for inequality" );
        
        }
        { //::SireMaths::MultiFixed::count
        
            typedef int ( *count_function_type )(  );
            count_function_type count_function_value( &::SireMaths::MultiFixed::count );
            
            MultiFixed_exposer.def( 
                "count"
                , count_function_value
                , "Return the number of elements in the vector" );
        
        }
        { //::SireMaths::MultiFixed::fromArray
        
            typedef ::QVector< SireMaths::MultiFixed > ( *fromArray_function_type )( ::QVector< double > const & );
            fromArray_function_type fromArray_function_value( &::SireMaths::MultiFixed::fromArray );
            
            MultiFixed_exposer.def( 
                "fromArray"
                , fromArray_function_value
                , ( bp::arg("array") )
                , "Convert the passed array of doubles to an array of MultiFixed values.\nNote that the array may be returned padded with zeroes" );
        
        }
        { //::SireMaths::MultiFixed::get
        
            typedef double ( ::SireMaths::MultiFixed::*get_function_type)( int ) const;
            get_function_type get_function_value( &::SireMaths::MultiFixed::get );
            
            MultiFixed_exposer.def( 
                "get"
                , get_function_value
                , ( bp::arg("i") )
                , "Return the value of the ith element of the vector" );
        
        }
        { //::SireMaths::MultiFixed::logicalAnd
        
            typedef ::SireMaths::MultiFixed ( ::SireMaths::MultiFixed::*logicalAnd_function_type)( ::SireMaths::MultiFixed const & ) const;
            logicalAnd_function_type logicalAnd_function_value( &::SireMaths::MultiFixed::logicalAnd );
            
            MultiFixed_exposer.def( 
                "logicalAnd"
                , logicalAnd_function_value
                , ( bp::arg("other") )
                , "Logical bitwise and operator" );
        
        }
        { //::SireMaths::MultiFixed::logicalAndNot
        
            typedef ::SireMaths::MultiFixed ( ::SireMaths::MultiFixed::*logicalAndNot_function_type)( ::SireMaths::MultiFixed const & ) const;
            logicalAndNot_function_type logicalAndNot_function_value( &::SireMaths::MultiFixed::logicalAndNot );
            
            MultiFixed_exposer.def( 
                "logicalAndNot"
                , logicalAndNot_function_value
                , ( bp::arg("other") )
                , "Logical bitwise and not" );
        
        }
        { //::SireMaths::MultiFixed::logicalNot
        
            typedef ::SireMaths::MultiFixed ( ::SireMaths::MultiFixed::*logicalNot_function_type)(  ) const;
            logicalNot_function_type logicalNot_function_value( &::SireMaths::MultiFixed::logicalNot );
            
            MultiFixed_exposer.def( 
                "logicalNot"
                , logicalNot_function_value
                , "Logical bitwise not operator" );
        
        }
        { //::SireMaths::MultiFixed::logicalOr
        
            typedef ::SireMaths::MultiFixed ( ::SireMaths::MultiFixed::*logicalOr_function_type)( ::SireMaths::MultiFixed const & ) const;
            logicalOr_function_type logicalOr_function_value( &::SireMaths::MultiFixed::logicalOr );
            
            MultiFixed_exposer.def( 
                "logicalOr"
                , logicalOr_function_value
                , ( bp::arg("other") )
                , "Logical bitwise or" );
        
        }
        { //::SireMaths::MultiFixed::logicalXor
        
            typedef ::SireMaths::MultiFixed ( ::SireMaths::MultiFixed::*logicalXor_function_type)( ::SireMaths::MultiFixed const & ) const;
            logicalXor_function_type logicalXor_function_value( &::SireMaths::MultiFixed::logicalXor );
            
            MultiFixed_exposer.def( 
                "logicalXor"
                , logicalXor_function_value
                , ( bp::arg("other") )
                , "Logical bitwise xor" );
        
        }
        { //::SireMaths::MultiFixed::max
        
            typedef ::SireMaths::MultiFixed ( ::SireMaths::MultiFixed::*max_function_type)( ::SireMaths::MultiFixed const & ) const;
            max_function_type max_function_value( &::SireMaths::MultiFixed::max );
            
            MultiFixed_exposer.def( 
                "max"
                , max_function_value
                , ( bp::arg("other") )
                , "Return the max of this vector with other" );
        
        }
        { //::SireMaths::MultiFixed::min
        
            typedef ::SireMaths::MultiFixed ( ::SireMaths::MultiFixed::*min_function_type)( ::SireMaths::MultiFixed const & ) const;
            min_function_type min_function_value( &::SireMaths::MultiFixed::min );
            
            MultiFixed_exposer.def( 
                "min"
                , min_function_value
                , ( bp::arg("other") )
                , "Return the min of this vector with other" );
        
        }
        { //::SireMaths::MultiFixed::multiplyAdd
        
            typedef ::SireMaths::MultiFixed & ( ::SireMaths::MultiFixed::*multiplyAdd_function_type)( ::SireMaths::MultiFixed const &,::SireMaths::MultiFixed const & ) ;
            multiplyAdd_function_type multiplyAdd_function_value( &::SireMaths::MultiFixed::multiplyAdd );
            
            MultiFixed_exposer.def( 
                "multiplyAdd"
                , multiplyAdd_function_value
                , ( bp::arg("val0"), bp::arg("val1") )
                , bp::return_self< >()
                , "Multiply val0 and val1 and add it onto this vector" );
        
        }
        MultiFixed_exposer.def( !bp::self );
        MultiFixed_exposer.def( bp::self != bp::self );
        MultiFixed_exposer.def( bp::self & bp::self );
        MultiFixed_exposer.def( bp::self * bp::self );
        MultiFixed_exposer.def( bp::self + bp::self );
        MultiFixed_exposer.def( -bp::self );
        MultiFixed_exposer.def( bp::self - bp::self );
        MultiFixed_exposer.def( bp::self / bp::self );
        MultiFixed_exposer.def( bp::self < bp::self );
        MultiFixed_exposer.def( bp::self <= bp::self );
        { //::SireMaths::MultiFixed::operator=
        
            typedef ::SireMaths::MultiFixed & ( ::SireMaths::MultiFixed::*assign_function_type)( ::SireMaths::MultiFixed const & ) ;
            assign_function_type assign_function_value( &::SireMaths::MultiFixed::operator= );
            
            MultiFixed_exposer.def( 
                "assign"
                , assign_function_value
                , ( bp::arg("other") )
                , bp::return_self< >()
                , "" );
        
        }
        MultiFixed_exposer.def( bp::self == bp::self );
        MultiFixed_exposer.def( bp::self > bp::self );
        MultiFixed_exposer.def( bp::self >= bp::self );
        { //::SireMaths::MultiFixed::operator[]
        
            typedef double ( ::SireMaths::MultiFixed::*__getitem___function_type)( int ) const;
            __getitem___function_type __getitem___function_value( &::SireMaths::MultiFixed::operator[] );
            
            MultiFixed_exposer.def( 
                "__getitem__"
                , __getitem___function_value
                , ( bp::arg("i") )
                , "" );
        
        }
        MultiFixed_exposer.def( bp::self ^ bp::self );
        MultiFixed_exposer.def( bp::self | bp::self );
        { //::SireMaths::MultiFixed::reciprocal
        
            typedef ::SireMaths::MultiFixed ( ::SireMaths::MultiFixed::*reciprocal_function_type)(  ) const;
            reciprocal_function_type reciprocal_function_value( &::SireMaths::MultiFixed::reciprocal );
            
            MultiFixed_exposer.def( 
                "reciprocal"
                , reciprocal_function_value
                , "Return the reciprocal of this number" );
        
        }
        { //::SireMaths::MultiFixed::rotate
        
            typedef ::SireMaths::MultiFixed ( ::SireMaths::MultiFixed::*rotate_function_type)(  ) const;
            rotate_function_type rotate_function_value( &::SireMaths::MultiFixed::rotate );
            
            MultiFixed_exposer.def( 
                "rotate"
                , rotate_function_value
                , "Rotate this vector in the same direction as MultiFloat::rotate()" );
        
        }
        { //::SireMaths::MultiFixed::rsqrt
        
            typedef ::SireMaths::MultiFixed ( ::SireMaths::MultiFixed::*rsqrt_function_type)(  ) const;
            rsqrt_function_type rsqrt_function_value( &::SireMaths::MultiFixed::rsqrt );
            
            MultiFixed_exposer.def( 
                "rsqrt"
                , rsqrt_function_value
                , "Return the reciprocal square root of this number" );
        
        }
        { //::SireMaths::MultiFixed::set
        
            typedef void ( ::SireMaths::MultiFixed::*set_function_type)( int,double ) ;
            set_function_type set_function_value( &::SireMaths::MultiFixed::set );
            
            MultiFixed_exposer.def( 
                "set"
                , set_function_value
                , ( bp::arg("i"), bp::arg("value") )
                , "Set the ith element of this vector to value" );
        
        }
        { //::SireMaths::MultiFixed::size
        
            typedef int ( *size_function_type )(  );
            size_function_type size_function_value( &::SireMaths::MultiFixed::size );
            
            MultiFixed_exposer.def( 
                "size"
                , size_function_value
                , "Return the number of elements in the vector" );
        
        }
        { //::SireMaths::MultiFixed::sqrt
        
            typedef ::SireMaths::MultiFixed ( ::SireMaths::MultiFixed::*sqrt_function_type)(  ) const;
            sqrt_function_type sqrt_function_value( &::SireMaths::MultiFixed::sqrt );
            
            MultiFixed_exposer.def( 
                "sqrt"
                , sqrt_function_value
                , "Return the square root of this number" );
        
        }
        { //::SireMaths::MultiFixed::sum
        
            typedef double ( ::SireMaths::MultiFixed::*sum_function_type)(  ) const;
            sum_function_type sum_function_value( &::SireMaths::MultiFixed::sum );
            
            MultiFixed_exposer.def( 
                "sum"
                , sum_function_value
                , "Return the sum of all of the elements of this vector" );
        
        }
        { //::SireMaths::MultiFixed::toArray
        
            typedef ::QVector< double > ( *toArray_function_type )( ::QVector< SireMaths::MultiFixed > const & );
            toArray_function_type toArray_function_value( &::SireMaths::MultiFixed::toArray );
            
            MultiFixed_exposer.def( 
                "toArray"
                , toArray_function_value
                , ( bp::arg("array") )
                , "Return convert the passed MultiFixed array back into an array of doubles" );
        
        }
        { //::SireMaths::MultiFixed::toBinaryString
        
            typedef ::QString ( ::SireMaths::MultiFixed::*toBinaryString_function_type)(  ) const;
            toBinaryString_function_type toBinaryString_function_value( &::SireMaths::MultiFixed::toBinaryString );
            
            MultiFixed_exposer.def( 
                "toBinaryString"
                , toBinaryString_function_value
                , "" );
        
        }
        { //::SireMaths::MultiFixed::toString
        
            typedef ::QString ( ::SireMaths::MultiFixed::*toString_function_type)(  ) const;
            toString_function_type toString_function_value( &::SireMaths::MultiFixed::toString );
            
            MultiFixed_exposer.def( 
                "toString"
                , toString_function_value
                , "" );
        
        }
        { //::SireMaths::MultiFixed::typeName
        
            typedef char const * ( *typeName_function_type )(  );
            typeName_function_type typeName_function_value( &::SireMaths::MultiFixed::typeName );
            
            MultiFixed_exposer.def( 
                "typeName"
                , typeName_function_value
                , "" );
        
        }
        { //::SireMaths::MultiFixed::what
        
            typedef char const * ( ::SireMaths::MultiFixed::*what_function_type)(  ) const;
            what_function_type what_function_value( &::SireMaths::MultiFixed::what );
            
            MultiFixed_exposer.def( 
                "what"
                , what_function_value
                , "" );
        
        }
        MultiFixed_exposer.staticmethod( "count" );
        MultiFixed_exposer.staticmethod( "fromArray" );
        MultiFixed_exposer.staticmethod( "size" );
        MultiFixed_exposer.staticmethod( "toArray" );
        MultiFixed_exposer.staticmethod( "typeName" );
        MultiFixed_exposer.def( "__copy__", &__copy__);
        MultiFixed_exposer.def( "__deepcopy__", &__copy__);
        MultiFixed_exposer.def( "clone", &__copy__);
        MultiFixed_exposer.def( "__str__", &__str__< ::SireMaths::MultiFixed > );
        MultiFixed_exposer.def( "__repr__", &__str__< ::SireMaths::MultiFixed > );
        MultiFixed_exposer.def( "__len__", &__len_size< ::SireMaths::MultiFixed > );
    }

}
