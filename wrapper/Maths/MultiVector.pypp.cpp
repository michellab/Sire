// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 2 License

#include "boost/python.hpp"
#include "MultiVector.pypp.hpp"

namespace bp = boost::python;

#include "SireError/errors.h"

#include "SireID/index.h"

#include "multivector.h"

#include <QDebug>

#include "multivector.h"

#include "multifloat.h"

#include "multiint.h"

#include "multidouble.h"

#include "multivector.h"

#include "multiquaternion.h"

SireMaths::MultiVector __copy__(const SireMaths::MultiVector &other){ return SireMaths::MultiVector(other); }

#include "Helpers/str.hpp"

#include "Helpers/release_gil_policy.hpp"

#include "Helpers/len.hpp"

void register_MultiVector_class(){

    { //::SireMaths::MultiVector
        typedef bp::class_< SireMaths::MultiVector > MultiVector_exposer_t;
        MultiVector_exposer_t MultiVector_exposer = MultiVector_exposer_t( "MultiVector", "\nThis is a vectorised version of Vector, e.g. x, y, and z\nare held as MultiDouble objects, meaning that this is a\npacked vector of vectors\n\nAuthor: Christopher Woods\n", bp::init< >("") );
        bp::scope MultiVector_scope( MultiVector_exposer );
        MultiVector_exposer.def( bp::init< SireMaths::MultiDouble const & >(( bp::arg("value") ), "Copy constructor") );
        MultiVector_exposer.def( bp::init< SireMaths::MultiDouble const &, SireMaths::MultiDouble const &, SireMaths::MultiDouble const & >(( bp::arg("x"), bp::arg("y"), bp::arg("z") ), "") );
        MultiVector_exposer.def( bp::init< SireMaths::Vector const *, int >(( bp::arg("array"), bp::arg("size") ), "Construct from an array of Vectors. This array cannot be greater\nthan MultiDouble::size()") );
        MultiVector_exposer.def( bp::init< QVector< SireMaths::Vector > const & >(( bp::arg("array") ), "Construct from an array of Vectors. This array cannot be greater\nthan MultiDouble::size()") );
        MultiVector_exposer.def( bp::init< SireMaths::MultiVector const & >(( bp::arg("other") ), "Copy constructor") );
        { //::SireMaths::MultiVector::angle
        
            typedef ::SireMaths::MultiDouble ( *angle_function_type )( ::SireMaths::MultiVector const &,::SireMaths::MultiVector const & );
            angle_function_type angle_function_value( &::SireMaths::MultiVector::angle );
            
            MultiVector_exposer.def( 
                "angle"
                , angle_function_value
                , ( bp::arg("v0"), bp::arg("v1") )
                , bp::release_gil_policy()
                , "Return the angle between vectors v0 and v1 - this is the smallest\nangle, and will always lie between 0 and 180 degrees" );
        
        }
        { //::SireMaths::MultiVector::angle
        
            typedef ::SireMaths::MultiDouble ( *angle_function_type )( ::SireMaths::MultiVector const &,::SireMaths::MultiVector const &,::SireMaths::MultiVector const & );
            angle_function_type angle_function_value( &::SireMaths::MultiVector::angle );
            
            MultiVector_exposer.def( 
                "angle"
                , angle_function_value
                , ( bp::arg("v0"), bp::arg("v1"), bp::arg("v2") )
                , bp::release_gil_policy()
                , "Return the angle between v0-v1-v2 (treating the vectors as points in space)" );
        
        }
        { //::SireMaths::MultiVector::at
        
            typedef ::SireMaths::Vector ( ::SireMaths::MultiVector::*at_function_type)( int ) const;
            at_function_type at_function_value( &::SireMaths::MultiVector::at );
            
            MultiVector_exposer.def( 
                "at"
                , at_function_value
                , ( bp::arg("i") )
                , bp::release_gil_policy()
                , "Access the ith vector in the MultiVector" );
        
        }
        { //::SireMaths::MultiVector::b
        
            typedef ::SireMaths::MultiDouble ( ::SireMaths::MultiVector::*b_function_type)(  ) const;
            b_function_type b_function_value( &::SireMaths::MultiVector::b );
            
            MultiVector_exposer.def( 
                "b"
                , b_function_value
                , bp::release_gil_policy()
                , "Return the components via rgb (limited between 0 and 1)" );
        
        }
        { //::SireMaths::MultiVector::bearing
        
            typedef ::SireMaths::MultiDouble ( ::SireMaths::MultiVector::*bearing_function_type)(  ) const;
            bearing_function_type bearing_function_value( &::SireMaths::MultiVector::bearing );
            
            MultiVector_exposer.def( 
                "bearing"
                , bearing_function_value
                , bp::release_gil_policy()
                , "Return the bearing of this vector against (0,1,0) (north) on the xy plane" );
        
        }
        { //::SireMaths::MultiVector::bearingXY
        
            typedef ::SireMaths::MultiDouble ( ::SireMaths::MultiVector::*bearingXY_function_type)( ::SireMaths::MultiVector const & ) const;
            bearingXY_function_type bearingXY_function_value( &::SireMaths::MultiVector::bearingXY );
            
            MultiVector_exposer.def( 
                "bearingXY"
                , bearingXY_function_value
                , ( bp::arg("v") )
                , bp::release_gil_policy()
                , "Return the bearing of this vector against v on the xy plane" );
        
        }
        { //::SireMaths::MultiVector::bearingXZ
        
            typedef ::SireMaths::MultiDouble ( ::SireMaths::MultiVector::*bearingXZ_function_type)( ::SireMaths::MultiVector const & ) const;
            bearingXZ_function_type bearingXZ_function_value( &::SireMaths::MultiVector::bearingXZ );
            
            MultiVector_exposer.def( 
                "bearingXZ"
                , bearingXZ_function_value
                , ( bp::arg("v") )
                , bp::release_gil_policy()
                , "Return the bearing of this vector against v on the xz plane" );
        
        }
        { //::SireMaths::MultiVector::bearingYZ
        
            typedef ::SireMaths::MultiDouble ( ::SireMaths::MultiVector::*bearingYZ_function_type)( ::SireMaths::MultiVector const & ) const;
            bearingYZ_function_type bearingYZ_function_value( &::SireMaths::MultiVector::bearingYZ );
            
            MultiVector_exposer.def( 
                "bearingYZ"
                , bearingYZ_function_value
                , ( bp::arg("v") )
                , bp::release_gil_policy()
                , "Return the bearing of this vector against v on the yz plane" );
        
        }
        { //::SireMaths::MultiVector::count
        
            typedef int ( *count_function_type )(  );
            count_function_type count_function_value( &::SireMaths::MultiVector::count );
            
            MultiVector_exposer.def( 
                "count"
                , count_function_value
                , bp::release_gil_policy()
                , "Return the number of vectors in this MultiVector" );
        
        }
        { //::SireMaths::MultiVector::cross
        
            typedef ::SireMaths::MultiVector ( *cross_function_type )( ::SireMaths::MultiVector const &,::SireMaths::MultiVector const & );
            cross_function_type cross_function_value( &::SireMaths::MultiVector::cross );
            
            MultiVector_exposer.def( 
                "cross"
                , cross_function_value
                , ( bp::arg("v0"), bp::arg("v1") )
                , bp::release_gil_policy()
                , "Return the cross product of v0 and v1" );
        
        }
        { //::SireMaths::MultiVector::dihedral
        
            typedef ::SireMaths::MultiDouble ( *dihedral_function_type )( ::SireMaths::MultiVector const &,::SireMaths::MultiVector const &,::SireMaths::MultiVector const &,::SireMaths::MultiVector const & );
            dihedral_function_type dihedral_function_value( &::SireMaths::MultiVector::dihedral );
            
            MultiVector_exposer.def( 
                "dihedral"
                , dihedral_function_value
                , ( bp::arg("v0"), bp::arg("v1"), bp::arg("v2"), bp::arg("v3") )
                , bp::release_gil_policy()
                , "Return the dihedral angle between v0-v1-v2-v3 (treating the vectors as points)" );
        
        }
        { //::SireMaths::MultiVector::direction
        
            typedef ::SireMaths::MultiVector ( ::SireMaths::MultiVector::*direction_function_type)(  ) const;
            direction_function_type direction_function_value( &::SireMaths::MultiVector::direction );
            
            MultiVector_exposer.def( 
                "direction"
                , direction_function_value
                , bp::release_gil_policy()
                , "Return the unit vector pointing in the direction of this vector" );
        
        }
        { //::SireMaths::MultiVector::distance
        
            typedef ::SireMaths::MultiDouble ( *distance_function_type )( ::SireMaths::MultiVector const &,::SireMaths::MultiVector const & );
            distance_function_type distance_function_value( &::SireMaths::MultiVector::distance );
            
            MultiVector_exposer.def( 
                "distance"
                , distance_function_value
                , ( bp::arg("v1"), bp::arg("v2") )
                , bp::release_gil_policy()
                , "Return the distance between two vectors" );
        
        }
        { //::SireMaths::MultiVector::distance2
        
            typedef ::SireMaths::MultiDouble ( *distance2_function_type )( ::SireMaths::MultiVector const &,::SireMaths::MultiVector const & );
            distance2_function_type distance2_function_value( &::SireMaths::MultiVector::distance2 );
            
            MultiVector_exposer.def( 
                "distance2"
                , distance2_function_value
                , ( bp::arg("v1"), bp::arg("v2") )
                , bp::release_gil_policy()
                , "Return the distance squared between two vectors" );
        
        }
        { //::SireMaths::MultiVector::dot
        
            typedef ::SireMaths::MultiDouble ( *dot_function_type )( ::SireMaths::MultiVector const &,::SireMaths::MultiVector const & );
            dot_function_type dot_function_value( &::SireMaths::MultiVector::dot );
            
            MultiVector_exposer.def( 
                "dot"
                , dot_function_value
                , ( bp::arg("v0"), bp::arg("v1") )
                , bp::release_gil_policy()
                , "Return the dot product of v0 and v1" );
        
        }
        { //::SireMaths::MultiVector::fromArray
        
            typedef ::QVector< SireMaths::MultiVector > ( *fromArray_function_type )( ::SireMaths::Vector const *,int );
            fromArray_function_type fromArray_function_value( &::SireMaths::MultiVector::fromArray );
            
            MultiVector_exposer.def( 
                "fromArray"
                , fromArray_function_value
                , ( bp::arg("array"), bp::arg("size") )
                , bp::release_gil_policy()
                , "Convert the passed array of vectors into an array of MultiVectors" );
        
        }
        { //::SireMaths::MultiVector::fromArray
        
            typedef ::QVector< SireMaths::MultiVector > ( *fromArray_function_type )( ::QVector< SireMaths::Vector > const & );
            fromArray_function_type fromArray_function_value( &::SireMaths::MultiVector::fromArray );
            
            MultiVector_exposer.def( 
                "fromArray"
                , fromArray_function_value
                , ( bp::arg("array") )
                , bp::release_gil_policy()
                , "Convert the passed array of vectors into an array of MultiVectors" );
        
        }
        { //::SireMaths::MultiVector::g
        
            typedef ::SireMaths::MultiDouble ( ::SireMaths::MultiVector::*g_function_type)(  ) const;
            g_function_type g_function_value( &::SireMaths::MultiVector::g );
            
            MultiVector_exposer.def( 
                "g"
                , g_function_value
                , bp::release_gil_policy()
                , "Return the components via rgb (limited between 0 and 1)" );
        
        }
        { //::SireMaths::MultiVector::generate
        
            typedef ::SireMaths::MultiVector ( *generate_function_type )( ::SireMaths::MultiDouble const &,::SireMaths::MultiVector const &,::SireMaths::MultiDouble const &,::SireMaths::MultiVector const &,::SireMaths::MultiDouble const &,::SireMaths::MultiVector const & );
            generate_function_type generate_function_value( &::SireMaths::MultiVector::generate );
            
            MultiVector_exposer.def( 
                "generate"
                , generate_function_value
                , ( bp::arg("dst"), bp::arg("v1"), bp::arg("ang"), bp::arg("v2"), bp::arg("dih"), bp::arg("v3") )
                , bp::release_gil_policy()
                , "Generate a vector, v0, that has distance dst v0-v1, angle ang v0-v1-v2,\nand dihedral dih v0-v1-v2-v3" );
        
        }
        { //::SireMaths::MultiVector::getitem
        
            typedef ::SireMaths::Vector ( ::SireMaths::MultiVector::*getitem_function_type)( int ) const;
            getitem_function_type getitem_function_value( &::SireMaths::MultiVector::getitem );
            
            MultiVector_exposer.def( 
                "getitem"
                , getitem_function_value
                , ( bp::arg("i") )
                , bp::release_gil_policy()
                , "Access the ith vector in the MultiVector" );
        
        }
        { //::SireMaths::MultiVector::invDistance
        
            typedef ::SireMaths::MultiDouble ( *invDistance_function_type )( ::SireMaths::MultiVector const &,::SireMaths::MultiVector const & );
            invDistance_function_type invDistance_function_value( &::SireMaths::MultiVector::invDistance );
            
            MultiVector_exposer.def( 
                "invDistance"
                , invDistance_function_value
                , ( bp::arg("v1"), bp::arg("v2") )
                , bp::release_gil_policy()
                , "Return the 1  distance between two vectors" );
        
        }
        { //::SireMaths::MultiVector::invDistance2
        
            typedef ::SireMaths::MultiDouble ( *invDistance2_function_type )( ::SireMaths::MultiVector const &,::SireMaths::MultiVector const & );
            invDistance2_function_type invDistance2_function_value( &::SireMaths::MultiVector::invDistance2 );
            
            MultiVector_exposer.def( 
                "invDistance2"
                , invDistance2_function_value
                , ( bp::arg("v1"), bp::arg("v2") )
                , bp::release_gil_policy()
                , "Return 1  distance2 between two vectors" );
        
        }
        { //::SireMaths::MultiVector::invLength
        
            typedef ::SireMaths::MultiDouble ( ::SireMaths::MultiVector::*invLength_function_type)(  ) const;
            invLength_function_type invLength_function_value( &::SireMaths::MultiVector::invLength );
            
            MultiVector_exposer.def( 
                "invLength"
                , invLength_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireMaths::MultiVector::invLength2
        
            typedef ::SireMaths::MultiDouble ( ::SireMaths::MultiVector::*invLength2_function_type)(  ) const;
            invLength2_function_type invLength2_function_value( &::SireMaths::MultiVector::invLength2 );
            
            MultiVector_exposer.def( 
                "invLength2"
                , invLength2_function_value
                , bp::release_gil_policy()
                , "Return the inverse length squared" );
        
        }
        { //::SireMaths::MultiVector::length
        
            typedef ::SireMaths::MultiDouble ( ::SireMaths::MultiVector::*length_function_type)(  ) const;
            length_function_type length_function_value( &::SireMaths::MultiVector::length );
            
            MultiVector_exposer.def( 
                "length"
                , length_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireMaths::MultiVector::length2
        
            typedef ::SireMaths::MultiDouble ( ::SireMaths::MultiVector::*length2_function_type)(  ) const;
            length2_function_type length2_function_value( &::SireMaths::MultiVector::length2 );
            
            MultiVector_exposer.def( 
                "length2"
                , length2_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireMaths::MultiVector::magnitude
        
            typedef ::SireMaths::MultiDouble ( ::SireMaths::MultiVector::*magnitude_function_type)(  ) const;
            magnitude_function_type magnitude_function_value( &::SireMaths::MultiVector::magnitude );
            
            MultiVector_exposer.def( 
                "magnitude"
                , magnitude_function_value
                , bp::release_gil_policy()
                , "Return the length of this vector" );
        
        }
        { //::SireMaths::MultiVector::manhattanLength
        
            typedef ::SireMaths::MultiDouble ( ::SireMaths::MultiVector::*manhattanLength_function_type)(  ) const;
            manhattanLength_function_type manhattanLength_function_value( &::SireMaths::MultiVector::manhattanLength );
            
            MultiVector_exposer.def( 
                "manhattanLength"
                , manhattanLength_function_value
                , bp::release_gil_policy()
                , "Return the manhattan length of the vector" );
        
        }
        { //::SireMaths::MultiVector::max
        
            typedef ::SireMaths::MultiVector ( ::SireMaths::MultiVector::*max_function_type)( ::SireMaths::MultiVector const & ) const;
            max_function_type max_function_value( &::SireMaths::MultiVector::max );
            
            MultiVector_exposer.def( 
                "max"
                , max_function_value
                , ( bp::arg("other") )
                , bp::release_gil_policy()
                , "Return a vector that has the maximum xyz components out of this\nand other" );
        
        }
        { //::SireMaths::MultiVector::min
        
            typedef ::SireMaths::MultiVector ( ::SireMaths::MultiVector::*min_function_type)( ::SireMaths::MultiVector const & ) const;
            min_function_type min_function_value( &::SireMaths::MultiVector::min );
            
            MultiVector_exposer.def( 
                "min"
                , min_function_value
                , ( bp::arg("other") )
                , bp::release_gil_policy()
                , "Return a vector that has the minimum components" );
        
        }
        { //::SireMaths::MultiVector::normalise
        
            typedef ::SireMaths::MultiVector ( ::SireMaths::MultiVector::*normalise_function_type)(  ) const;
            normalise_function_type normalise_function_value( &::SireMaths::MultiVector::normalise );
            
            MultiVector_exposer.def( 
                "normalise"
                , normalise_function_value
                , bp::release_gil_policy()
                , "Return a normalised form of the vector" );
        
        }
        MultiVector_exposer.def( bp::self != bp::self );
        MultiVector_exposer.def( -bp::self );
        { //::SireMaths::MultiVector::operator=
        
            typedef ::SireMaths::MultiVector & ( ::SireMaths::MultiVector::*assign_function_type)( ::SireMaths::MultiVector const & ) ;
            assign_function_type assign_function_value( &::SireMaths::MultiVector::operator= );
            
            MultiVector_exposer.def( 
                "assign"
                , assign_function_value
                , ( bp::arg("other") )
                , bp::return_self< >()
                , "" );
        
        }
        MultiVector_exposer.def( bp::self == bp::self );
        { //::SireMaths::MultiVector::operator[]
        
            typedef ::SireMaths::Vector ( ::SireMaths::MultiVector::*__getitem___function_type)( int ) const;
            __getitem___function_type __getitem___function_value( &::SireMaths::MultiVector::operator[] );
            
            MultiVector_exposer.def( 
                "__getitem__"
                , __getitem___function_value
                , ( bp::arg("i") )
                , "" );
        
        }
        { //::SireMaths::MultiVector::quickSet
        
            typedef void ( ::SireMaths::MultiVector::*quickSet_function_type)( int,::SireMaths::Vector const & ) ;
            quickSet_function_type quickSet_function_value( &::SireMaths::MultiVector::quickSet );
            
            MultiVector_exposer.def( 
                "quickSet"
                , quickSet_function_value
                , ( bp::arg("i"), bp::arg("val") )
                , bp::release_gil_policy()
                , "Quickly set the values of the vector, without checking the index is valid" );
        
        }
        { //::SireMaths::MultiVector::r
        
            typedef ::SireMaths::MultiDouble ( ::SireMaths::MultiVector::*r_function_type)(  ) const;
            r_function_type r_function_value( &::SireMaths::MultiVector::r );
            
            MultiVector_exposer.def( 
                "r"
                , r_function_value
                , bp::release_gil_policy()
                , "Return the components via rgb (limited between 0 and 1)" );
        
        }
        { //::SireMaths::MultiVector::set
        
            typedef void ( ::SireMaths::MultiVector::*set_function_type)( ::SireMaths::MultiDouble const &,::SireMaths::MultiDouble const &,::SireMaths::MultiDouble const & ) ;
            set_function_type set_function_value( &::SireMaths::MultiVector::set );
            
            MultiVector_exposer.def( 
                "set"
                , set_function_value
                , ( bp::arg("x"), bp::arg("y"), bp::arg("z") )
                , bp::release_gil_policy()
                , "Set individual values of the vector" );
        
        }
        { //::SireMaths::MultiVector::set
        
            typedef void ( ::SireMaths::MultiVector::*set_function_type)( int,::SireMaths::Vector const & ) ;
            set_function_type set_function_value( &::SireMaths::MultiVector::set );
            
            MultiVector_exposer.def( 
                "set"
                , set_function_value
                , ( bp::arg("i"), bp::arg("val") )
                , bp::release_gil_policy()
                , "Set individual values of the vector" );
        
        }
        { //::SireMaths::MultiVector::setB
        
            typedef void ( ::SireMaths::MultiVector::*setB_function_type)( ::SireMaths::MultiDouble const & ) ;
            setB_function_type setB_function_value( &::SireMaths::MultiVector::setB );
            
            MultiVector_exposer.def( 
                "setB"
                , setB_function_value
                , ( bp::arg("val") )
                , bp::release_gil_policy()
                , "Set individual values of the vector" );
        
        }
        { //::SireMaths::MultiVector::setG
        
            typedef void ( ::SireMaths::MultiVector::*setG_function_type)( ::SireMaths::MultiDouble const & ) ;
            setG_function_type setG_function_value( &::SireMaths::MultiVector::setG );
            
            MultiVector_exposer.def( 
                "setG"
                , setG_function_value
                , ( bp::arg("val") )
                , bp::release_gil_policy()
                , "Set individual values of the vector" );
        
        }
        { //::SireMaths::MultiVector::setMax
        
            typedef void ( ::SireMaths::MultiVector::*setMax_function_type)( ::SireMaths::MultiVector const & ) ;
            setMax_function_type setMax_function_value( &::SireMaths::MultiVector::setMax );
            
            MultiVector_exposer.def( 
                "setMax"
                , setMax_function_value
                , ( bp::arg("other") )
                , bp::release_gil_policy()
                , "Set this Vector so that it has the maximum xyz components out of\nthis and other (e.g. this->x = max(this->x(),other.x() etc.)" );
        
        }
        { //::SireMaths::MultiVector::setMin
        
            typedef void ( ::SireMaths::MultiVector::*setMin_function_type)( ::SireMaths::MultiVector const & ) ;
            setMin_function_type setMin_function_value( &::SireMaths::MultiVector::setMin );
            
            MultiVector_exposer.def( 
                "setMin"
                , setMin_function_value
                , ( bp::arg("other") )
                , bp::release_gil_policy()
                , "Set this Vector so that it has the minimum xyz components" );
        
        }
        { //::SireMaths::MultiVector::setR
        
            typedef void ( ::SireMaths::MultiVector::*setR_function_type)( ::SireMaths::MultiDouble const & ) ;
            setR_function_type setR_function_value( &::SireMaths::MultiVector::setR );
            
            MultiVector_exposer.def( 
                "setR"
                , setR_function_value
                , ( bp::arg("val") )
                , bp::release_gil_policy()
                , "Set individual values of the vector" );
        
        }
        { //::SireMaths::MultiVector::setX
        
            typedef void ( ::SireMaths::MultiVector::*setX_function_type)( ::SireMaths::MultiDouble const & ) ;
            setX_function_type setX_function_value( &::SireMaths::MultiVector::setX );
            
            MultiVector_exposer.def( 
                "setX"
                , setX_function_value
                , ( bp::arg("val") )
                , bp::release_gil_policy()
                , "Set individual values of the vector" );
        
        }
        { //::SireMaths::MultiVector::setY
        
            typedef void ( ::SireMaths::MultiVector::*setY_function_type)( ::SireMaths::MultiDouble const & ) ;
            setY_function_type setY_function_value( &::SireMaths::MultiVector::setY );
            
            MultiVector_exposer.def( 
                "setY"
                , setY_function_value
                , ( bp::arg("val") )
                , bp::release_gil_policy()
                , "Set individual values of the vector" );
        
        }
        { //::SireMaths::MultiVector::setZ
        
            typedef void ( ::SireMaths::MultiVector::*setZ_function_type)( ::SireMaths::MultiDouble const & ) ;
            setZ_function_type setZ_function_value( &::SireMaths::MultiVector::setZ );
            
            MultiVector_exposer.def( 
                "setZ"
                , setZ_function_value
                , ( bp::arg("val") )
                , bp::release_gil_policy()
                , "Set individual values of the vector" );
        
        }
        { //::SireMaths::MultiVector::size
        
            typedef int ( *size_function_type )(  );
            size_function_type size_function_value( &::SireMaths::MultiVector::size );
            
            MultiVector_exposer.def( 
                "size"
                , size_function_value
                , bp::release_gil_policy()
                , "Return the number of vectors in this MultiVector" );
        
        }
        { //::SireMaths::MultiVector::swap
        
            typedef void ( *swap_function_type )( ::SireMaths::MultiVector &,int,::SireMaths::MultiVector &,int );
            swap_function_type swap_function_value( &::SireMaths::MultiVector::swap );
            
            MultiVector_exposer.def( 
                "swap"
                , swap_function_value
                , ( bp::arg("v0"), bp::arg("idx0"), bp::arg("v1"), bp::arg("idx1") )
                , bp::release_gil_policy()
                , "Swap the values of the value at index idx0 in f0 with the value at index idx in f1" );
        
        }
        { //::SireMaths::MultiVector::toString
        
            typedef ::QString ( ::SireMaths::MultiVector::*toString_function_type)(  ) const;
            toString_function_type toString_function_value( &::SireMaths::MultiVector::toString );
            
            MultiVector_exposer.def( 
                "toString"
                , toString_function_value
                , bp::release_gil_policy()
                , "Return a QString representation of the vector" );
        
        }
        { //::SireMaths::MultiVector::typeName
        
            typedef char const * ( *typeName_function_type )(  );
            typeName_function_type typeName_function_value( &::SireMaths::MultiVector::typeName );
            
            MultiVector_exposer.def( 
                "typeName"
                , typeName_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireMaths::MultiVector::what
        
            typedef char const * ( ::SireMaths::MultiVector::*what_function_type)(  ) const;
            what_function_type what_function_value( &::SireMaths::MultiVector::what );
            
            MultiVector_exposer.def( 
                "what"
                , what_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireMaths::MultiVector::x
        
            typedef ::SireMaths::MultiDouble const & ( ::SireMaths::MultiVector::*x_function_type)(  ) const;
            x_function_type x_function_value( &::SireMaths::MultiVector::x );
            
            MultiVector_exposer.def( 
                "x"
                , x_function_value
                , bp::return_value_policy< bp::copy_const_reference >()
                , "" );
        
        }
        { //::SireMaths::MultiVector::y
        
            typedef ::SireMaths::MultiDouble const & ( ::SireMaths::MultiVector::*y_function_type)(  ) const;
            y_function_type y_function_value( &::SireMaths::MultiVector::y );
            
            MultiVector_exposer.def( 
                "y"
                , y_function_value
                , bp::return_value_policy< bp::copy_const_reference >()
                , "" );
        
        }
        { //::SireMaths::MultiVector::z
        
            typedef ::SireMaths::MultiDouble const & ( ::SireMaths::MultiVector::*z_function_type)(  ) const;
            z_function_type z_function_value( &::SireMaths::MultiVector::z );
            
            MultiVector_exposer.def( 
                "z"
                , z_function_value
                , bp::return_value_policy< bp::copy_const_reference >()
                , "" );
        
        }
        MultiVector_exposer.staticmethod( "angle" );
        MultiVector_exposer.staticmethod( "count" );
        MultiVector_exposer.staticmethod( "cross" );
        MultiVector_exposer.staticmethod( "dihedral" );
        MultiVector_exposer.staticmethod( "distance" );
        MultiVector_exposer.staticmethod( "distance2" );
        MultiVector_exposer.staticmethod( "dot" );
        MultiVector_exposer.staticmethod( "fromArray" );
        MultiVector_exposer.staticmethod( "generate" );
        MultiVector_exposer.staticmethod( "invDistance" );
        MultiVector_exposer.staticmethod( "invDistance2" );
        MultiVector_exposer.staticmethod( "size" );
        MultiVector_exposer.staticmethod( "swap" );
        MultiVector_exposer.staticmethod( "typeName" );
        MultiVector_exposer.def( bp::self * bp::other< SireMaths::MultiDouble >() );
        MultiVector_exposer.def( bp::self * bp::other< SireMaths::MultiQuaternion >() );
        MultiVector_exposer.def( bp::self + bp::self );
        MultiVector_exposer.def( bp::self - bp::self );
        MultiVector_exposer.def( bp::self / bp::other< SireMaths::MultiDouble >() );
        MultiVector_exposer.def( "__copy__", &__copy__);
        MultiVector_exposer.def( "__deepcopy__", &__copy__);
        MultiVector_exposer.def( "clone", &__copy__);
        MultiVector_exposer.def( "__str__", &__str__< ::SireMaths::MultiVector > );
        MultiVector_exposer.def( "__repr__", &__str__< ::SireMaths::MultiVector > );
        MultiVector_exposer.def( "__len__", &__len_size< ::SireMaths::MultiVector > );
        MultiVector_exposer.def( "__getitem__", &::SireMaths::MultiVector::getitem );
    }

}
