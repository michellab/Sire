// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 2 License

#include "boost/python.hpp"
#include "Space.pypp.hpp"

namespace bp = boost::python;

#include "SireError/errors.h"

#include "SireMaths/rangenerator.h"

#include "SireStream/datastream.h"

#include "SireStream/shareddatastream.h"

#include "cartesian.h"

#include "space.h"

#include <QMutex>

#include "space.h"

#include "Qt/qdatastream.hpp"

#include "Helpers/str.hpp"

#include "Helpers/release_gil_policy.hpp"

void register_Space_class(){

    { //::SireVol::Space
        typedef bp::class_< SireVol::Space, bp::bases< SireBase::Property >, boost::noncopyable > Space_exposer_t;
        Space_exposer_t Space_exposer = Space_exposer_t( "Space", "\nThis pure virtual base class represents the volume of space within which a SimSystem\nresides. This class provides functions that calculate the distances between CoordGroups\nin this volume, and has most of the optimisation (since most of the hard-work\ndouble distance loops occur in this class). Key overloaded classes that inherit\nSpace are Cartesian, which represents infinite 3D cartesian space, and\nPeriodicBox which represents a 3D periodic box.\n\nAs this class is used right in the heart of the double loop it is very important\nthat it is not implemented in a way that requires a lot of virtual function calls.\nThis means that the class is implemented to calculate the distances of all pairs of points\nbetween two CoordGroups in a single virtual function call. The results are held\nin a special matrix that can be queried via read-only, inline, non-virtual\nfunctions, with the items ordered in memory in the same order that you would get\nby iterating over all pairs (group1 in outer loop, group2 in inner loop). An advantage\nof this approach is that as the distances are calculated in one go, it is possible for\nthe Space class to find out whether two CoordGroups are within the non-bonded cutoff\ndistance before any further calculation is performed.\n\nTo prevent continual reallocation, the Space class works on an already-allocated\nmatrix class. This is only reallocated if it is found that it is not sufficiently\nlarge to hold the pair of CoordGroups.\n\nAs a further optimisation, the distance matrix may be populated with the interpoint\ndistances, or the square of the interatomic distances, or the 1  distances\nor 1  distances^2\n\nThe inheritors of this class should be the only parts of this code where\ndistance calculations are calculated between and within CoordGroups. This will\nallow you to change the space of the system here, and have that space used in the\nrest of the code that uses CoordGroups.\n\nThis is a virtual class that is designed to be used with SharedPolyPointer.\n\nAuthor: Christopher Woods\n", bp::no_init );
        bp::scope Space_scope( Space_exposer );
        { //::SireVol::Space::beyond
        
            typedef bool ( ::SireVol::Space::*beyond_function_type)( double,::SireVol::CoordGroup const &,::SireVol::CoordGroup const & ) const;
            beyond_function_type beyond_function_value( &::SireVol::Space::beyond );
            
            Space_exposer.def( 
                "beyond"
                , beyond_function_value
                , ( bp::arg("dist"), bp::arg("group0"), bp::arg("group1") )
                , bp::release_gil_policy()
                , "Return whether or not these two groups are definitely beyond the distance dist.\n\nWarning: Note beyond does not mean definitely within the distance\n" );
        
        }
        { //::SireVol::Space::beyond
        
            typedef bool ( ::SireVol::Space::*beyond_function_type)( double,::SireVol::AABox const &,::SireVol::AABox const & ) const;
            beyond_function_type beyond_function_value( &::SireVol::Space::beyond );
            
            Space_exposer.def( 
                "beyond"
                , beyond_function_value
                , ( bp::arg("dist"), bp::arg("aabox0"), bp::arg("aabox1") )
                , bp::release_gil_policy()
                , "Return whether or not two groups that are enclosed by the AABoxes\naabox0 and aabox1 are beyond the cutoff distance dist.\n\nWarning: Note beyond does not mean definitely within the distance\n" );
        
        }
        { //::SireVol::Space::calcAngle
        
            typedef ::SireUnits::Dimension::Angle ( ::SireVol::Space::*calcAngle_function_type)( ::SireMaths::Vector const &,::SireMaths::Vector const &,::SireMaths::Vector const & ) const;
            calcAngle_function_type calcAngle_function_value( &::SireVol::Space::calcAngle );
            
            Space_exposer.def( 
                "calcAngle"
                , calcAngle_function_value
                , ( bp::arg("point0"), bp::arg("point1"), bp::arg("point2") )
                , bp::release_gil_policy()
                , "Calculate the angle between the passed three points. This should return\nthe acute angle between the points, which should lie between 0 and 180 degrees" );
        
        }
        { //::SireVol::Space::calcDihedral
        
            typedef ::SireUnits::Dimension::Angle ( ::SireVol::Space::*calcDihedral_function_type)( ::SireMaths::Vector const &,::SireMaths::Vector const &,::SireMaths::Vector const &,::SireMaths::Vector const & ) const;
            calcDihedral_function_type calcDihedral_function_value( &::SireVol::Space::calcDihedral );
            
            Space_exposer.def( 
                "calcDihedral"
                , calcDihedral_function_value
                , ( bp::arg("point0"), bp::arg("point1"), bp::arg("point2"), bp::arg("point3") )
                , bp::release_gil_policy()
                , "Calculate the torsion angle between the passed four points. This should\nreturn the torsion angle measured clockwise when looking down the\ntorsion from point0-point1-point2-point3. This will lie between 0 and 360\ndegrees" );
        
        }
        { //::SireVol::Space::calcDist
        
            typedef double ( ::SireVol::Space::*calcDist_function_type)( ::SireMaths::Vector const &,::SireMaths::Vector const & ) const;
            calcDist_function_type calcDist_function_value( &::SireVol::Space::calcDist );
            
            Space_exposer.def( 
                "calcDist"
                , calcDist_function_value
                , ( bp::arg("point0"), bp::arg("point1") )
                , bp::release_gil_policy()
                , "Calculate the distance between two points" );
        
        }
        { //::SireVol::Space::calcDist
        
            typedef double ( ::SireVol::Space::*calcDist_function_type)( ::SireVol::CoordGroup const &,::SireVol::DistMatrix & ) const;
            calcDist_function_type calcDist_function_value( &::SireVol::Space::calcDist );
            
            Space_exposer.def( 
                "calcDist"
                , calcDist_function_value
                , ( bp::arg("group"), bp::arg("distmat") )
                , bp::release_gil_policy()
                , "Populate the matrix mat with the distances between all of the\npoints within a CoordGroup. This creates a symmetrical matrix,\nwith a 0 diagonal. This returns the shortest distance between\ntwo points within the group." );
        
        }
        { //::SireVol::Space::calcDist
        
            typedef double ( ::SireVol::Space::*calcDist_function_type)( ::SireVol::CoordGroup const &,::SireVol::CoordGroup const &,::SireVol::DistMatrix & ) const;
            calcDist_function_type calcDist_function_value( &::SireVol::Space::calcDist );
            
            Space_exposer.def( 
                "calcDist"
                , calcDist_function_value
                , ( bp::arg("group1"), bp::arg("group2"), bp::arg("distmat") )
                , bp::release_gil_policy()
                , "Populate the matrix mat with the distances between all of the\npoints of the two CoordGroups. Return the shortest distance^2 between the two\nCoordGroups." );
        
        }
        { //::SireVol::Space::calcDist
        
            typedef double ( ::SireVol::Space::*calcDist_function_type)( ::SireVol::CoordGroup const &,::SireMaths::Vector const &,::SireVol::DistMatrix & ) const;
            calcDist_function_type calcDist_function_value( &::SireVol::Space::calcDist );
            
            Space_exposer.def( 
                "calcDist"
                , calcDist_function_value
                , ( bp::arg("group"), bp::arg("point"), bp::arg("distmat") )
                , bp::release_gil_policy()
                , "Populate the matrix distmat with the distances between all of the\npoints in group to the point point. This returns the shortest\ndistance between the group points and point" );
        
        }
        { //::SireVol::Space::calcDist2
        
            typedef double ( ::SireVol::Space::*calcDist2_function_type)( ::SireMaths::Vector const &,::SireMaths::Vector const & ) const;
            calcDist2_function_type calcDist2_function_value( &::SireVol::Space::calcDist2 );
            
            Space_exposer.def( 
                "calcDist2"
                , calcDist2_function_value
                , ( bp::arg("point0"), bp::arg("point1") )
                , bp::release_gil_policy()
                , "Calculate the distance squared between two points" );
        
        }
        { //::SireVol::Space::calcDist2
        
            typedef double ( ::SireVol::Space::*calcDist2_function_type)( ::SireVol::CoordGroup const &,::SireVol::DistMatrix & ) const;
            calcDist2_function_type calcDist2_function_value( &::SireVol::Space::calcDist2 );
            
            Space_exposer.def( 
                "calcDist2"
                , calcDist2_function_value
                , ( bp::arg("group"), bp::arg("distmat") )
                , bp::release_gil_policy()
                , "Populate the matrix mat with the distances^2 between all of the\npoints within a CoordGroup. This creates a symmetrical matrix,\nwith a 0 diagonal. This returns the shortest distance^2 between\ntwo points within the group." );
        
        }
        { //::SireVol::Space::calcDist2
        
            typedef double ( ::SireVol::Space::*calcDist2_function_type)( ::SireVol::CoordGroup const &,::SireMaths::Vector const &,::SireVol::DistMatrix & ) const;
            calcDist2_function_type calcDist2_function_value( &::SireVol::Space::calcDist2 );
            
            Space_exposer.def( 
                "calcDist2"
                , calcDist2_function_value
                , ( bp::arg("group"), bp::arg("point"), bp::arg("distmat") )
                , bp::release_gil_policy()
                , "Populate the matrix distmat with the distances squared between all of the\npoints in group to the point point. This returns the shortest\ndistance between the group points and point" );
        
        }
        { //::SireVol::Space::calcDist2
        
            typedef double ( ::SireVol::Space::*calcDist2_function_type)( ::SireVol::CoordGroup const &,::SireVol::CoordGroup const &,::SireVol::DistMatrix & ) const;
            calcDist2_function_type calcDist2_function_value( &::SireVol::Space::calcDist2 );
            
            Space_exposer.def( 
                "calcDist2"
                , calcDist2_function_value
                , ( bp::arg("group1"), bp::arg("group2"), bp::arg("distmat") )
                , bp::release_gil_policy()
                , "Populate the matrix mat with the distances^2 between all of the\npoints of the two CoordGroups. Return the shortest distance^2 between the\ntwo CoordGroups." );
        
        }
        { //::SireVol::Space::calcDistVector
        
            typedef ::SireMaths::DistVector ( ::SireVol::Space::*calcDistVector_function_type)( ::SireMaths::Vector const &,::SireMaths::Vector const & ) const;
            calcDistVector_function_type calcDistVector_function_value( &::SireVol::Space::calcDistVector );
            
            Space_exposer.def( 
                "calcDistVector"
                , calcDistVector_function_value
                , ( bp::arg("point0"), bp::arg("point1") )
                , bp::release_gil_policy()
                , "Calculate the distance vector between two points" );
        
        }
        { //::SireVol::Space::calcDistVectors
        
            typedef double ( ::SireVol::Space::*calcDistVectors_function_type)( ::SireVol::CoordGroup const &,::SireVol::DistVectorMatrix & ) const;
            calcDistVectors_function_type calcDistVectors_function_value( &::SireVol::Space::calcDistVectors );
            
            Space_exposer.def( 
                "calcDistVectors"
                , calcDistVectors_function_value
                , ( bp::arg("group"), bp::arg("distmat") )
                , bp::release_gil_policy()
                , "Populate the matrix distmat with all of the interpoint distance vectors\nbetween all points within the CoordGroup. This is not a symmetrical matrix,\nas the direction from point A to point B is the negative of the\ndirection from point B to point A. This returns the shortest distance\nbetween two points in the group (that is not the self-self distance)" );
        
        }
        { //::SireVol::Space::calcDistVectors
        
            typedef double ( ::SireVol::Space::*calcDistVectors_function_type)( ::SireVol::CoordGroup const &,::SireVol::CoordGroup const &,::SireVol::DistVectorMatrix & ) const;
            calcDistVectors_function_type calcDistVectors_function_value( &::SireVol::Space::calcDistVectors );
            
            Space_exposer.def( 
                "calcDistVectors"
                , calcDistVectors_function_value
                , ( bp::arg("group1"), bp::arg("group2"), bp::arg("distmat") )
                , bp::release_gil_policy()
                , "Populate the matrix distmat between all the points of the two CoordGroups\ngroup1 and group2 - the returned matrix has the vectors pointing\nfrom each point in group1 to each point in group2. This returns\nthe shortest distance between two points in the group" );
        
        }
        { //::SireVol::Space::calcDistVectors
        
            typedef double ( ::SireVol::Space::*calcDistVectors_function_type)( ::SireVol::CoordGroup const &,::SireMaths::Vector const &,::SireVol::DistVectorMatrix & ) const;
            calcDistVectors_function_type calcDistVectors_function_value( &::SireVol::Space::calcDistVectors );
            
            Space_exposer.def( 
                "calcDistVectors"
                , calcDistVectors_function_value
                , ( bp::arg("group"), bp::arg("point"), bp::arg("distmat") )
                , bp::release_gil_policy()
                , "Populate the matrix distmat with the distances between all of the\npoints in group to the point point. This returns the shortest\ndistance between the group points and point" );
        
        }
        { //::SireVol::Space::calcInvDist
        
            typedef double ( ::SireVol::Space::*calcInvDist_function_type)( ::SireVol::CoordGroup const &,::SireVol::DistMatrix & ) const;
            calcInvDist_function_type calcInvDist_function_value( &::SireVol::Space::calcInvDist );
            
            Space_exposer.def( 
                "calcInvDist"
                , calcInvDist_function_value
                , ( bp::arg("group"), bp::arg("distmat") )
                , bp::release_gil_policy()
                , "Populate the matrix mat with the inverse distances between all of the\npoints within a CoordGroup. This creates a symmetrical matrix,\nwith a 0 diagonal. This returns the the largest inverse distance between\ntwo points within the group." );
        
        }
        { //::SireVol::Space::calcInvDist
        
            typedef double ( ::SireVol::Space::*calcInvDist_function_type)( ::SireVol::CoordGroup const &,::SireVol::CoordGroup const &,::SireVol::DistMatrix & ) const;
            calcInvDist_function_type calcInvDist_function_value( &::SireVol::Space::calcInvDist );
            
            Space_exposer.def( 
                "calcInvDist"
                , calcInvDist_function_value
                , ( bp::arg("group1"), bp::arg("group2"), bp::arg("distmat") )
                , bp::release_gil_policy()
                , "Populate the matrix mat with the inverse distances between all of the\npoints of the two CoordGroups. Return the largest inverse distance between the two\nCoordGroups." );
        
        }
        { //::SireVol::Space::calcInvDist2
        
            typedef double ( ::SireVol::Space::*calcInvDist2_function_type)( ::SireVol::CoordGroup const &,::SireVol::DistMatrix & ) const;
            calcInvDist2_function_type calcInvDist2_function_value( &::SireVol::Space::calcInvDist2 );
            
            Space_exposer.def( 
                "calcInvDist2"
                , calcInvDist2_function_value
                , ( bp::arg("group"), bp::arg("distmat") )
                , bp::release_gil_policy()
                , "Populate the matrix mat with the inverse distances^2 between all of the\npoints within a CoordGroup. This creates a symmetrical matrix,\nwith a 0 diagonal. This returns the the largest inverse distance^2 between\ntwo points within the group." );
        
        }
        { //::SireVol::Space::calcInvDist2
        
            typedef double ( ::SireVol::Space::*calcInvDist2_function_type)( ::SireVol::CoordGroup const &,::SireVol::CoordGroup const &,::SireVol::DistMatrix & ) const;
            calcInvDist2_function_type calcInvDist2_function_value( &::SireVol::Space::calcInvDist2 );
            
            Space_exposer.def( 
                "calcInvDist2"
                , calcInvDist2_function_value
                , ( bp::arg("group1"), bp::arg("group2"), bp::arg("distmat") )
                , bp::release_gil_policy()
                , "Populate the matrix mat with the inverse distances^2 between all of the\npoints of the two CoordGroups. Return the largest inverse distance^2 between the two\nCoordGroups." );
        
        }
        { //::SireVol::Space::changeVolume
        
            typedef ::SireVol::SpacePtr ( ::SireVol::Space::*changeVolume_function_type)( ::SireUnits::Dimension::Volume ) const;
            changeVolume_function_type changeVolume_function_value( &::SireVol::Space::changeVolume );
            
            Space_exposer.def( 
                "changeVolume"
                , changeVolume_function_value
                , ( bp::arg("delta") )
                , bp::release_gil_policy()
                , "Change the volume of this space by delta" );
        
        }
        { //::SireVol::Space::getBoxCenter
        
            typedef ::SireMaths::Vector ( ::SireVol::Space::*getBoxCenter_function_type)( ::SireMaths::Vector const & ) const;
            getBoxCenter_function_type getBoxCenter_function_value( &::SireVol::Space::getBoxCenter );
            
            Space_exposer.def( 
                "getBoxCenter"
                , getBoxCenter_function_value
                , ( bp::arg("p") )
                , bp::release_gil_policy()
                , "Return the center of the box that contains the point p assuming\nthat the center for the central box is located at the origin" );
        
        }
        { //::SireVol::Space::getBoxCenter
        
            typedef ::SireMaths::Vector ( ::SireVol::Space::*getBoxCenter_function_type)( ::SireMaths::Vector const &,::SireMaths::Vector const & ) const;
            getBoxCenter_function_type getBoxCenter_function_value( &::SireVol::Space::getBoxCenter );
            
            Space_exposer.def( 
                "getBoxCenter"
                , getBoxCenter_function_value
                , ( bp::arg("p"), bp::arg("center") )
                , bp::release_gil_policy()
                , "Return the center of the box that contains the point p assuming\nthat the center for the central box is located at center" );
        
        }
        { //::SireVol::Space::getCopiesWithin
        
            typedef ::QList< boost::tuples::tuple< double, SireVol::CoordGroup, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type > > ( ::SireVol::Space::*getCopiesWithin_function_type)( ::SireVol::CoordGroup const &,::SireVol::CoordGroup const &,double ) const;
            getCopiesWithin_function_type getCopiesWithin_function_value( &::SireVol::Space::getCopiesWithin );
            
            Space_exposer.def( 
                "getCopiesWithin"
                , getCopiesWithin_function_value
                , ( bp::arg("group"), bp::arg("center"), bp::arg("dist") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireVol::Space::getImagesWithin
        
            typedef ::QVector< SireMaths::Vector > ( ::SireVol::Space::*getImagesWithin_function_type)( ::SireMaths::Vector const &,::SireMaths::Vector const &,double ) const;
            getImagesWithin_function_type getImagesWithin_function_value( &::SireVol::Space::getImagesWithin );
            
            Space_exposer.def( 
                "getImagesWithin"
                , getImagesWithin_function_value
                , ( bp::arg("point"), bp::arg("center"), bp::arg("dist") )
                , bp::release_gil_policy()
                , "Return all periodic images of point with respect to center within\ndist distance of center" );
        
        }
        { //::SireVol::Space::getMinimumImage
        
            typedef ::SireVol::CoordGroup ( ::SireVol::Space::*getMinimumImage_function_type)( ::SireVol::CoordGroup const &,::SireMaths::Vector const & ) const;
            getMinimumImage_function_type getMinimumImage_function_value( &::SireVol::Space::getMinimumImage );
            
            Space_exposer.def( 
                "getMinimumImage"
                , getMinimumImage_function_value
                , ( bp::arg("group"), bp::arg("center") )
                , bp::release_gil_policy()
                , "Return the minimum image copy of group with respect to center.\nFor periodic spaces, this translates group into the box that\nhas its center at center (i.e. returns the closest copy of\ngroup to center according to the minimum image convention)" );
        
        }
        { //::SireVol::Space::getMinimumImage
        
            typedef ::SireVol::CoordGroupArray ( ::SireVol::Space::*getMinimumImage_function_type)( ::SireVol::CoordGroupArray const &,::SireMaths::Vector const &,bool ) const;
            getMinimumImage_function_type getMinimumImage_function_value( &::SireVol::Space::getMinimumImage );
            
            Space_exposer.def( 
                "getMinimumImage"
                , getMinimumImage_function_value
                , ( bp::arg("groups"), bp::arg("center"), bp::arg("translate_as_one")=(bool)(false) )
                , "Return the minimum image copy of groups with respect to center.\nFor periodic spaces, this translates groups into the box that\nhas its center at center (i.e. returns the closest copy of\neach group to center according to the minimum image convention)" );
        
        }
        { //::SireVol::Space::getMinimumImage
        
            typedef ::SireVol::AABox ( ::SireVol::Space::*getMinimumImage_function_type)( ::SireVol::AABox const &,::SireMaths::Vector const & ) const;
            getMinimumImage_function_type getMinimumImage_function_value( &::SireVol::Space::getMinimumImage );
            
            Space_exposer.def( 
                "getMinimumImage"
                , getMinimumImage_function_value
                , ( bp::arg("aabox"), bp::arg("center") )
                , bp::release_gil_policy()
                , "Return the minimum image copy of aabox with respect to center.\nFor periodic spaces, this returns the AABox translated into the\nbox that has its center at center" );
        
        }
        { //::SireVol::Space::getMinimumImage
        
            typedef ::SireMaths::Vector ( ::SireVol::Space::*getMinimumImage_function_type)( ::SireMaths::Vector const &,::SireMaths::Vector const & ) const;
            getMinimumImage_function_type getMinimumImage_function_value( &::SireVol::Space::getMinimumImage );
            
            Space_exposer.def( 
                "getMinimumImage"
                , getMinimumImage_function_value
                , ( bp::arg("point"), bp::arg("center") )
                , bp::release_gil_policy()
                , "Return the minimum image copy of point with respect to center.\nFor periodic spaces, this returns the point translated into the\nbox that has its center at center" );
        
        }
        { //::SireVol::Space::getRandomPoint
        
            typedef ::SireMaths::Vector ( ::SireVol::Space::*getRandomPoint_function_type)( ::SireMaths::Vector const &,::SireMaths::RanGenerator const & ) const;
            getRandomPoint_function_type getRandomPoint_function_value( &::SireVol::Space::getRandomPoint );
            
            Space_exposer.def( 
                "getRandomPoint"
                , getRandomPoint_function_value
                , ( bp::arg("center"), bp::arg("generator") )
                , bp::release_gil_policy()
                , "Return a random point within this space, using the passed\nrandom number generator to generate the necessary random numbers,\nand placing the center of the box at center" );
        
        }
        { //::SireVol::Space::getRandomPoint
        
            typedef ::SireMaths::Vector ( ::SireVol::Space::*getRandomPoint_function_type)( ::SireMaths::Vector const & ) const;
            getRandomPoint_function_type getRandomPoint_function_value( &::SireVol::Space::getRandomPoint );
            
            Space_exposer.def( 
                "getRandomPoint"
                , getRandomPoint_function_value
                , ( bp::arg("center") )
                , bp::release_gil_policy()
                , "Return a random point within this space using the global\nrandom number generator and with the box centered at center" );
        
        }
        { //::SireVol::Space::getRandomPoint
        
            typedef ::SireMaths::Vector ( ::SireVol::Space::*getRandomPoint_function_type)( ::SireMaths::RanGenerator const & ) const;
            getRandomPoint_function_type getRandomPoint_function_value( &::SireVol::Space::getRandomPoint );
            
            Space_exposer.def( 
                "getRandomPoint"
                , getRandomPoint_function_value
                , ( bp::arg("generator") )
                , bp::release_gil_policy()
                , "Return a random point within this space using the passed\nrandom number generator to generate any necessary random\nnumbers, and centering the box at the origin" );
        
        }
        { //::SireVol::Space::getRandomPoint
        
            typedef ::SireMaths::Vector ( ::SireVol::Space::*getRandomPoint_function_type)(  ) const;
            getRandomPoint_function_type getRandomPoint_function_value( &::SireVol::Space::getRandomPoint );
            
            Space_exposer.def( 
                "getRandomPoint"
                , getRandomPoint_function_value
                , bp::release_gil_policy()
                , "Return a random point within this space using the global\nrandom number generator, and with the box centered at the origin" );
        
        }
        { //::SireVol::Space::isCartesian
        
            typedef bool ( ::SireVol::Space::*isCartesian_function_type)(  ) const;
            isCartesian_function_type isCartesian_function_value( &::SireVol::Space::isCartesian );
            
            Space_exposer.def( 
                "isCartesian"
                , isCartesian_function_value
                , bp::release_gil_policy()
                , "Return whether or not this space is cartesian\n( x==y==z == 1 and all angle between x-y, y-z, x-z all 90 degrees )" );
        
        }
        { //::SireVol::Space::isPeriodic
        
            typedef bool ( ::SireVol::Space::*isPeriodic_function_type)(  ) const;
            isPeriodic_function_type isPeriodic_function_value( &::SireVol::Space::isPeriodic );
            
            Space_exposer.def( 
                "isPeriodic"
                , isPeriodic_function_value
                , bp::release_gil_policy()
                , "Return whether or not this space is periodic" );
        
        }
        { //::SireVol::Space::minimumDistance
        
            typedef double ( ::SireVol::Space::*minimumDistance_function_type)( ::SireVol::CoordGroup const &,::SireVol::CoordGroup const & ) const;
            minimumDistance_function_type minimumDistance_function_value( &::SireVol::Space::minimumDistance );
            
            Space_exposer.def( 
                "minimumDistance"
                , minimumDistance_function_value
                , ( bp::arg("group0"), bp::arg("group1") )
                , bp::release_gil_policy()
                , "Return the minimum distance between the points in group0 and group1.\nIf this is a periodic space then this uses the minimum image convention\n(i.e. the minimum distance between the closest periodic replicas are\nused)" );
        
        }
        { //::SireVol::Space::minimumDistance
        
            typedef double ( ::SireVol::Space::*minimumDistance_function_type)( ::SireVol::CoordGroup const & ) const;
            minimumDistance_function_type minimumDistance_function_value( &::SireVol::Space::minimumDistance );
            
            Space_exposer.def( 
                "minimumDistance"
                , minimumDistance_function_value
                , ( bp::arg("group") )
                , bp::release_gil_policy()
                , "Return the minimum distance between points within the group group." );
        
        }
        { //::SireVol::Space::minimumDistance
        
            typedef double ( ::SireVol::Space::*minimumDistance_function_type)( ::SireVol::AABox const &,::SireVol::AABox const & ) const;
            minimumDistance_function_type minimumDistance_function_value( &::SireVol::Space::minimumDistance );
            
            Space_exposer.def( 
                "minimumDistance"
                , minimumDistance_function_value
                , ( bp::arg("box0"), bp::arg("box1") )
                , bp::release_gil_policy()
                , "Return the minimum distance between the two AABoxes" );
        
        }
        { //::SireVol::Space::null
        
            typedef ::SireVol::Cartesian const & ( *null_function_type )(  );
            null_function_type null_function_value( &::SireVol::Space::null );
            
            Space_exposer.def( 
                "null"
                , null_function_value
                , bp::return_value_policy< bp::copy_const_reference >()
                , "Return the default space (Cartesian infinite box)" );
        
        }
        { //::SireVol::Space::setVolume
        
            typedef ::SireVol::SpacePtr ( ::SireVol::Space::*setVolume_function_type)( ::SireUnits::Dimension::Volume ) const;
            setVolume_function_type setVolume_function_value( &::SireVol::Space::setVolume );
            
            Space_exposer.def( 
                "setVolume"
                , setVolume_function_value
                , ( bp::arg("volume") )
                , bp::release_gil_policy()
                , "Return a copy of this space with the volume of set to volume\n- this will scale the space uniformly, keeping the center at\nthe same location, to achieve this volume" );
        
        }
        { //::SireVol::Space::toString
        
            typedef ::QString ( ::SireVol::Space::*toString_function_type)(  ) const;
            toString_function_type toString_function_value( &::SireVol::Space::toString );
            
            Space_exposer.def( 
                "toString"
                , toString_function_value
                , bp::release_gil_policy()
                , "Return a string representation of this space" );
        
        }
        { //::SireVol::Space::typeName
        
            typedef char const * ( *typeName_function_type )(  );
            typeName_function_type typeName_function_value( &::SireVol::Space::typeName );
            
            Space_exposer.def( 
                "typeName"
                , typeName_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireVol::Space::volume
        
            typedef ::SireUnits::Dimension::Volume ( ::SireVol::Space::*volume_function_type)(  ) const;
            volume_function_type volume_function_value( &::SireVol::Space::volume );
            
            Space_exposer.def( 
                "volume"
                , volume_function_value
                , bp::release_gil_policy()
                , "Return the volume of the central box of this space. This\nthrows an exception if it is not possible to calculate the\nvolume of this space (e.g. it is an infinite space)" );
        
        }
        Space_exposer.staticmethod( "null" );
        Space_exposer.staticmethod( "typeName" );
        Space_exposer.def( "__rlshift__", &__rlshift__QDataStream< ::SireVol::Space >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        Space_exposer.def( "__rrshift__", &__rrshift__QDataStream< ::SireVol::Space >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        Space_exposer.def_pickle(sire_pickle_suite< ::SireVol::Space >());
        Space_exposer.def( "__str__", &__str__< ::SireVol::Space > );
        Space_exposer.def( "__repr__", &__str__< ::SireVol::Space > );
    }

}
