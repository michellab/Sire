// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 2 License

#include "boost/python.hpp"
#include "Helpers/clone_const_reference.hpp"
#include "SymbolExpression.pypp.hpp"

namespace bp = boost::python;

#include "function.h"

#include "symbol.h"

#include "symbolexpression.h"

#include <boost/assert.hpp>

#include "symbolexpression.h"

SireCAS::SymbolExpression __copy__(const SireCAS::SymbolExpression &other){ return SireCAS::SymbolExpression(other); }

const char* pvt_get_name(const SireCAS::SymbolExpression&){ return "SireCAS::SymbolExpression";}

#include "Helpers/release_gil_policy.hpp"

void register_SymbolExpression_class(){

    { //::SireCAS::SymbolExpression
        typedef bp::class_< SireCAS::SymbolExpression > SymbolExpression_exposer_t;
        SymbolExpression_exposer_t SymbolExpression_exposer = SymbolExpression_exposer_t( "SymbolExpression", "Small class that holds a SymbolID number and an associated expression", bp::init< SireCAS::ExpressionBase const &, SireCAS::Expression const & >(( bp::arg("symbol"), bp::arg("expression") ), "") );
        bp::scope SymbolExpression_scope( SymbolExpression_exposer );
        { //::SireCAS::SymbolExpression::expression
        
            typedef ::SireCAS::Expression const & ( ::SireCAS::SymbolExpression::*expression_function_type)(  ) const;
            expression_function_type expression_function_value( &::SireCAS::SymbolExpression::expression );
            
            SymbolExpression_exposer.def( 
                "expression"
                , expression_function_value
                , bp::return_value_policy< bp::copy_const_reference >()
                , "" );
        
        }
        { //::SireCAS::SymbolExpression::function
        
            typedef ::SireCAS::Function const & ( ::SireCAS::SymbolExpression::*function_function_type)(  ) const;
            function_function_type function_function_value( &::SireCAS::SymbolExpression::function );
            
            SymbolExpression_exposer.def( 
                "function"
                , function_function_value
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Return the symbol as a function - this is only safe\nif isFunction() returns true" );
        
        }
        { //::SireCAS::SymbolExpression::isFunction
        
            typedef bool ( ::SireCAS::SymbolExpression::*isFunction_function_type)(  ) const;
            isFunction_function_type isFunction_function_value( &::SireCAS::SymbolExpression::isFunction );
            
            SymbolExpression_exposer.def( 
                "isFunction"
                , isFunction_function_value
                , bp::release_gil_policy()
                , "Return whether or not this is a function" );
        
        }
        { //::SireCAS::SymbolExpression::symbol
        
            typedef ::SireCAS::Symbol const & ( ::SireCAS::SymbolExpression::*symbol_function_type)(  ) const;
            symbol_function_type symbol_function_value( &::SireCAS::SymbolExpression::symbol );
            
            SymbolExpression_exposer.def( 
                "symbol"
                , symbol_function_value
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Return the symbol" );
        
        }
        SymbolExpression_exposer.def( "__copy__", &__copy__);
        SymbolExpression_exposer.def( "__deepcopy__", &__copy__);
        SymbolExpression_exposer.def( "clone", &__copy__);
        SymbolExpression_exposer.def( "__str__", &pvt_get_name);
        SymbolExpression_exposer.def( "__repr__", &pvt_get_name);
    }

}
