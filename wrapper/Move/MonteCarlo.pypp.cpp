// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 2 License

#include "boost/python.hpp"
#include "MonteCarlo.pypp.hpp"

namespace bp = boost::python;

#include "SireFF/forcefields.h"

#include "SireStream/datastream.h"

#include "SireStream/shareddatastream.h"

#include "SireUnits/temperature.h"

#include "SireUnits/units.h"

#include "montecarlo.h"

#include <QDebug>

#include <cmath>

#include "montecarlo.h"

#include "Qt/qdatastream.hpp"

#include "Helpers/str.hpp"

#include "Helpers/release_gil_policy.hpp"

void register_MonteCarlo_class(){

    { //::SireMove::MonteCarlo
        typedef bp::class_< SireMove::MonteCarlo, bp::bases< SireMove::Move, SireBase::Property >, boost::noncopyable > MonteCarlo_exposer_t;
        MonteCarlo_exposer_t MonteCarlo_exposer = MonteCarlo_exposer_t( "MonteCarlo", "This is the base class of all Monte Carlo moves\n\nAuthor: Christopher Woods\n", bp::no_init );
        bp::scope MonteCarlo_scope( MonteCarlo_exposer );
        { //::SireMove::MonteCarlo::acceptanceRatio
        
            typedef double ( ::SireMove::MonteCarlo::*acceptanceRatio_function_type)(  ) const;
            acceptanceRatio_function_type acceptanceRatio_function_value( &::SireMove::MonteCarlo::acceptanceRatio );
            
            MonteCarlo_exposer.def( 
                "acceptanceRatio"
                , acceptanceRatio_function_value
                , bp::release_gil_policy()
                , "Return the acceptance ratio (ratio of\naccepted moves to attempted moves)" );
        
        }
        { //::SireMove::MonteCarlo::clearStatistics
        
            typedef void ( ::SireMove::MonteCarlo::*clearStatistics_function_type)(  ) ;
            clearStatistics_function_type clearStatistics_function_value( &::SireMove::MonteCarlo::clearStatistics );
            
            MonteCarlo_exposer.def( 
                "clearStatistics"
                , clearStatistics_function_value
                , bp::release_gil_policy()
                , "Zero the move statistics" );
        
        }
        { //::SireMove::MonteCarlo::disableOptimisedMoves
        
            typedef void ( ::SireMove::MonteCarlo::*disableOptimisedMoves_function_type)(  ) ;
            disableOptimisedMoves_function_type disableOptimisedMoves_function_value( &::SireMove::MonteCarlo::disableOptimisedMoves );
            
            MonteCarlo_exposer.def( 
                "disableOptimisedMoves"
                , disableOptimisedMoves_function_value
                , bp::release_gil_policy()
                , "Turn off use of optimised MC moves. This uses slightly slower, but likely\nless buggy code, and is worth using if you suspect there are problems with\nthe optimised code" );
        
        }
        { //::SireMove::MonteCarlo::enableOptimisedMoves
        
            typedef void ( ::SireMove::MonteCarlo::*enableOptimisedMoves_function_type)(  ) ;
            enableOptimisedMoves_function_type enableOptimisedMoves_function_value( &::SireMove::MonteCarlo::enableOptimisedMoves );
            
            MonteCarlo_exposer.def( 
                "enableOptimisedMoves"
                , enableOptimisedMoves_function_value
                , bp::release_gil_policy()
                , "Turn on use of optimised MC moves. This turns on newer (and potentially more buggy)\ncode that aims to speed up the memory allocation and energy calculation for\nMC moves." );
        
        }
        { //::SireMove::MonteCarlo::ensemble
        
            typedef ::SireMove::Ensemble ( ::SireMove::MonteCarlo::*ensemble_function_type)(  ) const;
            ensemble_function_type ensemble_function_value( &::SireMove::MonteCarlo::ensemble );
            
            MonteCarlo_exposer.def( 
                "ensemble"
                , ensemble_function_value
                , bp::release_gil_policy()
                , "Return the ensemble for this move" );
        
        }
        { //::SireMove::MonteCarlo::generator
        
            typedef ::SireMaths::RanGenerator const & ( ::SireMove::MonteCarlo::*generator_function_type)(  ) const;
            generator_function_type generator_function_value( &::SireMove::MonteCarlo::generator );
            
            MonteCarlo_exposer.def( 
                "generator"
                , generator_function_value
                , bp::return_value_policy< bp::copy_const_reference >()
                , "Return the random number generator used for these moves" );
        
        }
        { //::SireMove::MonteCarlo::nAccepted
        
            typedef ::quint32 ( ::SireMove::MonteCarlo::*nAccepted_function_type)(  ) const;
            nAccepted_function_type nAccepted_function_value( &::SireMove::MonteCarlo::nAccepted );
            
            MonteCarlo_exposer.def( 
                "nAccepted"
                , nAccepted_function_value
                , bp::release_gil_policy()
                , "Return the number of accepted moves" );
        
        }
        { //::SireMove::MonteCarlo::nAttempted
        
            typedef ::quint32 ( ::SireMove::MonteCarlo::*nAttempted_function_type)(  ) const;
            nAttempted_function_type nAttempted_function_value( &::SireMove::MonteCarlo::nAttempted );
            
            MonteCarlo_exposer.def( 
                "nAttempted"
                , nAttempted_function_value
                , bp::release_gil_policy()
                , "Return the number of attempted moves" );
        
        }
        { //::SireMove::MonteCarlo::nMoves
        
            typedef int ( ::SireMove::MonteCarlo::*nMoves_function_type)(  ) const;
            nMoves_function_type nMoves_function_value( &::SireMove::MonteCarlo::nMoves );
            
            MonteCarlo_exposer.def( 
                "nMoves"
                , nMoves_function_value
                , bp::release_gil_policy()
                , "Return the total number of these moves that have been performed" );
        
        }
        { //::SireMove::MonteCarlo::nRejected
        
            typedef ::quint32 ( ::SireMove::MonteCarlo::*nRejected_function_type)(  ) const;
            nRejected_function_type nRejected_function_value( &::SireMove::MonteCarlo::nRejected );
            
            MonteCarlo_exposer.def( 
                "nRejected"
                , nRejected_function_value
                , bp::release_gil_policy()
                , "Return the number of rejected moves" );
        
        }
        { //::SireMove::MonteCarlo::setGenerator
        
            typedef void ( ::SireMove::MonteCarlo::*setGenerator_function_type)( ::SireMaths::RanGenerator const & ) ;
            setGenerator_function_type setGenerator_function_value( &::SireMove::MonteCarlo::setGenerator );
            
            MonteCarlo_exposer.def( 
                "setGenerator"
                , setGenerator_function_value
                , ( bp::arg("generator") )
                , bp::release_gil_policy()
                , "Set the random number generator to use for these moves" );
        
        }
        { //::SireMove::MonteCarlo::setUseOptimisedMoves
        
            typedef void ( ::SireMove::MonteCarlo::*setUseOptimisedMoves_function_type)( bool ) ;
            setUseOptimisedMoves_function_type setUseOptimisedMoves_function_value( &::SireMove::MonteCarlo::setUseOptimisedMoves );
            
            MonteCarlo_exposer.def( 
                "setUseOptimisedMoves"
                , setUseOptimisedMoves_function_value
                , ( bp::arg("on") )
                , bp::release_gil_policy()
                , "Switch on or off use of the optimised MC code" );
        
        }
        { //::SireMove::MonteCarlo::typeName
        
            typedef char const * ( *typeName_function_type )(  );
            typeName_function_type typeName_function_value( &::SireMove::MonteCarlo::typeName );
            
            MonteCarlo_exposer.def( 
                "typeName"
                , typeName_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireMove::MonteCarlo::usingOptimisedMoves
        
            typedef bool ( ::SireMove::MonteCarlo::*usingOptimisedMoves_function_type)(  ) const;
            usingOptimisedMoves_function_type usingOptimisedMoves_function_value( &::SireMove::MonteCarlo::usingOptimisedMoves );
            
            MonteCarlo_exposer.def( 
                "usingOptimisedMoves"
                , usingOptimisedMoves_function_value
                , bp::release_gil_policy()
                , "Return whether or not the optimised MC code is being used" );
        
        }
        MonteCarlo_exposer.staticmethod( "typeName" );
        MonteCarlo_exposer.def( "__rlshift__", &__rlshift__QDataStream< ::SireMove::MonteCarlo >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        MonteCarlo_exposer.def( "__rrshift__", &__rrshift__QDataStream< ::SireMove::MonteCarlo >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        MonteCarlo_exposer.def_pickle(sire_pickle_suite< ::SireMove::MonteCarlo >());
        MonteCarlo_exposer.def( "__str__", &__str__< ::SireMove::MonteCarlo > );
        MonteCarlo_exposer.def( "__repr__", &__str__< ::SireMove::MonteCarlo > );
    }

}
