// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 2 License

#include "boost/python.hpp"
#include "HMCVelGen.pypp.hpp"

namespace bp = boost::python;

#include "SireMol/atomelements.h"

#include "SireMol/atommasses.h"

#include "SireMol/atomvelocities.h"

#include "SireStream/datastream.h"

#include "SireStream/shareddatastream.h"

#include "SireUnits/temperature.h"

#include "SireUnits/units.h"

#include "hybridmc.h"

#include <QDebug>

#include "hybridmc.h"

#include "Qt/qdatastream.hpp"

#include "Helpers/str.hpp"

#include "Helpers/release_gil_policy.hpp"

void register_HMCVelGen_class(){

    { //::SireMove::HMCVelGen
        typedef bp::class_< SireMove::HMCVelGen, bp::bases< SireMove::VelocityGenerator, SireBase::Property >, boost::noncopyable > HMCVelGen_exposer_t;
        HMCVelGen_exposer_t HMCVelGen_exposer = HMCVelGen_exposer_t( "HMCVelGen", "This class provides the base class of an extension\nof the velocity generator that generates velocities\nin such a way that the bias can be\ncalculated and accounted for within the hybrid MC move\n\nAuthor: Christopher Woods\n", bp::no_init );
        bp::scope HMCVelGen_scope( HMCVelGen_exposer );
        { //::SireMove::HMCVelGen::generate
        
            typedef double ( ::SireMove::HMCVelGen::*generate_function_type)( ::SireSystem::System const &,::SireMove::MolecularDynamics & ) ;
            generate_function_type generate_function_value( &::SireMove::HMCVelGen::generate );
            
            HMCVelGen_exposer.def( 
                "generate"
                , generate_function_value
                , ( bp::arg("system"), bp::arg("md") )
                , bp::release_gil_policy()
                , "Generate the velocites in the passed MD object,\nreturning the biasing factor for the HMC algorithm" );
        
        }
        { //::SireMove::HMCVelGen::getBias
        
            typedef double ( ::SireMove::HMCVelGen::*getBias_function_type)( ::SireMove::MolecularDynamics const & ) ;
            getBias_function_type getBias_function_value( &::SireMove::HMCVelGen::getBias );
            
            HMCVelGen_exposer.def( 
                "getBias"
                , getBias_function_value
                , ( bp::arg("md") )
                , bp::release_gil_policy()
                , "Return the bias for the velocities in the passed MD object" );
        
        }
        { //::SireMove::HMCVelGen::setGenerator
        
            typedef void ( ::SireMove::HMCVelGen::*setGenerator_function_type)( ::SireMaths::RanGenerator const & ) ;
            setGenerator_function_type setGenerator_function_value( &::SireMove::HMCVelGen::setGenerator );
            
            HMCVelGen_exposer.def( 
                "setGenerator"
                , setGenerator_function_value
                , ( bp::arg("generator") )
                , bp::release_gil_policy()
                , "Set the random number generator used to generate the random\nnumbers needed by this generator" );
        
        }
        { //::SireMove::HMCVelGen::setTemperature
        
            typedef void ( ::SireMove::HMCVelGen::*setTemperature_function_type)( ::SireUnits::Dimension::Temperature ) ;
            setTemperature_function_type setTemperature_function_value( &::SireMove::HMCVelGen::setTemperature );
            
            HMCVelGen_exposer.def( 
                "setTemperature"
                , setTemperature_function_value
                , ( bp::arg("temperature") )
                , bp::release_gil_policy()
                , "Set the temperature of the velocities to be generated" );
        
        }
        { //::SireMove::HMCVelGen::temperature
        
            typedef ::SireUnits::Dimension::Temperature ( ::SireMove::HMCVelGen::*temperature_function_type)(  ) const;
            temperature_function_type temperature_function_value( &::SireMove::HMCVelGen::temperature );
            
            HMCVelGen_exposer.def( 
                "temperature"
                , temperature_function_value
                , bp::release_gil_policy()
                , "Return the temperature of the velocities to be generated" );
        
        }
        HMCVelGen_exposer.def( "__rlshift__", &__rlshift__QDataStream< ::SireMove::HMCVelGen >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        HMCVelGen_exposer.def( "__rrshift__", &__rrshift__QDataStream< ::SireMove::HMCVelGen >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        HMCVelGen_exposer.def_pickle(sire_pickle_suite< ::SireMove::HMCVelGen >());
        HMCVelGen_exposer.def( "__str__", &__str__< ::SireMove::HMCVelGen > );
        HMCVelGen_exposer.def( "__repr__", &__str__< ::SireMove::HMCVelGen > );
    }

}
