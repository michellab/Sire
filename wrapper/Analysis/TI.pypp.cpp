// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 2 License

#include "boost/python.hpp"
#include "TI.pypp.hpp"

namespace bp = boost::python;

#include "SireError/errors.h"

#include "SireID/index.h"

#include "SireStream/datastream.h"

#include "SireStream/registeralternativename.h"

#include "SireStream/shareddatastream.h"

#include "ti.h"

#include "tostring.h"

#include <cmath>

#include "ti.h"

SireAnalysis::TI __copy__(const SireAnalysis::TI &other){ return SireAnalysis::TI(other); }

#include "Qt/qdatastream.hpp"

#include "Helpers/str.hpp"

#include "Helpers/release_gil_policy.hpp"

#include "Helpers/len.hpp"

void register_TI_class(){

    { //::SireAnalysis::TI
        typedef bp::class_< SireAnalysis::TI, bp::bases< SireBase::Property > > TI_exposer_t;
        TI_exposer_t TI_exposer = TI_exposer_t( "TI", "This class is used to analyse the free energies that are\ncalculated during a thermodynamic integration simulation\n\nAuthor: Christopher Woods\n", bp::init< >("Null constructor") );
        bp::scope TI_scope( TI_exposer );
        TI_exposer.def( bp::init< SireAnalysis::Gradients const & >(( bp::arg("gradients") ), "Construct from the passed set of gradients") );
        TI_exposer.def( bp::init< QList< SireAnalysis::Gradients > const & >(( bp::arg("gradients") ), "Construct from the passed list of gradients from each iteration") );
        TI_exposer.def( bp::init< SireAnalysis::TI const & >(( bp::arg("other") ), "Copy constructor") );
        { //::SireAnalysis::TI::add
        
            typedef void ( ::SireAnalysis::TI::*add_function_type)( ::QMap< double, SireMaths::AverageAndStddev > const & ) ;
            add_function_type add_function_value( &::SireAnalysis::TI::add );
            
            TI_exposer.def( 
                "add"
                , add_function_value
                , ( bp::arg("gradients") )
                , bp::release_gil_policy()
                , "Add the passed free energy gradients to the TI calculation. The gradients\nare in a dictionary, indexed by lambda value, and are analytic TI gradients" );
        
        }
        { //::SireAnalysis::TI::add
        
            typedef void ( ::SireAnalysis::TI::*add_function_type)( ::QMap< double, SireMaths::FreeEnergyAverage > const & ) ;
            add_function_type add_function_value( &::SireAnalysis::TI::add );
            
            TI_exposer.def( 
                "add"
                , add_function_value
                , ( bp::arg("gradients") )
                , bp::release_gil_policy()
                , "Add the passed free energy gradients to the TI calculation. The gradients\nare in a dictionary, indexed by lambda value, and are pure TI gradients,\ni.e. they have been calculated exactly with an infinitesimal delta lambda" );
        
        }
        { //::SireAnalysis::TI::add
        
            typedef void ( ::SireAnalysis::TI::*add_function_type)( ::QMap< double, SireMaths::FreeEnergyAverage > const &,double ) ;
            add_function_type add_function_value( &::SireAnalysis::TI::add );
            
            TI_exposer.def( 
                "add"
                , add_function_value
                , ( bp::arg("gradients"), bp::arg("delta_lambda") )
                , bp::release_gil_policy()
                , "Add the passed free energy gradients to the TI calcualtion. The gradients\nare in a dictionary, indexed by lambda value, and are the raw free energies\ncalculated via the zwanzig equation as part of a finite-difference TI calculation.\nThe value of delta lambda used must also be passed (so that we can then divide\neach gradient by delta lambda to get an approximation of the gradient)" );
        
        }
        { //::SireAnalysis::TI::add
        
            typedef void ( ::SireAnalysis::TI::*add_function_type)( ::QMap< double, SireMaths::FreeEnergyAverage > const &,::QMap< double, SireMaths::FreeEnergyAverage > const &,double ) ;
            add_function_type add_function_value( &::SireAnalysis::TI::add );
            
            TI_exposer.def( 
                "add"
                , add_function_value
                , ( bp::arg("forwards"), bp::arg("backwards"), bp::arg("delta_lambda") )
                , bp::release_gil_policy()
                , "Add the passed free energy gradients to the TI calculation. The gradients\nare in dictionaries, indexed by lambda values, and are the raw forwards and\nbackwards free energies calculated via the zwanzig equation as part of\na finite-difference TI calculation (backwards gradients calculated as the\nfree energy from lambda-delta_lambda -> lambda, while forwards gradients calculated as the\ndifference between lambda -> lambda+delta_lambda). The value of delta lambda\nmust be passed (so that we can then divide each gradient by delta lambda to get\nan approximation of the true gradient)" );
        
        }
        { //::SireAnalysis::TI::add
        
            typedef void ( ::SireAnalysis::TI::*add_function_type)( ::SireAnalysis::Gradients const & ) ;
            add_function_type add_function_value( &::SireAnalysis::TI::add );
            
            TI_exposer.def( 
                "add"
                , add_function_value
                , ( bp::arg("gradients") )
                , bp::release_gil_policy()
                , "Add the passed free energy gradients to the TI calculation. The gradients\nare in a dictionary, indexed by lambda value, and are analytic TI gradients" );
        
        }
        { //::SireAnalysis::TI::at
        
            typedef ::SireAnalysis::Gradients ( ::SireAnalysis::TI::*at_function_type)( int ) const;
            at_function_type at_function_value( &::SireAnalysis::TI::at );
            
            TI_exposer.def( 
                "at"
                , at_function_value
                , ( bp::arg("i") )
                , bp::release_gil_policy()
                , "Return the free energy gradient data for the ith iteration. This returns\na tuple of the forwards gradients, backwards gradients and the value\nof delta lambda. Note that for pure TI calculations, the forwards and\nbackwards gradients will be equal and the value of delta lambda will be 0" );
        
        }
        { //::SireAnalysis::TI::clear
        
            typedef void ( ::SireAnalysis::TI::*clear_function_type)(  ) ;
            clear_function_type clear_function_value( &::SireAnalysis::TI::clear );
            
            TI_exposer.def( 
                "clear"
                , clear_function_value
                , bp::release_gil_policy()
                , "Remove all values from the histogram" );
        
        }
        { //::SireAnalysis::TI::count
        
            typedef int ( ::SireAnalysis::TI::*count_function_type)(  ) const;
            count_function_type count_function_value( &::SireAnalysis::TI::count );
            
            TI_exposer.def( 
                "count"
                , count_function_value
                , bp::release_gil_policy()
                , "Return the number of iterations" );
        
        }
        { //::SireAnalysis::TI::gradients
        
            typedef ::QList< SireAnalysis::Gradients > ( ::SireAnalysis::TI::*gradients_function_type)(  ) const;
            gradients_function_type gradients_function_value( &::SireAnalysis::TI::gradients );
            
            TI_exposer.def( 
                "gradients"
                , gradients_function_value
                , bp::release_gil_policy()
                , "Return the raw list of gradients" );
        
        }
        { //::SireAnalysis::TI::lambdaValues
        
            typedef ::QList< double > ( ::SireAnalysis::TI::*lambdaValues_function_type)(  ) const;
            lambdaValues_function_type lambdaValues_function_value( &::SireAnalysis::TI::lambdaValues );
            
            TI_exposer.def( 
                "lambdaValues"
                , lambdaValues_function_value
                , bp::release_gil_policy()
                , "Return all values of lambda that have data. The values are returned\nin numerical order" );
        
        }
        { //::SireAnalysis::TI::merge
        
            typedef ::SireAnalysis::Gradients ( ::SireAnalysis::TI::*merge_function_type)( int,int ) const;
            merge_function_type merge_function_value( &::SireAnalysis::TI::merge );
            
            TI_exposer.def( 
                "merge"
                , merge_function_value
                , ( bp::arg("start"), bp::arg("end") )
                , bp::release_gil_policy()
                , "Merge (average) together the gradients from iteration start to iteration\nend inclusive" );
        
        }
        { //::SireAnalysis::TI::merge
        
            typedef ::SireAnalysis::Gradients ( ::SireAnalysis::TI::*merge_function_type)( ::QList< int > ) const;
            merge_function_type merge_function_value( &::SireAnalysis::TI::merge );
            
            TI_exposer.def( 
                "merge"
                , merge_function_value
                , ( bp::arg("indicies") )
                , bp::release_gil_policy()
                , "Merge together the gradients from the iterations with the passed indicies" );
        
        }
        { //::SireAnalysis::TI::nIterations
        
            typedef int ( ::SireAnalysis::TI::*nIterations_function_type)(  ) const;
            nIterations_function_type nIterations_function_value( &::SireAnalysis::TI::nIterations );
            
            TI_exposer.def( 
                "nIterations"
                , nIterations_function_value
                , bp::release_gil_policy()
                , "Return the number of iterations (number of sets of gradients that have been added)" );
        
        }
        { //::SireAnalysis::TI::nLambdaValues
        
            typedef int ( ::SireAnalysis::TI::*nLambdaValues_function_type)(  ) const;
            nLambdaValues_function_type nLambdaValues_function_value( &::SireAnalysis::TI::nLambdaValues );
            
            TI_exposer.def( 
                "nLambdaValues"
                , nLambdaValues_function_value
                , bp::release_gil_policy()
                , "Return the number of lambda values" );
        
        }
        { //::SireAnalysis::TI::nSamples
        
            typedef ::qint64 ( ::SireAnalysis::TI::*nSamples_function_type)(  ) const;
            nSamples_function_type nSamples_function_value( &::SireAnalysis::TI::nSamples );
            
            TI_exposer.def( 
                "nSamples"
                , nSamples_function_value
                , bp::release_gil_policy()
                , "Return the total number of samples in this calculation" );
        
        }
        TI_exposer.def( bp::self != bp::self );
        { //::SireAnalysis::TI::operator=
        
            typedef ::SireAnalysis::TI & ( ::SireAnalysis::TI::*assign_function_type)( ::SireAnalysis::TI const & ) ;
            assign_function_type assign_function_value( &::SireAnalysis::TI::operator= );
            
            TI_exposer.def( 
                "assign"
                , assign_function_value
                , ( bp::arg("other") )
                , bp::return_self< >()
                , "" );
        
        }
        TI_exposer.def( bp::self == bp::self );
        { //::SireAnalysis::TI::operator[]
        
            typedef ::SireAnalysis::Gradients ( ::SireAnalysis::TI::*__getitem___function_type)( int ) const;
            __getitem___function_type __getitem___function_value( &::SireAnalysis::TI::operator[] );
            
            TI_exposer.def( 
                "__getitem__"
                , __getitem___function_value
                , ( bp::arg("i") )
                , "" );
        
        }
        { //::SireAnalysis::TI::removeAt
        
            typedef void ( ::SireAnalysis::TI::*removeAt_function_type)( int ) ;
            removeAt_function_type removeAt_function_value( &::SireAnalysis::TI::removeAt );
            
            TI_exposer.def( 
                "removeAt"
                , removeAt_function_value
                , ( bp::arg("i") )
                , bp::release_gil_policy()
                , "Remove the data for iteration i. This sets the data equal to Gradients()" );
        
        }
        { //::SireAnalysis::TI::removeRange
        
            typedef void ( ::SireAnalysis::TI::*removeRange_function_type)( int,int ) ;
            removeRange_function_type removeRange_function_value( &::SireAnalysis::TI::removeRange );
            
            TI_exposer.def( 
                "removeRange"
                , removeRange_function_value
                , ( bp::arg("start"), bp::arg("end") )
                , bp::release_gil_policy()
                , "Remove every iteration from start to end (inclusively). This sets\nthe data equal to Gradients()" );
        
        }
        { //::SireAnalysis::TI::rollingAverage
        
            typedef ::QList< SireAnalysis::Gradients > ( ::SireAnalysis::TI::*rollingAverage_function_type)( int ) const;
            rollingAverage_function_type rollingAverage_function_value( &::SireAnalysis::TI::rollingAverage );
            
            TI_exposer.def( 
                "rollingAverage"
                , rollingAverage_function_value
                , ( bp::arg("niterations") )
                , bp::release_gil_policy()
                , "Return a list of Gradients that represents the rolling average over niterations\niterations over this TI data set. If this data set contains 100 iterations, and\nwe calculate the rolling average over 50 iterations, then the returned Gradients\nwill be the average from 1-50, then 2-51, 3-52.....51-100" );
        
        }
        { //::SireAnalysis::TI::set
        
            typedef void ( ::SireAnalysis::TI::*set_function_type)( int,::QMap< double, SireMaths::AverageAndStddev > const & ) ;
            set_function_type set_function_value( &::SireAnalysis::TI::set );
            
            TI_exposer.def( 
                "set"
                , set_function_value
                , ( bp::arg("i"), bp::arg("gradients") )
                , bp::release_gil_policy()
                , "Set the gradients for the ith iteration equal to gradients. These\nare analytic TI gradients" );
        
        }
        { //::SireAnalysis::TI::set
        
            typedef void ( ::SireAnalysis::TI::*set_function_type)( int,::QMap< double, SireMaths::FreeEnergyAverage > const & ) ;
            set_function_type set_function_value( &::SireAnalysis::TI::set );
            
            TI_exposer.def( 
                "set"
                , set_function_value
                , ( bp::arg("i"), bp::arg("gradients") )
                , bp::release_gil_policy()
                , "Set the gradients for the ith iteration equal to gradients. These\nmust be pure TI gradients, with no associated delta lambda value" );
        
        }
        { //::SireAnalysis::TI::set
        
            typedef void ( ::SireAnalysis::TI::*set_function_type)( int,::QMap< double, SireMaths::FreeEnergyAverage > const &,double ) ;
            set_function_type set_function_value( &::SireAnalysis::TI::set );
            
            TI_exposer.def( 
                "set"
                , set_function_value
                , ( bp::arg("i"), bp::arg("gradients"), bp::arg("delta_lambda") )
                , bp::release_gil_policy()
                , "Set the gradients for the ith iteration equal to gradients. These\nare finite difference TI gradients, which are the raw zwanzig\nfree energies together with the passed value of delta lambda" );
        
        }
        { //::SireAnalysis::TI::set
        
            typedef void ( ::SireAnalysis::TI::*set_function_type)( int,::QMap< double, SireMaths::FreeEnergyAverage > const &,::QMap< double, SireMaths::FreeEnergyAverage > const &,double ) ;
            set_function_type set_function_value( &::SireAnalysis::TI::set );
            
            TI_exposer.def( 
                "set"
                , set_function_value
                , ( bp::arg("i"), bp::arg("forwards"), bp::arg("backwards"), bp::arg("delta_lambda") )
                , bp::release_gil_policy()
                , "Set the gradients for the ith iteration to the passed forwards\nand backwards finite difference TI values (together with associated\ndelta lambda). The forwards gradients should be the raw zwanzig\nvalues from lambda -> lambda+delta_lambda, while the backwards\ngradients should be the raw zwanzig values from lambda-delta_lambda -> lambda" );
        
        }
        { //::SireAnalysis::TI::set
        
            typedef void ( ::SireAnalysis::TI::*set_function_type)( int,::SireAnalysis::Gradients const & ) ;
            set_function_type set_function_value( &::SireAnalysis::TI::set );
            
            TI_exposer.def( 
                "set"
                , set_function_value
                , ( bp::arg("i"), bp::arg("gradients") )
                , bp::release_gil_policy()
                , "Set the gradients for the ith iteration equal to gradients. These\nare analytic TI gradients" );
        
        }
        { //::SireAnalysis::TI::size
        
            typedef int ( ::SireAnalysis::TI::*size_function_type)(  ) const;
            size_function_type size_function_value( &::SireAnalysis::TI::size );
            
            TI_exposer.def( 
                "size"
                , size_function_value
                , bp::release_gil_policy()
                , "Return the number of iterations" );
        
        }
        { //::SireAnalysis::TI::toString
        
            typedef ::QString ( ::SireAnalysis::TI::*toString_function_type)(  ) const;
            toString_function_type toString_function_value( &::SireAnalysis::TI::toString );
            
            TI_exposer.def( 
                "toString"
                , toString_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireAnalysis::TI::typeName
        
            typedef char const * ( *typeName_function_type )(  );
            typeName_function_type typeName_function_value( &::SireAnalysis::TI::typeName );
            
            TI_exposer.def( 
                "typeName"
                , typeName_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireAnalysis::TI::what
        
            typedef char const * ( ::SireAnalysis::TI::*what_function_type)(  ) const;
            what_function_type what_function_value( &::SireAnalysis::TI::what );
            
            TI_exposer.def( 
                "what"
                , what_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        TI_exposer.staticmethod( "typeName" );
        TI_exposer.def( "__copy__", &__copy__);
        TI_exposer.def( "__deepcopy__", &__copy__);
        TI_exposer.def( "clone", &__copy__);
        TI_exposer.def( "__rlshift__", &__rlshift__QDataStream< ::SireAnalysis::TI >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        TI_exposer.def( "__rrshift__", &__rrshift__QDataStream< ::SireAnalysis::TI >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        TI_exposer.def_pickle(sire_pickle_suite< ::SireAnalysis::TI >());
        TI_exposer.def( "__str__", &__str__< ::SireAnalysis::TI > );
        TI_exposer.def( "__repr__", &__str__< ::SireAnalysis::TI > );
        TI_exposer.def( "__len__", &__len_size< ::SireAnalysis::TI > );
    }

}
