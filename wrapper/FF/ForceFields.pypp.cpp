// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 2 License

#include "boost/python.hpp"
#include "Helpers/clone_const_reference.hpp"
#include "ForceFields.pypp.hpp"

namespace bp = boost::python;

#include "SireBase/combineproperties.h"

#include "SireBase/errors.h"

#include "SireBase/linktoproperty.h"

#include "SireCAS/identities.h"

#include "SireError/errors.h"

#include "SireFF/errors.h"

#include "SireMol/errors.h"

#include "SireMol/mgidx.h"

#include "SireMol/mgnum.h"

#include "SireMol/molecule.h"

#include "SireMol/moleculegroup.h"

#include "SireMol/molecules.h"

#include "SireMol/moleculeview.h"

#include "SireMol/partialmolecule.h"

#include "SireMol/viewsofmol.h"

#include "SireStream/datastream.h"

#include "SireStream/shareddatastream.h"

#include "energytable.h"

#include "ff3d.h"

#include "ffidx.h"

#include "ffname.h"

#include "fieldtable.h"

#include "forcefields.h"

#include "forcetable.h"

#include "potentialtable.h"

#include "probe.h"

#include "tostring.h"

#include <QDebug>

#include <QSet>

#include <QTime>

#include <boost/shared_ptr.hpp>

#include <tbb/tbb.h>

#include "forcefields.h"

#include "forcetable.h"

#include "energytable.h"

SireFF::ForceFields __copy__(const SireFF::ForceFields &other){ return SireFF::ForceFields(other); }

#include "Qt/qdatastream.hpp"

#include "Helpers/str.hpp"

#include "Helpers/release_gil_policy.hpp"

#include "Helpers/len.hpp"

void register_ForceFields_class(){

    { //::SireFF::ForceFields
        typedef bp::class_< SireFF::ForceFields, bp::bases< SireMol::MolGroupsBase, SireBase::Property > > ForceFields_exposer_t;
        ForceFields_exposer_t ForceFields_exposer = ForceFields_exposer_t( "ForceFields", "A ForceFields object contains a collection of forcefields,\ntogether with energy functions that allow energiesforces\nof a combination of forcefield components to be evaluated.\n\nAuthor: Christopher Woods\n", bp::init< >("Constructor") );
        bp::scope ForceFields_scope( ForceFields_exposer );
        ForceFields_exposer.def( bp::init< SireFF::FF const & >(( bp::arg("forcefield") ), "Construct a group that holds just a single forcefield") );
        ForceFields_exposer.def( bp::init< QList< SireBase::PropPtr< SireFF::FF > > const & >(( bp::arg("forcefields") ), "Construct a group that holds lots of forcefields") );
        ForceFields_exposer.def( bp::init< QVector< SireBase::PropPtr< SireFF::FF > > const & >(( bp::arg("forcefields") ), "Construct a group that holds lots of forcefields") );
        ForceFields_exposer.def( bp::init< SireFF::ForceFields const & >(( bp::arg("other") ), "Copy constructor") );
        { //::SireFF::ForceFields::accept
        
            typedef void ( ::SireFF::ForceFields::*accept_function_type)(  ) ;
            accept_function_type accept_function_value( &::SireFF::ForceFields::accept );
            
            ForceFields_exposer.def( 
                "accept"
                , accept_function_value
                , bp::release_gil_policy()
                , "Ensure that any forcefields that are using temporary workspace have that accepted" );
        
        }
        { //::SireFF::ForceFields::add
        
            typedef void ( ::SireFF::ForceFields::*add_function_type)( ::SireFF::FF const & ) ;
            add_function_type add_function_value( &::SireFF::ForceFields::add );
            
            ForceFields_exposer.def( 
                "add"
                , add_function_value
                , ( bp::arg("forcefield") )
                , bp::release_gil_policy()
                , "Add the forcefield forcefield to this set. This will raise\nan exception if this forcefield (or one with the same name)\nis already present in this set. Note that if the added\nforcefield will be updated to contain the versions of\nany molecules that are already present in any of the\nother forcefields.\nThrow: SireFF::duplicate_forcefield\nThrow: SireMol::duplicate_group\n" );
        
        }
        { //::SireFF::ForceFields::add
        
            typedef void ( ::SireFF::ForceFields::*add_function_type)( ::SireMol::MoleculeView const &,::SireMol::MGID const &,::SireBase::PropertyMap const & ) ;
            add_function_type add_function_value( &::SireFF::ForceFields::add );
            
            ForceFields_exposer.def( 
                "add"
                , add_function_value
                , ( bp::arg("molview"), bp::arg("mgid"), bp::arg("map") )
                , bp::release_gil_policy()
                , "Add the molecule view molview to the molecule groups identified\nby mgid, using the supplied property map to find the properties\nrequired for the forcefield\nThrow: SireMol::missing_group\nThrow: SireBase::missing_parameter\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireFF::ForceFields::add
        
            typedef void ( ::SireFF::ForceFields::*add_function_type)( ::SireMol::ViewsOfMol const &,::SireMol::MGID const &,::SireBase::PropertyMap const & ) ;
            add_function_type add_function_value( &::SireFF::ForceFields::add );
            
            ForceFields_exposer.def( 
                "add"
                , add_function_value
                , ( bp::arg("molviews"), bp::arg("mgid"), bp::arg("map") )
                , bp::release_gil_policy()
                , "Add the views of the molecule in molviews to the molecule groups identified\nby mgid, using the supplied property map to find the properties\nrequired for the forcefield\nThrow: SireMol::missing_group\nThrow: SireBase::missing_parameter\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireFF::ForceFields::add
        
            typedef void ( ::SireFF::ForceFields::*add_function_type)( ::SireMol::Molecules const &,::SireMol::MGID const &,::SireBase::PropertyMap const & ) ;
            add_function_type add_function_value( &::SireFF::ForceFields::add );
            
            ForceFields_exposer.def( 
                "add"
                , add_function_value
                , ( bp::arg("molecules"), bp::arg("mgid"), bp::arg("map") )
                , bp::release_gil_policy()
                , "Add the molecules in molecules to the molecule groups identified\nby mgid, using the supplied property map to find the properties\nrequired for the forcefield\nThrow: SireMol::missing_group\nThrow: SireBase::missing_parameter\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireFF::ForceFields::add
        
            typedef void ( ::SireFF::ForceFields::*add_function_type)( ::SireMol::MoleculeGroup const &,::SireMol::MGID const &,::SireBase::PropertyMap const & ) ;
            add_function_type add_function_value( &::SireFF::ForceFields::add );
            
            ForceFields_exposer.def( 
                "add"
                , add_function_value
                , ( bp::arg("molgroup"), bp::arg("mgid"), bp::arg("map") )
                , bp::release_gil_policy()
                , "Add the molecules in the molecule group molgroup to the molecule\ngroups identified by mgid, using the supplied property map to find the\nproperties required for the forcefield\nThrow: SireMol::missing_group\nThrow: SireBase::missing_parameter\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireFF::ForceFields::add
        
            typedef void ( ::SireFF::ForceFields::*add_function_type)( ::SireMol::MoleculeView const &,::SireMol::MGID const & ) ;
            add_function_type add_function_value( &::SireFF::ForceFields::add );
            
            ForceFields_exposer.def( 
                "add"
                , add_function_value
                , ( bp::arg("molview"), bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Add the molecule view molview to the molecule groups identified\nby mgid, using the default locations to find any properties\nrequired by the forcefields.\nThrow: SireMol::missing_group\nThrow: SireBase::missing_parameter\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireFF::ForceFields::add
        
            typedef void ( ::SireFF::ForceFields::*add_function_type)( ::SireMol::ViewsOfMol const &,::SireMol::MGID const & ) ;
            add_function_type add_function_value( &::SireFF::ForceFields::add );
            
            ForceFields_exposer.def( 
                "add"
                , add_function_value
                , ( bp::arg("molviews"), bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Add the molecule views in molviews to the molecule groups identified\nby mgid, using the supplied property map to find the properties\nrequired for the forcefield\nThrow: SireMol::missing_group\nThrow: SireBase::missing_parameter\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireFF::ForceFields::add
        
            typedef void ( ::SireFF::ForceFields::*add_function_type)( ::SireMol::Molecules const &,::SireMol::MGID const & ) ;
            add_function_type add_function_value( &::SireFF::ForceFields::add );
            
            ForceFields_exposer.def( 
                "add"
                , add_function_value
                , ( bp::arg("molecules"), bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Add the molecules in molecules to the molecule groups identified\nby mgid, using the supplied property map to find the properties\nrequired for the forcefield\nThrow: SireMol::missing_group\nThrow: SireBase::missing_parameter\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireFF::ForceFields::add
        
            typedef void ( ::SireFF::ForceFields::*add_function_type)( ::SireMol::MoleculeGroup const &,::SireMol::MGID const & ) ;
            add_function_type add_function_value( &::SireFF::ForceFields::add );
            
            ForceFields_exposer.def( 
                "add"
                , add_function_value
                , ( bp::arg("molgroup"), bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Add the molecules in the molecule group molgroup to the molecule\ngroups identified by mgid, using the supplied property map to\nfind the properties required for the forcefield\nThrow: SireMol::missing_group\nThrow: SireBase::missing_parameter\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireFF::ForceFields::addIfUnique
        
            typedef void ( ::SireFF::ForceFields::*addIfUnique_function_type)( ::SireMol::MoleculeView const &,::SireMol::MGID const &,::SireBase::PropertyMap const & ) ;
            addIfUnique_function_type addIfUnique_function_value( &::SireFF::ForceFields::addIfUnique );
            
            ForceFields_exposer.def( 
                "addIfUnique"
                , addIfUnique_function_value
                , ( bp::arg("molview"), bp::arg("mgid"), bp::arg("map") )
                , bp::release_gil_policy()
                , "Add the molecule view molview to the molecule groups identified\nby mgid, using the supplied property map to find the properties\nrequired for the forcefield. This only adds the view to groups\nthat dont already contain this view.\nThrow: SireMol::missing_group\nThrow: SireBase::missing_parameter\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireFF::ForceFields::addIfUnique
        
            typedef void ( ::SireFF::ForceFields::*addIfUnique_function_type)( ::SireMol::ViewsOfMol const &,::SireMol::MGID const &,::SireBase::PropertyMap const & ) ;
            addIfUnique_function_type addIfUnique_function_value( &::SireFF::ForceFields::addIfUnique );
            
            ForceFields_exposer.def( 
                "addIfUnique"
                , addIfUnique_function_value
                , ( bp::arg("molviews"), bp::arg("mgid"), bp::arg("map") )
                , bp::release_gil_policy()
                , "Add the molecule views in molviews to the molecule groups identified\nby mgid, using the supplied property map to find the properties\nrequired for the forcefield. This only adds the view to groups\nthat dont already contain this view.\nThrow: SireMol::missing_group\nThrow: SireBase::missing_parameter\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireFF::ForceFields::addIfUnique
        
            typedef void ( ::SireFF::ForceFields::*addIfUnique_function_type)( ::SireMol::Molecules const &,::SireMol::MGID const &,::SireBase::PropertyMap const & ) ;
            addIfUnique_function_type addIfUnique_function_value( &::SireFF::ForceFields::addIfUnique );
            
            ForceFields_exposer.def( 
                "addIfUnique"
                , addIfUnique_function_value
                , ( bp::arg("molecules"), bp::arg("mgid"), bp::arg("map") )
                , bp::release_gil_policy()
                , "Add the molecules in molecules to the molecule groups identified\nby mgid, using the supplied property map to find the properties\nrequired for the forcefield. This only adds the view to groups\nthat dont already contain this view.\nThrow: SireMol::missing_group\nThrow: SireBase::missing_parameter\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireFF::ForceFields::addIfUnique
        
            typedef void ( ::SireFF::ForceFields::*addIfUnique_function_type)( ::SireMol::MoleculeGroup const &,::SireMol::MGID const &,::SireBase::PropertyMap const & ) ;
            addIfUnique_function_type addIfUnique_function_value( &::SireFF::ForceFields::addIfUnique );
            
            ForceFields_exposer.def( 
                "addIfUnique"
                , addIfUnique_function_value
                , ( bp::arg("molgroup"), bp::arg("mgid"), bp::arg("map") )
                , bp::release_gil_policy()
                , "Add the molecules in the molecule group molgroup to the molecule\ngroups identified by mgid, using the supplied property map to\nfind the properties required for the forcefield. This only adds the\nview to groups that dont already contain this view.\nThrow: SireMol::missing_group\nThrow: SireBase::missing_parameter\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireFF::ForceFields::addIfUnique
        
            typedef void ( ::SireFF::ForceFields::*addIfUnique_function_type)( ::SireMol::MoleculeView const &,::SireMol::MGID const & ) ;
            addIfUnique_function_type addIfUnique_function_value( &::SireFF::ForceFields::addIfUnique );
            
            ForceFields_exposer.def( 
                "addIfUnique"
                , addIfUnique_function_value
                , ( bp::arg("molview"), bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Add the molecule view molview to the molecule groups identified\nby mgid, using the supplied property map to find the properties\nrequired for the forcefield. Only views that arent already in\nthe forcefield are added.\nThrow: SireMol::missing_group\nThrow: SireBase::missing_parameter\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireFF::ForceFields::addIfUnique
        
            typedef void ( ::SireFF::ForceFields::*addIfUnique_function_type)( ::SireMol::ViewsOfMol const &,::SireMol::MGID const & ) ;
            addIfUnique_function_type addIfUnique_function_value( &::SireFF::ForceFields::addIfUnique );
            
            ForceFields_exposer.def( 
                "addIfUnique"
                , addIfUnique_function_value
                , ( bp::arg("molviews"), bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Add the molecule views in molviews to the molecule groups identified\nby mgid, using the supplied property map to find the properties\nrequired for the forcefield. Only views that arent already in\nthe forcefield are added.\nThrow: SireMol::missing_group\nThrow: SireBase::missing_parameter\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireFF::ForceFields::addIfUnique
        
            typedef void ( ::SireFF::ForceFields::*addIfUnique_function_type)( ::SireMol::Molecules const &,::SireMol::MGID const & ) ;
            addIfUnique_function_type addIfUnique_function_value( &::SireFF::ForceFields::addIfUnique );
            
            ForceFields_exposer.def( 
                "addIfUnique"
                , addIfUnique_function_value
                , ( bp::arg("molecules"), bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Add the molecules in molecules to the molecule groups identified\nby mgid, using the supplied property map to find the properties\nrequired for the forcefield. Only views that arent already in\nthe forcefield are added.\nThrow: SireMol::missing_group\nThrow: SireBase::missing_parameter\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireFF::ForceFields::addIfUnique
        
            typedef void ( ::SireFF::ForceFields::*addIfUnique_function_type)( ::SireMol::MoleculeGroup const &,::SireMol::MGID const & ) ;
            addIfUnique_function_type addIfUnique_function_value( &::SireFF::ForceFields::addIfUnique );
            
            ForceFields_exposer.def( 
                "addIfUnique"
                , addIfUnique_function_value
                , ( bp::arg("molgroup"), bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Add the molecules in the molecule group molgroup to the molecule\ngroups identified by mgid, using the supplied property map to\nfind the properties required for the forcefield. Only views that\narent already in the forcefield are added.\nThrow: SireMol::missing_group\nThrow: SireBase::missing_parameter\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireFF::ForceFields::at
        
            typedef ::SireFF::FF const & ( ::SireFF::ForceFields::*at_function_type)( ::SireFF::FFName const & ) const;
            at_function_type at_function_value( &::SireFF::ForceFields::at );
            
            ForceFields_exposer.def( 
                "at"
                , at_function_value
                , ( bp::arg("ffname") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Return the forcefield with name ffname\nThrow: SireFF::missing_forcefield\n" );
        
        }
        { //::SireFF::ForceFields::at
        
            typedef ::SireFF::FF const & ( ::SireFF::ForceFields::*at_function_type)( ::SireFF::FFIdx const & ) const;
            at_function_type at_function_value( &::SireFF::ForceFields::at );
            
            ForceFields_exposer.def( 
                "at"
                , at_function_value
                , ( bp::arg("ffidx") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Return the forcefield at index ffidx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireFF::ForceFields::at
        
            typedef ::SireFF::FF const & ( ::SireFF::ForceFields::*at_function_type)( ::SireFF::FFID const & ) const;
            at_function_type at_function_value( &::SireFF::ForceFields::at );
            
            ForceFields_exposer.def( 
                "at"
                , at_function_value
                , ( bp::arg("ffid") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Return the forcefield with ID ffid\nThrow: SireFF::missing_forcefield\nThrow: SireFF::duplicate_forcefield\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireFF::ForceFields::at
        
            typedef ::SireMol::MoleculeGroup const & ( ::SireFF::ForceFields::*at_function_type)( ::SireMol::MGNum ) const;
            at_function_type at_function_value( &::SireFF::ForceFields::at );
            
            ForceFields_exposer.def( 
                "at"
                , at_function_value
                , ( bp::arg("mgnum") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "overloading MolGroupsBase virtual functions" );
        
        }
        { //::SireFF::ForceFields::builtinProperties
        
            typedef ::SireBase::Properties ( ::SireFF::ForceFields::*builtinProperties_function_type)(  ) const;
            builtinProperties_function_type builtinProperties_function_value( &::SireFF::ForceFields::builtinProperties );
            
            ForceFields_exposer.def( 
                "builtinProperties"
                , builtinProperties_function_value
                , bp::release_gil_policy()
                , "Return all of the built-in properties of the forcefields in this set" );
        
        }
        { //::SireFF::ForceFields::builtinProperty
        
            typedef ::SireBase::Property const & ( ::SireFF::ForceFields::*builtinProperty_function_type)( ::QString const & ) const;
            builtinProperty_function_type builtinProperty_function_value( &::SireFF::ForceFields::builtinProperty );
            
            ForceFields_exposer.def( 
                "builtinProperty"
                , builtinProperty_function_value
                , ( bp::arg("name") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Return the built-in property at name. This will by-pass any\nuser-supplied property with this name, and will raise an\nexception if there is no built-in property with this name\nThrow: SireBase::missing_property\n" );
        
        }
        { //::SireFF::ForceFields::componentExpression
        
            typedef ::SireCAS::Expression ( ::SireFF::ForceFields::*componentExpression_function_type)( ::SireCAS::Symbol const & ) const;
            componentExpression_function_type componentExpression_function_value( &::SireFF::ForceFields::componentExpression );
            
            ForceFields_exposer.def( 
                "componentExpression"
                , componentExpression_function_value
                , ( bp::arg("symbol") )
                , bp::release_gil_policy()
                , "Return the expression for the constant or energy component\nrepresented by symbol\nThrow: SireFF::missing_component\n" );
        
        }
        { //::SireFF::ForceFields::componentExpressions
        
            typedef ::QHash< SireCAS::Symbol, SireCAS::Expression > ( ::SireFF::ForceFields::*componentExpressions_function_type)( ::QSet< SireCAS::Symbol > const & ) const;
            componentExpressions_function_type componentExpressions_function_value( &::SireFF::ForceFields::componentExpressions );
            
            ForceFields_exposer.def( 
                "componentExpressions"
                , componentExpressions_function_value
                , ( bp::arg("symbols") )
                , bp::release_gil_policy()
                , "Return all of the expressions for the constant or energy\ncomponents whose symbols are in symbols\nThrow: SireFF::missing_component\n" );
        
        }
        { //::SireFF::ForceFields::componentExpressions
        
            typedef ::QHash< SireCAS::Symbol, SireCAS::Expression > ( ::SireFF::ForceFields::*componentExpressions_function_type)(  ) const;
            componentExpressions_function_type componentExpressions_function_value( &::SireFF::ForceFields::componentExpressions );
            
            ForceFields_exposer.def( 
                "componentExpressions"
                , componentExpressions_function_value
                , bp::release_gil_policy()
                , "Return all of the constant and energy expressions attached\nto these forcefields" );
        
        }
        { //::SireFF::ForceFields::componentSymbols
        
            typedef ::QSet< SireCAS::Symbol > ( ::SireFF::ForceFields::*componentSymbols_function_type)(  ) const;
            componentSymbols_function_type componentSymbols_function_value( &::SireFF::ForceFields::componentSymbols );
            
            ForceFields_exposer.def( 
                "componentSymbols"
                , componentSymbols_function_value
                , bp::release_gil_policy()
                , "Return the symbols representing all of the constant and energy components" );
        
        }
        { //::SireFF::ForceFields::componentValue
        
            typedef double ( ::SireFF::ForceFields::*componentValue_function_type)( ::SireCAS::Symbol const & ) ;
            componentValue_function_type componentValue_function_value( &::SireFF::ForceFields::componentValue );
            
            ForceFields_exposer.def( 
                "componentValue"
                , componentValue_function_value
                , ( bp::arg("symbol") )
                , bp::release_gil_policy()
                , "Return the energy or constant component associated with the symbol symbol\nThrow: SireFF::missing_component\n" );
        
        }
        { //::SireFF::ForceFields::componentValues
        
            typedef ::SireCAS::Values ( ::SireFF::ForceFields::*componentValues_function_type)( ::QSet< SireCAS::Symbol > const & ) ;
            componentValues_function_type componentValues_function_value( &::SireFF::ForceFields::componentValues );
            
            ForceFields_exposer.def( 
                "componentValues"
                , componentValues_function_value
                , ( bp::arg("symbols") )
                , bp::release_gil_policy()
                , "Return the values of the energy or constant components whose\nsymbols are in symbols\nThrow: SireFF::missing_component\n" );
        
        }
        { //::SireFF::ForceFields::componentValues
        
            typedef ::SireCAS::Values ( ::SireFF::ForceFields::*componentValues_function_type)(  ) ;
            componentValues_function_type componentValues_function_value( &::SireFF::ForceFields::componentValues );
            
            ForceFields_exposer.def( 
                "componentValues"
                , componentValues_function_value
                , bp::release_gil_policy()
                , "Return the values of all energy and constant components" );
        
        }
        { //::SireFF::ForceFields::compoundProperty
        
            typedef ::SireBase::Property const & ( ::SireFF::ForceFields::*compoundProperty_function_type)( ::QString const & ) const;
            compoundProperty_function_type compoundProperty_function_value( &::SireFF::ForceFields::compoundProperty );
            
            ForceFields_exposer.def( 
                "compoundProperty"
                , compoundProperty_function_value
                , ( bp::arg("name") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Return the raw compound property with name name - this returns\nthe property representing the link, or the combined property,\nand raises an exception if a compound property with this name\ndoes not exist\nThrow: SireBase::missing_property\n" );
        
        }
        { //::SireFF::ForceFields::constant
        
            typedef double ( ::SireFF::ForceFields::*constant_function_type)( ::SireCAS::Symbol const & ) const;
            constant_function_type constant_function_value( &::SireFF::ForceFields::constant );
            
            ForceFields_exposer.def( 
                "constant"
                , constant_function_value
                , ( bp::arg("component") )
                , bp::release_gil_policy()
                , "Return the value associated with the constant component component\nThrow: SireFF::missing_component\n" );
        
        }
        { //::SireFF::ForceFields::constantComponents
        
            typedef ::SireCAS::Values ( ::SireFF::ForceFields::*constantComponents_function_type)(  ) const;
            constantComponents_function_type constantComponents_function_value( &::SireFF::ForceFields::constantComponents );
            
            ForceFields_exposer.def( 
                "constantComponents"
                , constantComponents_function_value
                , bp::release_gil_policy()
                , "Synonym for ForceFields::constants()" );
        
        }
        { //::SireFF::ForceFields::constantExpression
        
            typedef ::SireCAS::Expression ( ::SireFF::ForceFields::*constantExpression_function_type)( ::SireCAS::Symbol const & ) const;
            constantExpression_function_type constantExpression_function_value( &::SireFF::ForceFields::constantExpression );
            
            ForceFields_exposer.def( 
                "constantExpression"
                , constantExpression_function_value
                , ( bp::arg("symbol") )
                , bp::release_gil_policy()
                , "Return the expression for the constant component symbol\nThrow: SireFF::missing_component\n" );
        
        }
        { //::SireFF::ForceFields::constantExpressions
        
            typedef ::QHash< SireCAS::Symbol, SireCAS::Expression > ( ::SireFF::ForceFields::*constantExpressions_function_type)( ::QSet< SireCAS::Symbol > const & ) const;
            constantExpressions_function_type constantExpressions_function_value( &::SireFF::ForceFields::constantExpressions );
            
            ForceFields_exposer.def( 
                "constantExpressions"
                , constantExpressions_function_value
                , ( bp::arg("symbols") )
                , bp::release_gil_policy()
                , "Return the expressions for the constant components in symbols\nThrow: SireFF::missing_component\n" );
        
        }
        { //::SireFF::ForceFields::constantExpressions
        
            typedef ::QHash< SireCAS::Symbol, SireCAS::Expression > ( ::SireFF::ForceFields::*constantExpressions_function_type)(  ) const;
            constantExpressions_function_type constantExpressions_function_value( &::SireFF::ForceFields::constantExpressions );
            
            ForceFields_exposer.def( 
                "constantExpressions"
                , constantExpressions_function_value
                , bp::release_gil_policy()
                , "Return all of the constant expressions in the forcefields" );
        
        }
        { //::SireFF::ForceFields::constantSymbols
        
            typedef ::QSet< SireCAS::Symbol > ( ::SireFF::ForceFields::*constantSymbols_function_type)(  ) const;
            constantSymbols_function_type constantSymbols_function_value( &::SireFF::ForceFields::constantSymbols );
            
            ForceFields_exposer.def( 
                "constantSymbols"
                , constantSymbols_function_value
                , bp::release_gil_policy()
                , "Return the symbols representing the constant forcefield components" );
        
        }
        { //::SireFF::ForceFields::constants
        
            typedef ::SireCAS::Values ( ::SireFF::ForceFields::*constants_function_type)(  ) const;
            constants_function_type constants_function_value( &::SireFF::ForceFields::constants );
            
            ForceFields_exposer.def( 
                "constants"
                , constants_function_value
                , bp::release_gil_policy()
                , "Return the values of all constant components in the forcefields" );
        
        }
        { //::SireFF::ForceFields::constants
        
            typedef ::SireCAS::Values ( ::SireFF::ForceFields::*constants_function_type)( ::QSet< SireCAS::Symbol > const & ) const;
            constants_function_type constants_function_value( &::SireFF::ForceFields::constants );
            
            ForceFields_exposer.def( 
                "constants"
                , constants_function_value
                , ( bp::arg("components") )
                , bp::release_gil_policy()
                , "Return the constant values associated with the constant components\nin components\nThrow: SireFF::missing_component\n" );
        
        }
        { //::SireFF::ForceFields::containsProperty
        
            typedef bool ( ::SireFF::ForceFields::*containsProperty_function_type)( ::QString const & ) const;
            containsProperty_function_type containsProperty_function_value( &::SireFF::ForceFields::containsProperty );
            
            ForceFields_exposer.def( 
                "containsProperty"
                , containsProperty_function_value
                , ( bp::arg("name") )
                , bp::release_gil_policy()
                , "Return whether or not any of the forcefields contain the property\nwith name name" );
        
        }
        { //::SireFF::ForceFields::containsProperty
        
            typedef bool ( ::SireFF::ForceFields::*containsProperty_function_type)( ::SireFF::FFID const &,::QString const & ) const;
            containsProperty_function_type containsProperty_function_value( &::SireFF::ForceFields::containsProperty );
            
            ForceFields_exposer.def( 
                "containsProperty"
                , containsProperty_function_value
                , ( bp::arg("ffid"), bp::arg("name") )
                , bp::release_gil_policy()
                , "Return whether or not any of the forcefields that match the ID ffid\ncontain the property with name name\nNote that because this operates on the level of individual forcefields,\nit can only return built-in properties, and ignores any\nuser-supplied properties\nThrow: SireFF::missing_forcefield\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireFF::ForceFields::containsProperty
        
            typedef bool ( ::SireFF::ForceFields::*containsProperty_function_type)( ::SireBase::PropertyName const & ) const;
            containsProperty_function_type containsProperty_function_value( &::SireFF::ForceFields::containsProperty );
            
            ForceFields_exposer.def( 
                "containsProperty"
                , containsProperty_function_value
                , ( bp::arg("name") )
                , bp::release_gil_policy()
                , "Return whether or not any of the forcefields contain the property\nwith name name" );
        
        }
        { //::SireFF::ForceFields::containsProperty
        
            typedef bool ( ::SireFF::ForceFields::*containsProperty_function_type)( ::SireFF::FFID const &,::SireBase::PropertyName const & ) const;
            containsProperty_function_type containsProperty_function_value( &::SireFF::ForceFields::containsProperty );
            
            ForceFields_exposer.def( 
                "containsProperty"
                , containsProperty_function_value
                , ( bp::arg("ffid"), bp::arg("name") )
                , bp::release_gil_policy()
                , "Return whether or not any of the forcefields that match the ID ffid\ncontain the property with name name\nNote that because this operates on the level of individual forcefields,\nit can only return built-in properties, and ignores any\nuser-supplied properties\nThrow: SireFF::missing_forcefield\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireFF::ForceFields::energies
        
            typedef ::SireCAS::Values ( ::SireFF::ForceFields::*energies_function_type)(  ) ;
            energies_function_type energies_function_value( &::SireFF::ForceFields::energies );
            
            ForceFields_exposer.def( 
                "energies"
                , energies_function_value
                , bp::release_gil_policy()
                , "Return the energies of all of the energy components of all of the forcefields,\nconstants and expressions" );
        
        }
        { //::SireFF::ForceFields::energies
        
            typedef ::SireCAS::Values ( ::SireFF::ForceFields::*energies_function_type)( ::QSet< SireCAS::Symbol > const & ) ;
            energies_function_type energies_function_value( &::SireFF::ForceFields::energies );
            
            ForceFields_exposer.def( 
                "energies"
                , energies_function_value
                , ( bp::arg("components") )
                , bp::release_gil_policy()
                , "Return the energies of all of the energy components whose symbols are\nlisted in components\nThrow: SireFF::missing_component\n" );
        
        }
        { //::SireFF::ForceFields::energy
        
            typedef ::SireUnits::Dimension::MolarEnergy ( ::SireFF::ForceFields::*energy_function_type)(  ) ;
            energy_function_type energy_function_value( &::SireFF::ForceFields::energy );
            
            ForceFields_exposer.def( 
                "energy"
                , energy_function_value
                , bp::release_gil_policy()
                , "Return the energy of this set of forcefields. This uses the supplied\ntotal energy function to calculate the energy, if one exists,\nor it just calculates the sum of the total energies of all of the\ncontained forcefields" );
        
        }
        { //::SireFF::ForceFields::energy
        
            typedef ::SireUnits::Dimension::MolarEnergy ( ::SireFF::ForceFields::*energy_function_type)( ::SireCAS::Symbol const & ) ;
            energy_function_type energy_function_value( &::SireFF::ForceFields::energy );
            
            ForceFields_exposer.def( 
                "energy"
                , energy_function_value
                , ( bp::arg("component") )
                , bp::release_gil_policy()
                , "Return the energy associated with the symbol component. This component\nmay either be a component of one of the constituent forcefields,\nor it may represent a function of the forcefield components\nThrow: SireFF::missing_component\n" );
        
        }
        { //::SireFF::ForceFields::energy
        
            typedef void ( ::SireFF::ForceFields::*energy_function_type)( ::SireFF::EnergyTable &,double ) ;
            energy_function_type energy_function_value( &::SireFF::ForceFields::energy );
            
            ForceFields_exposer.def( 
                "energy"
                , energy_function_value
                , ( bp::arg("energytable"), bp::arg("scale_energy")=1 )
                , "Add the energies due to the forcefields in this set to the molecules\nin the energy table energytable, scaled by scale_energy" );
        
        }
        { //::SireFF::ForceFields::energy
        
            typedef void ( ::SireFF::ForceFields::*energy_function_type)( ::SireFF::EnergyTable &,::SireCAS::Symbol const &,double ) ;
            energy_function_type energy_function_value( &::SireFF::ForceFields::energy );
            
            ForceFields_exposer.def( 
                "energy"
                , energy_function_value
                , ( bp::arg("energytable"), bp::arg("component"), bp::arg("scale_energy")=1 )
                , "" );
        
        }
        { //::SireFF::ForceFields::energyComponents
        
            typedef ::SireCAS::Values ( ::SireFF::ForceFields::*energyComponents_function_type)(  ) ;
            energyComponents_function_type energyComponents_function_value( &::SireFF::ForceFields::energyComponents );
            
            ForceFields_exposer.def( 
                "energyComponents"
                , energyComponents_function_value
                , bp::release_gil_policy()
                , "Synonym for ForceFields::energies()" );
        
        }
        { //::SireFF::ForceFields::energyExpression
        
            typedef ::SireCAS::Expression ( ::SireFF::ForceFields::*energyExpression_function_type)( ::SireCAS::Symbol const & ) const;
            energyExpression_function_type energyExpression_function_value( &::SireFF::ForceFields::energyExpression );
            
            ForceFields_exposer.def( 
                "energyExpression"
                , energyExpression_function_value
                , ( bp::arg("expression") )
                , bp::release_gil_policy()
                , "Return the energy expression for the symbol component\nThrow: SireFF::missing_component\n" );
        
        }
        { //::SireFF::ForceFields::energyExpressions
        
            typedef ::QHash< SireCAS::Symbol, SireCAS::Expression > ( ::SireFF::ForceFields::*energyExpressions_function_type)( ::QSet< SireCAS::Symbol > const & ) const;
            energyExpressions_function_type energyExpressions_function_value( &::SireFF::ForceFields::energyExpressions );
            
            ForceFields_exposer.def( 
                "energyExpressions"
                , energyExpressions_function_value
                , ( bp::arg("symbols") )
                , bp::release_gil_policy()
                , "Return the energy expressions for the components whose\nsymbols are in symbols\nThrow: SireFF::missing_component\n" );
        
        }
        { //::SireFF::ForceFields::energyExpressions
        
            typedef ::QHash< SireCAS::Symbol, SireCAS::Expression > ( ::SireFF::ForceFields::*energyExpressions_function_type)(  ) const;
            energyExpressions_function_type energyExpressions_function_value( &::SireFF::ForceFields::energyExpressions );
            
            ForceFields_exposer.def( 
                "energyExpressions"
                , energyExpressions_function_value
                , bp::release_gil_policy()
                , "Return all of the energy expressions in this forcefield" );
        
        }
        { //::SireFF::ForceFields::energySymbols
        
            typedef ::QSet< SireCAS::Symbol > ( ::SireFF::ForceFields::*energySymbols_function_type)(  ) const;
            energySymbols_function_type energySymbols_function_value( &::SireFF::ForceFields::energySymbols );
            
            ForceFields_exposer.def( 
                "energySymbols"
                , energySymbols_function_value
                , bp::release_gil_policy()
                , "Return all of the symbols that represent energy components" );
        
        }
        { //::SireFF::ForceFields::ffIdx
        
            typedef ::SireFF::FFIdx ( ::SireFF::ForceFields::*ffIdx_function_type)( ::SireFF::FFName const & ) const;
            ffIdx_function_type ffIdx_function_value( &::SireFF::ForceFields::ffIdx );
            
            ForceFields_exposer.def( 
                "ffIdx"
                , ffIdx_function_value
                , ( bp::arg("ffname") )
                , bp::release_gil_policy()
                , "Return the index of the forcefield with name ffname\nThrow: SireFF::missing_forcefield\nThrow: SireFF::duplicate_forcefield\n" );
        
        }
        { //::SireFF::ForceFields::ffIdx
        
            typedef ::SireFF::FFIdx ( ::SireFF::ForceFields::*ffIdx_function_type)( ::SireFF::FFIdx const & ) const;
            ffIdx_function_type ffIdx_function_value( &::SireFF::ForceFields::ffIdx );
            
            ForceFields_exposer.def( 
                "ffIdx"
                , ffIdx_function_value
                , ( bp::arg("ffidx") )
                , bp::release_gil_policy()
                , "Simple function that allows a shortcut for ffIdx(FFIdx)\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireFF::ForceFields::ffIdx
        
            typedef ::SireFF::FFIdx ( ::SireFF::ForceFields::*ffIdx_function_type)( ::SireFF::FFID const & ) const;
            ffIdx_function_type ffIdx_function_value( &::SireFF::ForceFields::ffIdx );
            
            ForceFields_exposer.def( 
                "ffIdx"
                , ffIdx_function_value
                , ( bp::arg("ffid") )
                , bp::release_gil_policy()
                , "Return the FFIdx of the forcefield that matches the ID ffid\nThrow: SireFF::missing_forcefield\nThrow: SireFF::duplicate_forcefield\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireFF::ForceFields::ffName
        
            typedef ::SireFF::FFName const & ( ::SireFF::ForceFields::*ffName_function_type)( ::SireFF::FFName const & ) const;
            ffName_function_type ffName_function_value( &::SireFF::ForceFields::ffName );
            
            ForceFields_exposer.def( 
                "ffName"
                , ffName_function_value
                , ( bp::arg("ffname") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Simple function that short cuts ffName(FFName)\nThrow: SireFF::missing_forcefield\n" );
        
        }
        { //::SireFF::ForceFields::ffName
        
            typedef ::SireFF::FFName const & ( ::SireFF::ForceFields::*ffName_function_type)( ::SireFF::FFIdx const & ) const;
            ffName_function_type ffName_function_value( &::SireFF::ForceFields::ffName );
            
            ForceFields_exposer.def( 
                "ffName"
                , ffName_function_value
                , ( bp::arg("ffidx") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Return the name of the forcefield at index ffidx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireFF::ForceFields::ffName
        
            typedef ::SireFF::FFName const & ( ::SireFF::ForceFields::*ffName_function_type)( ::SireFF::FFID const & ) const;
            ffName_function_type ffName_function_value( &::SireFF::ForceFields::ffName );
            
            ForceFields_exposer.def( 
                "ffName"
                , ffName_function_value
                , ( bp::arg("ffid") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Return the name of the forcefield that matches the ID ffid\nThrow: SireFF::missing_forcefield\nThrow: SireFF::duplicate_forcefield\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireFF::ForceFields::ffNames
        
            typedef ::QList< SireFF::FFName > ( ::SireFF::ForceFields::*ffNames_function_type)(  ) const;
            ffNames_function_type ffNames_function_value( &::SireFF::ForceFields::ffNames );
            
            ForceFields_exposer.def( 
                "ffNames"
                , ffNames_function_value
                , bp::release_gil_policy()
                , "Return a list of all of the forcefield names, ordered in the same\norder as the forcefields appear in this set" );
        
        }
        { //::SireFF::ForceFields::ffNames
        
            typedef ::QList< SireFF::FFName > ( ::SireFF::ForceFields::*ffNames_function_type)( ::SireFF::FFID const & ) const;
            ffNames_function_type ffNames_function_value( &::SireFF::ForceFields::ffNames );
            
            ForceFields_exposer.def( 
                "ffNames"
                , ffNames_function_value
                , ( bp::arg("ffid") )
                , bp::release_gil_policy()
                , "Return the names of all of the forcefields that match the ID ffid\nThrow: SireFF::missing_forcefield\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireFF::ForceFields::field
        
            typedef void ( ::SireFF::ForceFields::*field_function_type)( ::SireFF::FieldTable &,double ) ;
            field_function_type field_function_value( &::SireFF::ForceFields::field );
            
            ForceFields_exposer.def( 
                "field"
                , field_function_value
                , ( bp::arg("fieldtable"), bp::arg("scale_field")=1 )
                , "Add the fields due to the forcefields in this set to the molecules\nin the field table fieldtable, scaled by scale_field" );
        
        }
        { //::SireFF::ForceFields::field
        
            typedef void ( ::SireFF::ForceFields::*field_function_type)( ::SireFF::FieldTable &,::SireCAS::Symbol const &,double ) ;
            field_function_type field_function_value( &::SireFF::ForceFields::field );
            
            ForceFields_exposer.def( 
                "field"
                , field_function_value
                , ( bp::arg("fieldtable"), bp::arg("component"), bp::arg("scale_field")=1 )
                , "Add the field due to the component component to the molecules\nin the field table fieldtable, scaled by scale_field\nThrow: SireFF::missing_component\n" );
        
        }
        { //::SireFF::ForceFields::field
        
            typedef void ( ::SireFF::ForceFields::*field_function_type)( ::SireFF::FieldTable &,::SireFF::Probe const &,double ) ;
            field_function_type field_function_value( &::SireFF::ForceFields::field );
            
            ForceFields_exposer.def( 
                "field"
                , field_function_value
                , ( bp::arg("fieldtable"), bp::arg("probe"), bp::arg("scale_field")=1 )
                , "Add the fields due to the forcefields in this set to the molecules\nin the field table fieldtable, scaled by scale_field" );
        
        }
        { //::SireFF::ForceFields::field
        
            typedef void ( ::SireFF::ForceFields::*field_function_type)( ::SireFF::FieldTable &,::SireCAS::Symbol const &,::SireFF::Probe const &,double ) ;
            field_function_type field_function_value( &::SireFF::ForceFields::field );
            
            ForceFields_exposer.def( 
                "field"
                , field_function_value
                , ( bp::arg("fieldtable"), bp::arg("component"), bp::arg("probe"), bp::arg("scale_field")=1 )
                , "Add the field due to the component component to the molecules\nin the field table fieldtable, scaled by scale_field\nThrow: SireFF::missing_component\n" );
        
        }
        { //::SireFF::ForceFields::force
        
            typedef void ( ::SireFF::ForceFields::*force_function_type)( ::SireFF::ForceTable &,double ) ;
            force_function_type force_function_value( &::SireFF::ForceFields::force );
            
            ForceFields_exposer.def( 
                "force"
                , force_function_value
                , ( bp::arg("forcetable"), bp::arg("scale_force")=1 )
                , "Add the forces due to the forcefields in this set to the molecules\nin the force table forcetable, scaled by scale_force" );
        
        }
        { //::SireFF::ForceFields::force
        
            typedef void ( ::SireFF::ForceFields::*force_function_type)( ::SireFF::ForceTable &,::SireCAS::Symbol const &,double ) ;
            force_function_type force_function_value( &::SireFF::ForceFields::force );
            
            ForceFields_exposer.def( 
                "force"
                , force_function_value
                , ( bp::arg("forcetable"), bp::arg("component"), bp::arg("scale_force")=1 )
                , "Add the force due to the component component to the molecules\nin the force table forcetable, scaled by scale_force\nThrow: SireFF::missing_component\n" );
        
        }
        { //::SireFF::ForceFields::forceField
        
            typedef ::SireFF::FF const & ( ::SireFF::ForceFields::*forceField_function_type)( ::SireFF::FFName const & ) const;
            forceField_function_type forceField_function_value( &::SireFF::ForceFields::forceField );
            
            ForceFields_exposer.def( 
                "forceField"
                , forceField_function_value
                , ( bp::arg("ffname") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Return the forcefield with name ffname\nThrow: SireFF::missing_forcefield\n" );
        
        }
        { //::SireFF::ForceFields::forceField
        
            typedef ::SireFF::FF const & ( ::SireFF::ForceFields::*forceField_function_type)( ::SireFF::FFIdx const & ) const;
            forceField_function_type forceField_function_value( &::SireFF::ForceFields::forceField );
            
            ForceFields_exposer.def( 
                "forceField"
                , forceField_function_value
                , ( bp::arg("ffidx") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Return the forcefield at index ffidx\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireFF::ForceFields::forceField
        
            typedef ::SireFF::FF const & ( ::SireFF::ForceFields::*forceField_function_type)( ::SireFF::FFID const & ) const;
            forceField_function_type forceField_function_value( &::SireFF::ForceFields::forceField );
            
            ForceFields_exposer.def( 
                "forceField"
                , forceField_function_value
                , ( bp::arg("ffid") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Return the forcefield with ID ffid\nThrow: SireFF::missing_forcefield\nThrow: SireFF::duplicate_forcefield\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireFF::ForceFields::forceField
        
            typedef ::SireFF::FF const & ( ::SireFF::ForceFields::*forceField_function_type)( ::SireMol::MGNum const & ) const;
            forceField_function_type forceField_function_value( &::SireFF::ForceFields::forceField );
            
            ForceFields_exposer.def( 
                "forceField"
                , forceField_function_value
                , ( bp::arg("mgnum") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Return the forcefield that contains the molecule group with\nnumber mgnum\nThrow: SireMol::missing_group\n" );
        
        }
        { //::SireFF::ForceFields::forceFields
        
            typedef ::QVector< SireBase::PropPtr< SireFF::FF > > const & ( ::SireFF::ForceFields::*forceFields_function_type)(  ) const;
            forceFields_function_type forceFields_function_value( &::SireFF::ForceFields::forceFields );
            
            ForceFields_exposer.def( 
                "forceFields"
                , forceFields_function_value
                , bp::return_value_policy< bp::copy_const_reference >()
                , "Return an array containing all of the forcefields in this set, ordered\nin the same order as they appear in this set" );
        
        }
        { //::SireFF::ForceFields::forceFields
        
            typedef ::QVector< SireBase::PropPtr< SireFF::FF > > ( ::SireFF::ForceFields::*forceFields_function_type)( ::SireFF::FFID const & ) const;
            forceFields_function_type forceFields_function_value( &::SireFF::ForceFields::forceFields );
            
            ForceFields_exposer.def( 
                "forceFields"
                , forceFields_function_value
                , ( bp::arg("ffid") )
                , bp::release_gil_policy()
                , "Return the list of all forcefields that match the ID ffid\nThrow: SireFF::missing_forcefield\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireFF::ForceFields::forceFieldsWithProperty
        
            typedef ::QVector< SireBase::PropPtr< SireFF::FF > > ( ::SireFF::ForceFields::*forceFieldsWithProperty_function_type)( ::QString const & ) const;
            forceFieldsWithProperty_function_type forceFieldsWithProperty_function_value( &::SireFF::ForceFields::forceFieldsWithProperty );
            
            ForceFields_exposer.def( 
                "forceFieldsWithProperty"
                , forceFieldsWithProperty_function_value
                , ( bp::arg("name") )
                , bp::release_gil_policy()
                , "Return the list of all forcefields that contain a property with name name\nNote that because this operates on the level of individual forcefields,\nit can only return built-in properties, and ignores any\nuser-supplied properties\nThrow: SireBase::missing_property\n" );
        
        }
        { //::SireFF::ForceFields::forceFieldsWithProperty
        
            typedef ::QVector< SireBase::PropPtr< SireFF::FF > > ( ::SireFF::ForceFields::*forceFieldsWithProperty_function_type)( ::SireFF::FFID const &,::QString const & ) const;
            forceFieldsWithProperty_function_type forceFieldsWithProperty_function_value( &::SireFF::ForceFields::forceFieldsWithProperty );
            
            ForceFields_exposer.def( 
                "forceFieldsWithProperty"
                , forceFieldsWithProperty_function_value
                , ( bp::arg("ffid"), bp::arg("name") )
                , bp::release_gil_policy()
                , "Return the list of forcefields that match the ID ffid and that\ncontain the property with name name\nNote that because this operates on the level of individual forcefields,\nit can only return built-in properties, and ignores any\nuser-supplied properties\nThrow: SireFF::missing_forcefield\nThrow: SireBase::missing_property\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireFF::ForceFields::hasComponent
        
            typedef bool ( ::SireFF::ForceFields::*hasComponent_function_type)( ::SireCAS::Symbol const & ) const;
            hasComponent_function_type hasComponent_function_value( &::SireFF::ForceFields::hasComponent );
            
            ForceFields_exposer.def( 
                "hasComponent"
                , hasComponent_function_value
                , ( bp::arg("symbol") )
                , bp::release_gil_policy()
                , "Return whether or not there is a constant or energy component with symbol symbol" );
        
        }
        { //::SireFF::ForceFields::hasConstantComponent
        
            typedef bool ( ::SireFF::ForceFields::*hasConstantComponent_function_type)( ::SireCAS::Symbol const & ) const;
            hasConstantComponent_function_type hasConstantComponent_function_value( &::SireFF::ForceFields::hasConstantComponent );
            
            ForceFields_exposer.def( 
                "hasConstantComponent"
                , hasConstantComponent_function_value
                , ( bp::arg("component") )
                , bp::release_gil_policy()
                , "Return whether or not there is a constant component in the\nforcefield expressions with symbol component" );
        
        }
        { //::SireFF::ForceFields::hasEnergyComponent
        
            typedef bool ( ::SireFF::ForceFields::*hasEnergyComponent_function_type)( ::SireCAS::Symbol const & ) const;
            hasEnergyComponent_function_type hasEnergyComponent_function_value( &::SireFF::ForceFields::hasEnergyComponent );
            
            ForceFields_exposer.def( 
                "hasEnergyComponent"
                , hasEnergyComponent_function_value
                , ( bp::arg("component") )
                , bp::release_gil_policy()
                , "Return whether or not the forcefields have an energy component\nwith symbol component" );
        
        }
        { //::SireFF::ForceFields::isBuiltinProperty
        
            typedef bool ( ::SireFF::ForceFields::*isBuiltinProperty_function_type)( ::QString const & ) const;
            isBuiltinProperty_function_type isBuiltinProperty_function_value( &::SireFF::ForceFields::isBuiltinProperty );
            
            ForceFields_exposer.def( 
                "isBuiltinProperty"
                , isBuiltinProperty_function_value
                , ( bp::arg("name") )
                , bp::release_gil_policy()
                , "Return whether or not the property name exists and is a builtin\nproperty of one of the forcefields in this set" );
        
        }
        { //::SireFF::ForceFields::isClean
        
            typedef bool ( ::SireFF::ForceFields::*isClean_function_type)(  ) const;
            isClean_function_type isClean_function_value( &::SireFF::ForceFields::isClean );
            
            ForceFields_exposer.def( 
                "isClean"
                , isClean_function_value
                , bp::release_gil_policy()
                , "Return whether or not all of the forcefields in this set are clean\n(there have been no changes since the last energy evaluation)" );
        
        }
        { //::SireFF::ForceFields::isCompoundProperty
        
            typedef bool ( ::SireFF::ForceFields::*isCompoundProperty_function_type)( ::QString const & ) const;
            isCompoundProperty_function_type isCompoundProperty_function_value( &::SireFF::ForceFields::isCompoundProperty );
            
            ForceFields_exposer.def( 
                "isCompoundProperty"
                , isCompoundProperty_function_value
                , ( bp::arg("name") )
                , bp::release_gil_policy()
                , "Return whether or not the property name exists and is a compound\nproperty (either a link or a combined property)" );
        
        }
        { //::SireFF::ForceFields::isConstantComponent
        
            typedef bool ( ::SireFF::ForceFields::*isConstantComponent_function_type)( ::SireCAS::Symbol const & ) const;
            isConstantComponent_function_type isConstantComponent_function_value( &::SireFF::ForceFields::isConstantComponent );
            
            ForceFields_exposer.def( 
                "isConstantComponent"
                , isConstantComponent_function_value
                , ( bp::arg("component") )
                , bp::release_gil_policy()
                , "Return whether or not the forcefield component component\nis a constant component\nThrow: SireFF::missing_component\n" );
        
        }
        { //::SireFF::ForceFields::isDirty
        
            typedef bool ( ::SireFF::ForceFields::*isDirty_function_type)(  ) const;
            isDirty_function_type isDirty_function_value( &::SireFF::ForceFields::isDirty );
            
            ForceFields_exposer.def( 
                "isDirty"
                , isDirty_function_value
                , bp::release_gil_policy()
                , "Return whether or not any of the forcefields in this set are dirty\n(the molecules have changed since the last energy calculation)" );
        
        }
        { //::SireFF::ForceFields::isEnergyComponent
        
            typedef bool ( ::SireFF::ForceFields::*isEnergyComponent_function_type)( ::SireCAS::Symbol const & ) const;
            isEnergyComponent_function_type isEnergyComponent_function_value( &::SireFF::ForceFields::isEnergyComponent );
            
            ForceFields_exposer.def( 
                "isEnergyComponent"
                , isEnergyComponent_function_value
                , ( bp::arg("component") )
                , bp::release_gil_policy()
                , "Return whether or not the forcefield component component\nis an energy component\nThrow: SireFF::missing_component\n" );
        
        }
        { //::SireFF::ForceFields::isUserProperty
        
            typedef bool ( ::SireFF::ForceFields::*isUserProperty_function_type)( ::QString const & ) const;
            isUserProperty_function_type isUserProperty_function_value( &::SireFF::ForceFields::isUserProperty );
            
            ForceFields_exposer.def( 
                "isUserProperty"
                , isUserProperty_function_value
                , ( bp::arg("name") )
                , bp::release_gil_policy()
                , "Return whether or not the property name exists and is a user\nsupplied property (either a compound property or an extra\nForceFields property)" );
        
        }
        { //::SireFF::ForceFields::list
        
            typedef ::QVector< SireBase::PropPtr< SireFF::FF > > const & ( ::SireFF::ForceFields::*list_function_type)(  ) const;
            list_function_type list_function_value( &::SireFF::ForceFields::list );
            
            ForceFields_exposer.def( 
                "list"
                , list_function_value
                , bp::return_value_policy< bp::copy_const_reference >()
                , "Return an array containing all of the forcefields in this set, ordered\nin the same order as they appear in this set" );
        
        }
        { //::SireFF::ForceFields::map
        
            typedef ::QList< SireFF::FFIdx > ( ::SireFF::ForceFields::*map_function_type)( ::SireFF::FFID const & ) const;
            map_function_type map_function_value( &::SireFF::ForceFields::map );
            
            ForceFields_exposer.def( 
                "map"
                , map_function_value
                , ( bp::arg("ffid") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireFF::ForceFields::map
        
            typedef ::QList< SireFF::FFIdx > ( ::SireFF::ForceFields::*map_function_type)( ::SireFF::FFIdx const & ) const;
            map_function_type map_function_value( &::SireFF::ForceFields::map );
            
            ForceFields_exposer.def( 
                "map"
                , map_function_value
                , ( bp::arg("ffidx") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireFF::ForceFields::map
        
            typedef ::QList< SireFF::FFIdx > ( ::SireFF::ForceFields::*map_function_type)( ::SireFF::FFName const & ) const;
            map_function_type map_function_value( &::SireFF::ForceFields::map );
            
            ForceFields_exposer.def( 
                "map"
                , map_function_value
                , ( bp::arg("ffname") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireFF::ForceFields::mustNowRecalculateFromScratch
        
            typedef void ( ::SireFF::ForceFields::*mustNowRecalculateFromScratch_function_type)(  ) ;
            mustNowRecalculateFromScratch_function_type mustNowRecalculateFromScratch_function_value( &::SireFF::ForceFields::mustNowRecalculateFromScratch );
            
            ForceFields_exposer.def( 
                "mustNowRecalculateFromScratch"
                , mustNowRecalculateFromScratch_function_value
                , bp::release_gil_policy()
                , "Tell all of the forcefields that they must now recalculate their\nenergies from scratch. This is a good way to debug the forcefields,\nbut may also speed up cases where you know in advance that you will\nbe moving most (or all) of the molecules between energy calculations" );
        
        }
        { //::SireFF::ForceFields::nForceFields
        
            typedef int ( ::SireFF::ForceFields::*nForceFields_function_type)(  ) const;
            nForceFields_function_type nForceFields_function_value( &::SireFF::ForceFields::nForceFields );
            
            ForceFields_exposer.def( 
                "nForceFields"
                , nForceFields_function_value
                , bp::release_gil_policy()
                , "Return the number of forcefields in this set" );
        
        }
        { //::SireFF::ForceFields::names
        
            typedef ::QList< SireFF::FFName > ( ::SireFF::ForceFields::*names_function_type)(  ) const;
            names_function_type names_function_value( &::SireFF::ForceFields::names );
            
            ForceFields_exposer.def( 
                "names"
                , names_function_value
                , bp::release_gil_policy()
                , "Return a list of all of the forcefield names, ordered in the same\norder as the forcefields appear in this set" );
        
        }
        { //::SireFF::ForceFields::needsAccepting
        
            typedef bool ( ::SireFF::ForceFields::*needsAccepting_function_type)(  ) const;
            needsAccepting_function_type needsAccepting_function_value( &::SireFF::ForceFields::needsAccepting );
            
            ForceFields_exposer.def( 
                "needsAccepting"
                , needsAccepting_function_value
                , bp::release_gil_policy()
                , "Return whether or not these forcefields are using any temporary workspace that needs\nto be accepted" );
        
        }
        ForceFields_exposer.def( bp::self != bp::self );
        { //::SireFF::ForceFields::operator=
        
            typedef ::SireFF::ForceFields & ( ::SireFF::ForceFields::*assign_function_type)( ::SireFF::ForceFields const & ) ;
            assign_function_type assign_function_value( &::SireFF::ForceFields::operator= );
            
            ForceFields_exposer.def( 
                "assign"
                , assign_function_value
                , ( bp::arg("other") )
                , bp::return_self< >()
                , "" );
        
        }
        ForceFields_exposer.def( bp::self == bp::self );
        { //::SireFF::ForceFields::operator[]
        
            typedef ::SireFF::FF const & ( ::SireFF::ForceFields::*__getitem___function_type)( ::SireFF::FFName const & ) const;
            __getitem___function_type __getitem___function_value( &::SireFF::ForceFields::operator[] );
            
            ForceFields_exposer.def( 
                "__getitem__"
                , __getitem___function_value
                , ( bp::arg("ffname") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "" );
        
        }
        { //::SireFF::ForceFields::operator[]
        
            typedef ::SireFF::FF const & ( ::SireFF::ForceFields::*__getitem___function_type)( ::SireFF::FFIdx const & ) const;
            __getitem___function_type __getitem___function_value( &::SireFF::ForceFields::operator[] );
            
            ForceFields_exposer.def( 
                "__getitem__"
                , __getitem___function_value
                , ( bp::arg("ffidx") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "" );
        
        }
        { //::SireFF::ForceFields::operator[]
        
            typedef ::SireFF::FF const & ( ::SireFF::ForceFields::*__getitem___function_type)( ::SireFF::FFID const & ) const;
            __getitem___function_type __getitem___function_value( &::SireFF::ForceFields::operator[] );
            
            ForceFields_exposer.def( 
                "__getitem__"
                , __getitem___function_value
                , ( bp::arg("ffid") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "" );
        
        }
        { //::SireFF::ForceFields::potential
        
            typedef void ( ::SireFF::ForceFields::*potential_function_type)( ::SireFF::PotentialTable &,::SireFF::Probe const &,double ) ;
            potential_function_type potential_function_value( &::SireFF::ForceFields::potential );
            
            ForceFields_exposer.def( 
                "potential"
                , potential_function_value
                , ( bp::arg("pottable"), bp::arg("probe"), bp::arg("scale_potential")=1 )
                , "Add the potential due to the forcefields in this set to the molecules\nin the potential table pottable, scaled by scale_potential" );
        
        }
        { //::SireFF::ForceFields::potential
        
            typedef void ( ::SireFF::ForceFields::*potential_function_type)( ::SireFF::PotentialTable &,::SireCAS::Symbol const &,::SireFF::Probe const &,double ) ;
            potential_function_type potential_function_value( &::SireFF::ForceFields::potential );
            
            ForceFields_exposer.def( 
                "potential"
                , potential_function_value
                , ( bp::arg("pottable"), bp::arg("component"), bp::arg("probe"), bp::arg("scale_potential")=1 )
                , "Add the potential due to the component component to the molecules\nin the potential table pottable, scaled by scale_potential\nThrow: SireFF::missing_component\n" );
        
        }
        { //::SireFF::ForceFields::potential
        
            typedef void ( ::SireFF::ForceFields::*potential_function_type)( ::SireFF::PotentialTable &,double ) ;
            potential_function_type potential_function_value( &::SireFF::ForceFields::potential );
            
            ForceFields_exposer.def( 
                "potential"
                , potential_function_value
                , ( bp::arg("pottable"), bp::arg("scale_potential")=1 )
                , "Add the potential due to the forcefields in this set to the molecules\nin the potential table pottable, scaled by scale_potential" );
        
        }
        { //::SireFF::ForceFields::potential
        
            typedef void ( ::SireFF::ForceFields::*potential_function_type)( ::SireFF::PotentialTable &,::SireCAS::Symbol const &,double ) ;
            potential_function_type potential_function_value( &::SireFF::ForceFields::potential );
            
            ForceFields_exposer.def( 
                "potential"
                , potential_function_value
                , ( bp::arg("pottable"), bp::arg("component"), bp::arg("scale_potential")=1 )
                , "Add the potential due to the component component to the molecules\nin the potential table pottable, scaled by scale_potential\nThrow: SireFF::missing_component\n" );
        
        }
        { //::SireFF::ForceFields::properties
        
            typedef ::SireBase::Properties ( ::SireFF::ForceFields::*properties_function_type)(  ) const;
            properties_function_type properties_function_value( &::SireFF::ForceFields::properties );
            
            ForceFields_exposer.def( 
                "properties"
                , properties_function_value
                , bp::release_gil_policy()
                , "Return all of the properties in all of the forcefields. This will raise\nan error if there are properties with the same name in different\nforcefields that have different values.\nThrow: SireBase::duplicate_property\n" );
        
        }
        { //::SireFF::ForceFields::properties
        
            typedef ::SireBase::Properties ( ::SireFF::ForceFields::*properties_function_type)( ::SireFF::FFID const & ) const;
            properties_function_type properties_function_value( &::SireFF::ForceFields::properties );
            
            ForceFields_exposer.def( 
                "properties"
                , properties_function_value
                , ( bp::arg("ffid") )
                , bp::release_gil_policy()
                , "Return all of the properties in all of the forcefields identified by\nthe ID ffid. This will raise an error if there are properties with\nthe same name in different forcefields that have different values.\nNote that because this operates on the level of individual forcefields,\nit can only return built-in properties, and ignores any\nuser-supplied properties\nThrow: SireBase::duplicate_property\n" );
        
        }
        { //::SireFF::ForceFields::property
        
            typedef ::SireBase::Property const & ( ::SireFF::ForceFields::*property_function_type)( ::QString const & ) const;
            property_function_type property_function_value( &::SireFF::ForceFields::property );
            
            ForceFields_exposer.def( 
                "property"
                , property_function_value
                , ( bp::arg("name") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Return the value of the property with name name. This returns\nthe property if it exists in at least one forcefield, and\nif all occurances of the property have the same value\nThrow: SireBase::duplicate_property\nThrow: SireBase::missing_property\n" );
        
        }
        { //::SireFF::ForceFields::property
        
            typedef ::SireBase::Property const & ( ::SireFF::ForceFields::*property_function_type)( ::SireFF::FFID const &,::QString const & ) const;
            property_function_type property_function_value( &::SireFF::ForceFields::property );
            
            ForceFields_exposer.def( 
                "property"
                , property_function_value
                , ( bp::arg("ffid"), bp::arg("name") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Return the value of the property name in the forcefields identified\nby the ID ffid\nNote that because this operates on the level of individual forcefields,\nit can only return built-in properties, and ignores any\nuser-supplied properties\nThrow: SireBase::duplicate_property\nThrow: SireFF::missing_forcefield\nThrow: SireFF::duplicate_forcefield\nThrow: SireBase::missing_property\n" );
        
        }
        { //::SireFF::ForceFields::propertyKeys
        
            typedef ::QStringList ( ::SireFF::ForceFields::*propertyKeys_function_type)(  ) const;
            propertyKeys_function_type propertyKeys_function_value( &::SireFF::ForceFields::propertyKeys );
            
            ForceFields_exposer.def( 
                "propertyKeys"
                , propertyKeys_function_value
                , bp::release_gil_policy()
                , "Return the names of all of the properties in all of the forcefields" );
        
        }
        { //::SireFF::ForceFields::propertyKeys
        
            typedef ::QStringList ( ::SireFF::ForceFields::*propertyKeys_function_type)( ::SireFF::FFID const & ) const;
            propertyKeys_function_type propertyKeys_function_value( &::SireFF::ForceFields::propertyKeys );
            
            ForceFields_exposer.def( 
                "propertyKeys"
                , propertyKeys_function_value
                , ( bp::arg("ffid") )
                , bp::release_gil_policy()
                , "Return the names of all of the properties in the forcefields\nidentified by the ID ffid\nNote that because this operates on the level of individual forcefields,\nit can only return built-in properties, and ignores any\nuser-supplied properties\nThrow: SireFF::missing_forcefield\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireFF::ForceFields::remove
        
            typedef void ( ::SireFF::ForceFields::*remove_function_type)( ::SireFF::FFIdx const & ) ;
            remove_function_type remove_function_value( &::SireFF::ForceFields::remove );
            
            ForceFields_exposer.def( 
                "remove"
                , remove_function_value
                , ( bp::arg("ffidx") )
                , bp::release_gil_policy()
                , "Remove the forcefield at index ffidx from this set\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireFF::ForceFields::remove
        
            typedef void ( ::SireFF::ForceFields::*remove_function_type)( ::SireFF::FFName const & ) ;
            remove_function_type remove_function_value( &::SireFF::ForceFields::remove );
            
            ForceFields_exposer.def( 
                "remove"
                , remove_function_value
                , ( bp::arg("ffname") )
                , bp::release_gil_policy()
                , "Remove the forcefield with name ffname.\nThrow: SireFF::missing_forcefield\n" );
        
        }
        { //::SireFF::ForceFields::remove
        
            typedef void ( ::SireFF::ForceFields::*remove_function_type)( ::SireFF::FFID const & ) ;
            remove_function_type remove_function_value( &::SireFF::ForceFields::remove );
            
            ForceFields_exposer.def( 
                "remove"
                , remove_function_value
                , ( bp::arg("ffid") )
                , bp::release_gil_policy()
                , "Remove the forcefield(s) that match the ID ffid\nThrow: SireFF::missing_forcefield\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireFF::ForceFields::remove
        
            typedef bool ( ::SireFF::ForceFields::*remove_function_type)( ::SireMol::MoleculeView const &,::SireMol::MGID const & ) ;
            remove_function_type remove_function_value( &::SireFF::ForceFields::remove );
            
            ForceFields_exposer.def( 
                "remove"
                , remove_function_value
                , ( bp::arg("molview"), bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Remove the view molview from the specified groups in this\nforcefield. Note that this only removes the specific view\n(and indeed only the first copy of this view if there\nare duplicates) - it does not remove the atoms in this\nview from all of the other views\nThrow: SireMol::missing_group\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireFF::ForceFields::remove
        
            typedef bool ( ::SireFF::ForceFields::*remove_function_type)( ::SireMol::ViewsOfMol const &,::SireMol::MGID const & ) ;
            remove_function_type remove_function_value( &::SireFF::ForceFields::remove );
            
            ForceFields_exposer.def( 
                "remove"
                , remove_function_value
                , ( bp::arg("molviews"), bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Remove the views in molviews from the specified groups in this\nforcefield. Note that this only removes the specific views\n(and indeed only the first copy of this view if there\nare duplicates) - it does not remove the atoms in this\nview from all of the other views\nThrow: SireMol::missing_group\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireFF::ForceFields::remove
        
            typedef bool ( ::SireFF::ForceFields::*remove_function_type)( ::SireMol::Molecules const &,::SireMol::MGID const & ) ;
            remove_function_type remove_function_value( &::SireFF::ForceFields::remove );
            
            ForceFields_exposer.def( 
                "remove"
                , remove_function_value
                , ( bp::arg("molecules"), bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Remove them molecules in molecules from the specified groups in this\nforcefield. Note that this only removes the specific views\n(and indeed only the first copy of this view if there\nare duplicates) - it does not remove the atoms in this\nview from all of the other views\nThrow: SireMol::missing_group\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireFF::ForceFields::remove
        
            typedef bool ( ::SireFF::ForceFields::*remove_function_type)( ::SireMol::MoleculeGroup const &,::SireMol::MGID const & ) ;
            remove_function_type remove_function_value( &::SireFF::ForceFields::remove );
            
            ForceFields_exposer.def( 
                "remove"
                , remove_function_value
                , ( bp::arg("molgroup"), bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Remove the views in the molecule group molgroup from the specified\ngroups in this forcefield. Note that this only removes the specific views\n(and indeed only the first copy of this view if there\nare duplicates) - it does not remove the atoms in this\nview from all of the other views\nThrow: SireMol::missing_group\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireFF::ForceFields::remove
        
            typedef bool ( ::SireFF::ForceFields::*remove_function_type)( ::SireMol::MolNum,::SireMol::MGID const & ) ;
            remove_function_type remove_function_value( &::SireFF::ForceFields::remove );
            
            ForceFields_exposer.def( 
                "remove"
                , remove_function_value
                , ( bp::arg("molnum"), bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Remove all views of the molecule with number molnum from the molecule\ngroups identified by mgid\nThrow: SireMol::missing_group\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireFF::ForceFields::remove
        
            typedef bool ( ::SireFF::ForceFields::*remove_function_type)( ::QSet< SireMol::MolNum > const &,::SireMol::MGID const & ) ;
            remove_function_type remove_function_value( &::SireFF::ForceFields::remove );
            
            ForceFields_exposer.def( 
                "remove"
                , remove_function_value
                , ( bp::arg("molnums"), bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Remove all of the molecules whose numbers are in molnums from\nall of the molecule groups identified by the ID mgid\nThrow: SireMol::missing_group\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireFF::ForceFields::removeAll
        
            typedef bool ( ::SireFF::ForceFields::*removeAll_function_type)( ::SireMol::MGID const & ) ;
            removeAll_function_type removeAll_function_value( &::SireFF::ForceFields::removeAll );
            
            ForceFields_exposer.def( 
                "removeAll"
                , removeAll_function_value
                , ( bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Remove all of the molecule views that are contained in the molecule\ngroups identified by the ID mgid\nThrow: SireMol::missing_group\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireFF::ForceFields::removeAll
        
            typedef bool ( ::SireFF::ForceFields::*removeAll_function_type)( ::SireMol::MoleculeView const &,::SireMol::MGID const & ) ;
            removeAll_function_type removeAll_function_value( &::SireFF::ForceFields::removeAll );
            
            ForceFields_exposer.def( 
                "removeAll"
                , removeAll_function_value
                , ( bp::arg("molview"), bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Remove the all copies of the view in molview from the specified\ngroups in this forcefield. Note that this only removes the specific views\n- it does not remove the atoms in this view from all of the other views\nThrow: SireMol::missing_group\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireFF::ForceFields::removeAll
        
            typedef bool ( ::SireFF::ForceFields::*removeAll_function_type)( ::SireMol::ViewsOfMol const &,::SireMol::MGID const & ) ;
            removeAll_function_type removeAll_function_value( &::SireFF::ForceFields::removeAll );
            
            ForceFields_exposer.def( 
                "removeAll"
                , removeAll_function_value
                , ( bp::arg("molviews"), bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Remove the all copies of the views in molviews from the specified\ngroups in this forcefield. Note that this only removes the specific views\n- it does not remove the atoms in this view from all of the other views\nThrow: SireMol::missing_group\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireFF::ForceFields::removeAll
        
            typedef bool ( ::SireFF::ForceFields::*removeAll_function_type)( ::SireMol::Molecules const &,::SireMol::MGID const & ) ;
            removeAll_function_type removeAll_function_value( &::SireFF::ForceFields::removeAll );
            
            ForceFields_exposer.def( 
                "removeAll"
                , removeAll_function_value
                , ( bp::arg("molecules"), bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Remove the all copies of the molecules in molecules from the specified\ngroups in this forcefield. Note that this only removes the specific views\n- it does not remove the atoms in this view from all of the other views\nThrow: SireMol::missing_group\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireFF::ForceFields::removeAll
        
            typedef bool ( ::SireFF::ForceFields::*removeAll_function_type)( ::SireMol::MoleculeGroup const &,::SireMol::MGID const & ) ;
            removeAll_function_type removeAll_function_value( &::SireFF::ForceFields::removeAll );
            
            ForceFields_exposer.def( 
                "removeAll"
                , removeAll_function_value
                , ( bp::arg("molgroup"), bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Remove the all copies of the molecules in the molecule group molgroup\nfrom the specified groups in this forcefield. Note that this only removes\nthe specific views - it does not remove the atoms in this view from all\nof the other views\nThrow: SireMol::missing_group\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireFF::ForceFields::removeAllForceFields
        
            typedef void ( ::SireFF::ForceFields::*removeAllForceFields_function_type)(  ) ;
            removeAllForceFields_function_type removeAllForceFields_function_value( &::SireFF::ForceFields::removeAllForceFields );
            
            ForceFields_exposer.def( 
                "removeAllForceFields"
                , removeAllForceFields_function_value
                , bp::release_gil_policy()
                , "Remove all of the forcefields from this set" );
        
        }
        { //::SireFF::ForceFields::removeProperty
        
            typedef void ( ::SireFF::ForceFields::*removeProperty_function_type)( ::QString const & ) ;
            removeProperty_function_type removeProperty_function_value( &::SireFF::ForceFields::removeProperty );
            
            ForceFields_exposer.def( 
                "removeProperty"
                , removeProperty_function_value
                , ( bp::arg("name") )
                , bp::release_gil_policy()
                , "Remove the property with name name. Note that this can only\nremove user-level properties - it cannot remove built-in properties\nof the forcefields. This does nothing if there is no user-level\nproperty with this name" );
        
        }
        { //::SireFF::ForceFields::setComponent
        
            typedef void ( ::SireFF::ForceFields::*setComponent_function_type)( ::SireCAS::Symbol const &,double ) ;
            setComponent_function_type setComponent_function_value( &::SireFF::ForceFields::setComponent );
            
            ForceFields_exposer.def( 
                "setComponent"
                , setComponent_function_value
                , ( bp::arg("symbol"), bp::arg("value") )
                , bp::release_gil_policy()
                , "Set the component represented by the symbol symbol equal to the\nvalue value. This replaces any existing component with this value.\nNote that an exception will be raised if you try to replace a component\nthat exists in one of the constituent forcefields.\nThis is a convenient shorthand for ForceFields::setConstantComponent(symbol, value)\nThrow: SireFF::duplicate_component\n" );
        
        }
        { //::SireFF::ForceFields::setComponent
        
            typedef void ( ::SireFF::ForceFields::*setComponent_function_type)( ::SireCAS::Symbol const &,::SireCAS::Expression const & ) ;
            setComponent_function_type setComponent_function_value( &::SireFF::ForceFields::setComponent );
            
            ForceFields_exposer.def( 
                "setComponent"
                , setComponent_function_value
                , ( bp::arg("symbol"), bp::arg("expression") )
                , bp::release_gil_policy()
                , "Set the component represented by the symbol symbol equal to the expression\ncontained in expression. This replaces any existing constant or\nenergy component with this expression.\nNote that this expression must only involve terms that are linear in\nforcefield components, and there may be no products of forcefield\ncomponents (i.e. each term of the expression must have dimensions\nof energy)\nNote that an exception will be raised if you try to replace a\ncomponent that exists in one of the constituent forcefields\nThis is a convenient short-hand for\nForceFields::setEnergyComponent(symbol,expression)\nThrow: SireFF::duplicate_component\n" );
        
        }
        { //::SireFF::ForceFields::setConstantComponent
        
            typedef void ( ::SireFF::ForceFields::*setConstantComponent_function_type)( ::SireCAS::Symbol const &,double ) ;
            setConstantComponent_function_type setConstantComponent_function_value( &::SireFF::ForceFields::setConstantComponent );
            
            ForceFields_exposer.def( 
                "setConstantComponent"
                , setConstantComponent_function_value
                , ( bp::arg("symbol"), bp::arg("value") )
                , bp::release_gil_policy()
                , "Set the constant component represented by the symbol symbol equal to the\nvalue value. This replaces any existing constant or energy component with\nthis value. Note that an exception will be raised if you try to replace a component\nthat exists in one of the constituent forcefields.\nThrow: SireFF::duplicate_component\n" );
        
        }
        { //::SireFF::ForceFields::setConstantComponent
        
            typedef void ( ::SireFF::ForceFields::*setConstantComponent_function_type)( ::SireCAS::Symbol const &,::SireCAS::Expression const & ) ;
            setConstantComponent_function_type setConstantComponent_function_value( &::SireFF::ForceFields::setConstantComponent );
            
            ForceFields_exposer.def( 
                "setConstantComponent"
                , setConstantComponent_function_value
                , ( bp::arg("symbol"), bp::arg("expression") )
                , bp::release_gil_policy()
                , "Set the constant component represented by the symbol symbol equal to the\nexpression expression. This replaces any existing constant or energy component with\nthis value.\nNote that this expression must only involve constants, or other constant\ncomponents. A constant expression may not depend on a forcefield energy\nNote that an exception will be raised if you try to replace a component\nthat exists in one of the constituent forcefields.\nThrow: SireFF::duplicate_component\n" );
        
        }
        { //::SireFF::ForceFields::setContents
        
            typedef void ( ::SireFF::ForceFields::*setContents_function_type)( ::SireMol::MGID const &,::SireMol::MoleculeView const &,::SireBase::PropertyMap const & ) ;
            setContents_function_type setContents_function_value( &::SireFF::ForceFields::setContents );
            
            ForceFields_exposer.def( 
                "setContents"
                , setContents_function_value
                , ( bp::arg("mgid"), bp::arg("molview"), bp::arg("map") )
                , bp::release_gil_policy()
                , "Set the contents of the molecule groups identified by the ID mgid\nso that they only contain the view of the molecule in molview.\nThe passed property map is used to find any properties that are\nneeded by the forcefields\nThrow: SireMol::missing_group\nThrow: SireBase::missing_property\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireFF::ForceFields::setContents
        
            typedef void ( ::SireFF::ForceFields::*setContents_function_type)( ::SireMol::MGID const &,::SireMol::ViewsOfMol const &,::SireBase::PropertyMap const & ) ;
            setContents_function_type setContents_function_value( &::SireFF::ForceFields::setContents );
            
            ForceFields_exposer.def( 
                "setContents"
                , setContents_function_value
                , ( bp::arg("mgid"), bp::arg("molviews"), bp::arg("map") )
                , bp::release_gil_policy()
                , "Set the contents of the molecule groups identified by the ID mgid\nso that they only contain the views of the molecule in molviews.\nThe passed property map is used to find any properties that are\nneeded by the forcefields\nThrow: SireMol::missing_group\nThrow: SireBase::missing_property\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireFF::ForceFields::setContents
        
            typedef void ( ::SireFF::ForceFields::*setContents_function_type)( ::SireMol::MGID const &,::SireMol::Molecules const &,::SireBase::PropertyMap const & ) ;
            setContents_function_type setContents_function_value( &::SireFF::ForceFields::setContents );
            
            ForceFields_exposer.def( 
                "setContents"
                , setContents_function_value
                , ( bp::arg("mgid"), bp::arg("molecules"), bp::arg("map") )
                , bp::release_gil_policy()
                , "Set the contents of the molecule groups identified by the ID mgid\nso that they only contain the molecules in molecules.\nThe passed property map is used to find any properties that are\nneeded by the forcefields\nThrow: SireMol::missing_group\nThrow: SireBase::missing_property\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireFF::ForceFields::setContents
        
            typedef void ( ::SireFF::ForceFields::*setContents_function_type)( ::SireMol::MGID const &,::SireMol::MoleculeGroup const &,::SireBase::PropertyMap const & ) ;
            setContents_function_type setContents_function_value( &::SireFF::ForceFields::setContents );
            
            ForceFields_exposer.def( 
                "setContents"
                , setContents_function_value
                , ( bp::arg("mgid"), bp::arg("molgroup"), bp::arg("map") )
                , bp::release_gil_policy()
                , "Set the contents of the molecule groups identified by the ID mgid\nso that they only contain the molecules in the group molgroup.\nThe passed property map is used to find any properties that are\nneeded by the forcefields\nThrow: SireMol::missing_group\nThrow: SireBase::missing_property\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireFF::ForceFields::setContents
        
            typedef void ( ::SireFF::ForceFields::*setContents_function_type)( ::SireMol::MGID const &,::SireMol::MoleculeView const & ) ;
            setContents_function_type setContents_function_value( &::SireFF::ForceFields::setContents );
            
            ForceFields_exposer.def( 
                "setContents"
                , setContents_function_value
                , ( bp::arg("mgid"), bp::arg("molview") )
                , bp::release_gil_policy()
                , "Set the contents of the molecule groups identified by the ID mgid\nso that they only contain the view of the molecule in molview.\nProperties required by the forcefields are searched for in the\ndefault properties.\nThrow: SireMol::missing_group\nThrow: SireBase::missing_property\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireFF::ForceFields::setContents
        
            typedef void ( ::SireFF::ForceFields::*setContents_function_type)( ::SireMol::MGID const &,::SireMol::ViewsOfMol const & ) ;
            setContents_function_type setContents_function_value( &::SireFF::ForceFields::setContents );
            
            ForceFields_exposer.def( 
                "setContents"
                , setContents_function_value
                , ( bp::arg("mgid"), bp::arg("molviews") )
                , bp::release_gil_policy()
                , "Set the contents of the molecule groups identified by the ID mgid\nso that they only contain the views of the molecule in molviews.\nProperties required by the forcefields are searched for in the\ndefault properties.\nThrow: SireMol::missing_group\nThrow: SireBase::missing_property\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireFF::ForceFields::setContents
        
            typedef void ( ::SireFF::ForceFields::*setContents_function_type)( ::SireMol::MGID const &,::SireMol::Molecules const & ) ;
            setContents_function_type setContents_function_value( &::SireFF::ForceFields::setContents );
            
            ForceFields_exposer.def( 
                "setContents"
                , setContents_function_value
                , ( bp::arg("mgid"), bp::arg("molecules") )
                , bp::release_gil_policy()
                , "Set the contents of the molecule groups identified by the ID mgid\nso that they only contain the molecules in molecules.\nProperties required by the forcefields are searched for in the\ndefault properties.\nThrow: SireMol::missing_group\nThrow: SireBase::missing_property\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireFF::ForceFields::setContents
        
            typedef void ( ::SireFF::ForceFields::*setContents_function_type)( ::SireMol::MGID const &,::SireMol::MoleculeGroup const & ) ;
            setContents_function_type setContents_function_value( &::SireFF::ForceFields::setContents );
            
            ForceFields_exposer.def( 
                "setContents"
                , setContents_function_value
                , ( bp::arg("mgid"), bp::arg("molgroup") )
                , bp::release_gil_policy()
                , "Set the contents of the molecule groups identified by the ID mgid\nso that they only contain the molecules in the molecule group molgroup.\nProperties required by the forcefields are searched for in the\ndefault properties.\nThrow: SireMol::missing_group\nThrow: SireBase::missing_property\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireFF::ForceFields::setEnergyComponent
        
            typedef void ( ::SireFF::ForceFields::*setEnergyComponent_function_type)( ::SireCAS::Symbol const &,::SireCAS::Expression const & ) ;
            setEnergyComponent_function_type setEnergyComponent_function_value( &::SireFF::ForceFields::setEnergyComponent );
            
            ForceFields_exposer.def( 
                "setEnergyComponent"
                , setEnergyComponent_function_value
                , ( bp::arg("symbol"), bp::arg("expression") )
                , bp::release_gil_policy()
                , "Set the component represented by the symbol symbol equal to the expression\ncontained in expression. This replaces any existing constant or\nenergy component with this expression.\nNote that this expression must only involve terms that are linear in\nforcefield components, and there may be no products of forcefield\ncomponents (i.e. each term of the expression must have dimensions\nof energy)\nNote that an exception will be raised if you try to replace a\ncomponent that exists in one of the constituent forcefields\nThrow: SireFF::duplicate_component\n" );
        
        }
        { //::SireFF::ForceFields::setProperty
        
            typedef void ( ::SireFF::ForceFields::*setProperty_function_type)( ::QString const &,::SireBase::Property const & ) ;
            setProperty_function_type setProperty_function_value( &::SireFF::ForceFields::setProperty );
            
            ForceFields_exposer.def( 
                "setProperty"
                , setProperty_function_value
                , ( bp::arg("name"), bp::arg("value") )
                , bp::release_gil_policy()
                , "Set the property name to have the value value in all of the\nforcefields contained in this set\nThrow: SireError::incompatible_error\nThrow: SireError::invalid_cast\n" );
        
        }
        { //::SireFF::ForceFields::setProperty
        
            typedef void ( ::SireFF::ForceFields::*setProperty_function_type)( ::SireFF::FFID const &,::QString const &,::SireBase::Property const & ) ;
            setProperty_function_type setProperty_function_value( &::SireFF::ForceFields::setProperty );
            
            ForceFields_exposer.def( 
                "setProperty"
                , setProperty_function_value
                , ( bp::arg("ffid"), bp::arg("name"), bp::arg("value") )
                , bp::release_gil_policy()
                , "Set the built-in property name to have the value value in all of the forcefields\nin this set that match the ID ffid\nNote that because this operates on the level of individual forcefields,\nit operates only on built-in properties, not on user-supplied properties\nNote also that if this breaks any links or combined properties then\nthe broken links and combined properties (including all those that\ndepend on them) will be removed\nThrow: SireFF::missing_forcefield\nThrow: SireError::invalid_index\nThrow: SireError::incompatible_error\nThrow: SireError::invalid_cast\n" );
        
        }
        { //::SireFF::ForceFields::toString
        
            typedef ::QString ( ::SireFF::ForceFields::*toString_function_type)(  ) const;
            toString_function_type toString_function_value( &::SireFF::ForceFields::toString );
            
            ForceFields_exposer.def( 
                "toString"
                , toString_function_value
                , bp::release_gil_policy()
                , "Return a string representation of this set" );
        
        }
        { //::SireFF::ForceFields::totalComponent
        
            typedef ::SireCAS::Symbol const & ( *totalComponent_function_type )(  );
            totalComponent_function_type totalComponent_function_value( &::SireFF::ForceFields::totalComponent );
            
            ForceFields_exposer.def( 
                "totalComponent"
                , totalComponent_function_value
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Return the symbol representing the total energy component" );
        
        }
        { //::SireFF::ForceFields::typeName
        
            typedef char const * ( *typeName_function_type )(  );
            typeName_function_type typeName_function_value( &::SireFF::ForceFields::typeName );
            
            ForceFields_exposer.def( 
                "typeName"
                , typeName_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireFF::ForceFields::update
        
            typedef void ( ::SireFF::ForceFields::*update_function_type)( ::SireMol::MoleculeData const &,bool ) ;
            update_function_type update_function_value( &::SireFF::ForceFields::update );
            
            ForceFields_exposer.def( 
                "update"
                , update_function_value
                , ( bp::arg("moldata"), bp::arg("auto_commit")=(bool)(true) )
                , "Update all of the forcefields so that they use the version of the data\nof the molecule held in moldata\nThrow: SireBase::missing_property\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireFF::ForceFields::update
        
            typedef void ( ::SireFF::ForceFields::*update_function_type)( ::SireMol::Molecules const &,bool ) ;
            update_function_type update_function_value( &::SireFF::ForceFields::update );
            
            ForceFields_exposer.def( 
                "update"
                , update_function_value
                , ( bp::arg("molecules"), bp::arg("auto_commit")=(bool)(true) )
                , "Update all of the forcefields in this group so that they have the\nsame version of the molecules that are present in molecules\nThrow: SireBase::missing_property\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireFF::ForceFields::update
        
            typedef void ( ::SireFF::ForceFields::*update_function_type)( ::SireMol::MoleculeGroup const &,bool ) ;
            update_function_type update_function_value( &::SireFF::ForceFields::update );
            
            ForceFields_exposer.def( 
                "update"
                , update_function_value
                , ( bp::arg("molgroup"), bp::arg("auto_commit")=(bool)(true) )
                , "Update all of the forcefields in this group so that they have the\nsame version of the molecules that are present in the molecule\ngroup molgroup\nThrow: SireBase::missing_property\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireFF::ForceFields::userProperties
        
            typedef ::SireBase::Properties ( ::SireFF::ForceFields::*userProperties_function_type)(  ) const;
            userProperties_function_type userProperties_function_value( &::SireFF::ForceFields::userProperties );
            
            ForceFields_exposer.def( 
                "userProperties"
                , userProperties_function_value
                , bp::release_gil_policy()
                , "Return all of the user-supplied properties in this set of forcefields" );
        
        }
        { //::SireFF::ForceFields::userProperty
        
            typedef ::SireBase::Property const & ( ::SireFF::ForceFields::*userProperty_function_type)( ::QString const & ) const;
            userProperty_function_type userProperty_function_value( &::SireFF::ForceFields::userProperty );
            
            ForceFields_exposer.def( 
                "userProperty"
                , userProperty_function_value
                , ( bp::arg("name") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Return the user-supplied property at name. This raises an\nexception if there is no user-supplied property with this name\nThrow: SireBase::missing_property\n" );
        
        }
        ForceFields_exposer.staticmethod( "totalComponent" );
        ForceFields_exposer.staticmethod( "typeName" );
        ForceFields_exposer.def( "__copy__", &__copy__);
        ForceFields_exposer.def( "__deepcopy__", &__copy__);
        ForceFields_exposer.def( "clone", &__copy__);
        ForceFields_exposer.def( "__rlshift__", &__rlshift__QDataStream< ::SireFF::ForceFields >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        ForceFields_exposer.def( "__rrshift__", &__rrshift__QDataStream< ::SireFF::ForceFields >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        ForceFields_exposer.def_pickle(sire_pickle_suite< ::SireFF::ForceFields >());
        ForceFields_exposer.def( "__str__", &__str__< ::SireFF::ForceFields > );
        ForceFields_exposer.def( "__repr__", &__str__< ::SireFF::ForceFields > );
        ForceFields_exposer.def( "__len__", &__len_count< ::SireFF::ForceFields > );
    }

}
