// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 2 License

#include "boost/python.hpp"
#include "Helpers/clone_const_reference.hpp"
#include "System.pypp.hpp"

namespace bp = boost::python;

#include "SireBase/savestate.h"

#include "SireError/errors.h"

#include "SireFF/energytable.h"

#include "SireFF/ff.h"

#include "SireFF/ffidx.h"

#include "SireFF/ffmolgroup.h"

#include "SireFF/fieldtable.h"

#include "SireFF/forcefield.h"

#include "SireFF/forcetable.h"

#include "SireFF/potentialtable.h"

#include "SireFF/probe.h"

#include "SireMM/ljparameterdb.h"

#include "SireMol/atomcoords.h"

#include "SireMol/errors.h"

#include "SireMol/molecule.h"

#include "SireMol/moleculegroup.h"

#include "SireMol/molecules.h"

#include "SireMol/partialmolecule.h"

#include "SireStream/datastream.h"

#include "SireStream/shareddatastream.h"

#include "delta.h"

#include "monitorname.h"

#include "system.h"

#include <QDebug>

#include <QHash>

#include <QMutex>

#include <QTime>

#include "system.h"

#include "SireBase/slice.h"

SireSystem::System __copy__(const SireSystem::System &other){ return SireSystem::System(other); }

#include "Qt/qdatastream.hpp"

#include "Helpers/str.hpp"

#include "Helpers/release_gil_policy.hpp"

#include "Helpers/len.hpp"

void register_System_class(){

    { //::SireSystem::System
        typedef bp::class_< SireSystem::System, bp::bases< SireMol::MolGroupsBase, SireBase::Property > > System_exposer_t;
        System_exposer_t System_exposer = System_exposer_t( "System", "This is a simulation system. If contains molecules, forcefields that\nprovide energy functions of those molecules, and monitors that\ncan monitor the changing state of the system\n\nAuthor: Christopher Woods\n", bp::init< >("Construct an unnamed System") );
        bp::scope System_scope( System_exposer );
        System_exposer.def( bp::init< QString const & >(( bp::arg("name") ), "Construct a named System") );
        System_exposer.def( bp::init< SireSystem::System const & >(( bp::arg("other") ), "Copy constructor") );
        { //::SireSystem::System::UID
        
            typedef ::QUuid const & ( ::SireSystem::System::*UID_function_type)(  ) const;
            UID_function_type UID_function_value( &::SireSystem::System::UID );
            
            System_exposer.def( 
                "UID"
                , UID_function_value
                , bp::return_value_policy< bp::copy_const_reference >()
                , "" );
        
        }
        { //::SireSystem::System::accept
        
            typedef void ( ::SireSystem::System::*accept_function_type)(  ) ;
            accept_function_type accept_function_value( &::SireSystem::System::accept );
            
            System_exposer.def( 
                "accept"
                , accept_function_value
                , bp::release_gil_policy()
                , "Tell all of the forcefields that the last move was accepted. This allows\nany cacheing or use of temporary workspaces to be committed" );
        
        }
        { //::SireSystem::System::add
        
            typedef void ( ::SireSystem::System::*add_function_type)( ::QString const &,::SireSystem::SystemMonitor const &,int ) ;
            add_function_type add_function_value( &::SireSystem::System::add );
            
            System_exposer.def( 
                "add"
                , add_function_value
                , ( bp::arg("name"), bp::arg("monitor"), bp::arg("frequency")=(int)(1) )
                , "Add a system monitor monitor, identified by the name name, which\nwill be updated every frequency steps.\nThrow: SireSystem::duplicate_monitor\n" );
        
        }
        { //::SireSystem::System::add
        
            typedef void ( ::SireSystem::System::*add_function_type)( ::SireSystem::SystemMonitors const & ) ;
            add_function_type add_function_value( &::SireSystem::System::add );
            
            System_exposer.def( 
                "add"
                , add_function_value
                , ( bp::arg("monitors") )
                , bp::release_gil_policy()
                , "Add the monitors in monitors to this system\nThrow: SireSystem::duplicate_monitor\n" );
        
        }
        { //::SireSystem::System::add
        
            typedef void ( ::SireSystem::System::*add_function_type)( ::SireSystem::SystemMonitors const &,int ) ;
            add_function_type add_function_value( &::SireSystem::System::add );
            
            System_exposer.def( 
                "add"
                , add_function_value
                , ( bp::arg("monitors"), bp::arg("frequency") )
                , bp::release_gil_policy()
                , "Add the monitors in monitors, setting the frequency of the\nnew monitors to frequency\nThrow: SireSystem::duplicate_monitor\n" );
        
        }
        { //::SireSystem::System::add
        
            typedef void ( ::SireSystem::System::*add_function_type)( ::SireFF::FF const & ) ;
            add_function_type add_function_value( &::SireSystem::System::add );
            
            System_exposer.def( 
                "add"
                , add_function_value
                , ( bp::arg("forcefield") )
                , bp::release_gil_policy()
                , "Add the forcefield forcefield to this system. This will raise\nan exception if this forcefield (or one with the same name)\nis already present in this set. Note that if the added\nforcefield will be updated to contain the versions of\nany molecules that are already present in any of the\nother forcefields.\nThrow: SireFF::duplicate_forcefield\nThrow: SireMol::duplicate_group\n" );
        
        }
        { //::SireSystem::System::add
        
            typedef void ( ::SireSystem::System::*add_function_type)( ::SireMol::MoleculeGroup const & ) ;
            add_function_type add_function_value( &::SireSystem::System::add );
            
            System_exposer.def( 
                "add"
                , add_function_value
                , ( bp::arg("molgroup") )
                , bp::release_gil_policy()
                , "Add the molecule group molgroup to this system. If this is\na molecule group that is part of a forcefield, then the entire\nforcefield will be added to this system. This will raise\nan exception if this molecule group is already present in\nthis system. Note that the added molecule group will be\nupdated to contain the version of the any molecules that\nare already present in this system\nThrow: SireFF::duplicate_forcefield\nThrow: SireMol::duplicate_group\n" );
        
        }
        { //::SireSystem::System::add
        
            typedef void ( ::SireSystem::System::*add_function_type)( ::SireSystem::Constraint const & ) ;
            add_function_type add_function_value( &::SireSystem::System::add );
            
            System_exposer.def( 
                "add"
                , add_function_value
                , ( bp::arg("constraint") )
                , bp::release_gil_policy()
                , "Add the passed constraint to the system" );
        
        }
        { //::SireSystem::System::add
        
            typedef void ( ::SireSystem::System::*add_function_type)( ::SireSystem::Constraints const & ) ;
            add_function_type add_function_value( &::SireSystem::System::add );
            
            System_exposer.def( 
                "add"
                , add_function_value
                , ( bp::arg("constraints") )
                , bp::release_gil_policy()
                , "Add the passed constraint to the system" );
        
        }
        { //::SireSystem::System::add
        
            typedef void ( ::SireSystem::System::*add_function_type)( ::SireMol::MoleculeView const &,::SireMol::MGID const &,::SireBase::PropertyMap const & ) ;
            add_function_type add_function_value( &::SireSystem::System::add );
            
            System_exposer.def( 
                "add"
                , add_function_value
                , ( bp::arg("molview"), bp::arg("mgid"), bp::arg("map") )
                , bp::release_gil_policy()
                , "Add the molecule viewed in molview to the molecule groups\nidentified by the ID mgid. The supplied property map\nis used to find the properties required by any forcefields\nthat this molecule may be added to. The version of the molecule\nalready present in this system is used, if such a molecule exists.\nThrow: SireMol::missing_group\nThrow: SireBase::missing_property\nThrow: SireError::invalid_index\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireSystem::System::add
        
            typedef void ( ::SireSystem::System::*add_function_type)( ::SireMol::ViewsOfMol const &,::SireMol::MGID const &,::SireBase::PropertyMap const & ) ;
            add_function_type add_function_value( &::SireSystem::System::add );
            
            System_exposer.def( 
                "add"
                , add_function_value
                , ( bp::arg("molviews"), bp::arg("mgid"), bp::arg("map") )
                , bp::release_gil_policy()
                , "Add the views of the molecule in molviews to the molecule groups\nidentified by the ID mgid. The supplied property map\nis used to find the properties required by any forcefields\nthat this molecule may be added to. The version of the molecule\nalready present in this system is used, if such a molecule exists.\nThrow: SireMol::missing_group\nThrow: SireBase::missing_property\nThrow: SireError::invalid_index\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireSystem::System::add
        
            typedef void ( ::SireSystem::System::*add_function_type)( ::SireMol::Molecules const &,::SireMol::MGID const &,::SireBase::PropertyMap const & ) ;
            add_function_type add_function_value( &::SireSystem::System::add );
            
            System_exposer.def( 
                "add"
                , add_function_value
                , ( bp::arg("molecules"), bp::arg("mgid"), bp::arg("map") )
                , bp::release_gil_policy()
                , "Add the molecules viewed in molecules to the molecule groups\nidentified by the ID mgid. The supplied property map\nis used to find the properties required by any forcefields\nthat this molecule may be added to. The version of the molecule\nalready present in this system is used, if such a molecule exists.\nThrow: SireMol::missing_group\nThrow: SireBase::missing_property\nThrow: SireError::invalid_index\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireSystem::System::add
        
            typedef void ( ::SireSystem::System::*add_function_type)( ::SireMol::MoleculeGroup const &,::SireMol::MGID const &,::SireBase::PropertyMap const & ) ;
            add_function_type add_function_value( &::SireSystem::System::add );
            
            System_exposer.def( 
                "add"
                , add_function_value
                , ( bp::arg("molgroup"), bp::arg("mgid"), bp::arg("map") )
                , bp::release_gil_policy()
                , "Add the molecules in the molecule group molgroup to the molecule groups\nidentified by the ID mgid. The supplied property map\nis used to find the properties required by any forcefields\nthat this molecule may be added to. The version of the molecule\nalready present in this system is used, if such a molecule exists.\nThrow: SireMol::missing_group\nThrow: SireBase::missing_property\nThrow: SireError::invalid_index\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireSystem::System::add
        
            typedef void ( ::SireSystem::System::*add_function_type)( ::SireMol::MoleculeView const &,::SireMol::MGID const & ) ;
            add_function_type add_function_value( &::SireSystem::System::add );
            
            System_exposer.def( 
                "add"
                , add_function_value
                , ( bp::arg("molview"), bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Convenient overload of System::add that uses the default locations\nto find any necessary properties.\nThrow: SireMol::missing_group\nThrow: SireBase::missing_property\nThrow: SireError::invalid_index\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireSystem::System::add
        
            typedef void ( ::SireSystem::System::*add_function_type)( ::SireMol::ViewsOfMol const &,::SireMol::MGID const & ) ;
            add_function_type add_function_value( &::SireSystem::System::add );
            
            System_exposer.def( 
                "add"
                , add_function_value
                , ( bp::arg("molviews"), bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Convenient overload of System::add that uses the default locations\nto find any necessary properties.\nThrow: SireMol::missing_group\nThrow: SireBase::missing_property\nThrow: SireError::invalid_index\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireSystem::System::add
        
            typedef void ( ::SireSystem::System::*add_function_type)( ::SireMol::Molecules const &,::SireMol::MGID const & ) ;
            add_function_type add_function_value( &::SireSystem::System::add );
            
            System_exposer.def( 
                "add"
                , add_function_value
                , ( bp::arg("molecules"), bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Convenient overload of System::add that uses the default locations\nto find any necessary properties.\nThrow: SireMol::missing_group\nThrow: SireBase::missing_property\nThrow: SireError::invalid_index\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireSystem::System::add
        
            typedef void ( ::SireSystem::System::*add_function_type)( ::SireMol::MoleculeGroup const &,::SireMol::MGID const & ) ;
            add_function_type add_function_value( &::SireSystem::System::add );
            
            System_exposer.def( 
                "add"
                , add_function_value
                , ( bp::arg("molgroup"), bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Convenient overload of System::add that uses the default locations\nto find any necessary properties.\nThrow: SireMol::missing_group\nThrow: SireBase::missing_property\nThrow: SireError::invalid_index\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireSystem::System::addIfUnique
        
            typedef void ( ::SireSystem::System::*addIfUnique_function_type)( ::SireMol::MoleculeView const &,::SireMol::MGID const &,::SireBase::PropertyMap const & ) ;
            addIfUnique_function_type addIfUnique_function_value( &::SireSystem::System::addIfUnique );
            
            System_exposer.def( 
                "addIfUnique"
                , addIfUnique_function_value
                , ( bp::arg("molview"), bp::arg("mgid"), bp::arg("map") )
                , bp::release_gil_policy()
                , "Add the view of the molecule in molview to the groups\nidentified by mgid. This only adds the view to a group\nif it doesnt already exist in the group. The version\nof the molecule already present in this set is used if\nsuch a molecule already exists. The supplied property map\nis used to find the properties required by any forcefields\nthat this molecule may be added to.\nThrow: SireMol::missing_group\nThrow: SireBase::missing_property\nThrow: SireError::invalid_index\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireSystem::System::addIfUnique
        
            typedef void ( ::SireSystem::System::*addIfUnique_function_type)( ::SireMol::ViewsOfMol const &,::SireMol::MGID const &,::SireBase::PropertyMap const & ) ;
            addIfUnique_function_type addIfUnique_function_value( &::SireSystem::System::addIfUnique );
            
            System_exposer.def( 
                "addIfUnique"
                , addIfUnique_function_value
                , ( bp::arg("molviews"), bp::arg("mgid"), bp::arg("map") )
                , bp::release_gil_policy()
                , "Add the views of the molecule in molviews to the groups\nidentified by mgid. This only adds the view to a group\nif it doesnt already exist in the group. The version\nof the molecule already present in this set is used if\nsuch a molecule already exists. The supplied property map\nis used to find the properties required by any forcefields\nthat this molecule may be added to.\nThrow: SireMol::missing_group\nThrow: SireBase::missing_property\nThrow: SireError::invalid_index\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireSystem::System::addIfUnique
        
            typedef void ( ::SireSystem::System::*addIfUnique_function_type)( ::SireMol::Molecules const &,::SireMol::MGID const &,::SireBase::PropertyMap const & ) ;
            addIfUnique_function_type addIfUnique_function_value( &::SireSystem::System::addIfUnique );
            
            System_exposer.def( 
                "addIfUnique"
                , addIfUnique_function_value
                , ( bp::arg("molecules"), bp::arg("mgid"), bp::arg("map") )
                , bp::release_gil_policy()
                , "Add the views of the molecules in molecules to the groups\nidentified by mgid. This only adds the view to a group\nif it doesnt already exist in the group. The version\nof the molecule already present in this set is used if\nsuch a molecule already exists. The supplied property map\nis used to find the properties required by any forcefields\nthat this molecule may be added to.\nThrow: SireMol::missing_group\nThrow: SireBase::missing_property\nThrow: SireError::invalid_index\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireSystem::System::addIfUnique
        
            typedef void ( ::SireSystem::System::*addIfUnique_function_type)( ::SireMol::MoleculeGroup const &,::SireMol::MGID const &,::SireBase::PropertyMap const & ) ;
            addIfUnique_function_type addIfUnique_function_value( &::SireSystem::System::addIfUnique );
            
            System_exposer.def( 
                "addIfUnique"
                , addIfUnique_function_value
                , ( bp::arg("molgroup"), bp::arg("mgid"), bp::arg("map") )
                , bp::release_gil_policy()
                , "Add the view of the molecules in the group molgroup to the groups\nidentified by mgid. This only adds the view to a group\nif it doesnt already exist in the group. The version\nof the molecule already present in this set is used if\nsuch a molecule already exists. The supplied property map\nis used to find the properties required by any forcefields\nthat this molecule may be added to.\nThrow: SireMol::missing_group\nThrow: SireBase::missing_property\nThrow: SireError::invalid_index\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireSystem::System::addIfUnique
        
            typedef void ( ::SireSystem::System::*addIfUnique_function_type)( ::SireMol::MoleculeView const &,::SireMol::MGID const & ) ;
            addIfUnique_function_type addIfUnique_function_value( &::SireSystem::System::addIfUnique );
            
            System_exposer.def( 
                "addIfUnique"
                , addIfUnique_function_value
                , ( bp::arg("molview"), bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Convenient overload of System::addIfUnique that uses the default locations\nto find any necessary properties.\nThrow: SireMol::missing_group\nThrow: SireBase::missing_property\nThrow: SireError::invalid_index\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireSystem::System::addIfUnique
        
            typedef void ( ::SireSystem::System::*addIfUnique_function_type)( ::SireMol::ViewsOfMol const &,::SireMol::MGID const & ) ;
            addIfUnique_function_type addIfUnique_function_value( &::SireSystem::System::addIfUnique );
            
            System_exposer.def( 
                "addIfUnique"
                , addIfUnique_function_value
                , ( bp::arg("molviews"), bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Convenient overload of System::addIfUnique that uses the default locations\nto find any necessary properties.\nThrow: SireMol::missing_group\nThrow: SireBase::missing_property\nThrow: SireError::invalid_index\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireSystem::System::addIfUnique
        
            typedef void ( ::SireSystem::System::*addIfUnique_function_type)( ::SireMol::Molecules const &,::SireMol::MGID const & ) ;
            addIfUnique_function_type addIfUnique_function_value( &::SireSystem::System::addIfUnique );
            
            System_exposer.def( 
                "addIfUnique"
                , addIfUnique_function_value
                , ( bp::arg("molecules"), bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Convenient overload of System::addIfUnique that uses the default locations\nto find any necessary properties.\nThrow: SireMol::missing_group\nThrow: SireBase::missing_property\nThrow: SireError::invalid_index\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireSystem::System::addIfUnique
        
            typedef void ( ::SireSystem::System::*addIfUnique_function_type)( ::SireMol::MoleculeGroup const &,::SireMol::MGID const & ) ;
            addIfUnique_function_type addIfUnique_function_value( &::SireSystem::System::addIfUnique );
            
            System_exposer.def( 
                "addIfUnique"
                , addIfUnique_function_value
                , ( bp::arg("molgroup"), bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Convenient overload of System::addIfUnique that uses the default locations\nto find any necessary properties.\nThrow: SireMol::missing_group\nThrow: SireBase::missing_property\nThrow: SireError::invalid_index\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireSystem::System::applyConstraints
        
            typedef void ( ::SireSystem::System::*applyConstraints_function_type)(  ) ;
            applyConstraints_function_type applyConstraints_function_value( &::SireSystem::System::applyConstraints );
            
            System_exposer.def( 
                "applyConstraints"
                , applyConstraints_function_value
                , bp::release_gil_policy()
                , "Apply the system (and molecule) constraints" );
        
        }
        { //::SireSystem::System::at
        
            typedef ::SireFF::FF const & ( ::SireSystem::System::*at_function_type)( ::SireFF::FFID const & ) const;
            at_function_type at_function_value( &::SireSystem::System::at );
            
            System_exposer.def( 
                "at"
                , at_function_value
                , ( bp::arg("ffid") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Return the forcefield with ID ffid in this system\nThrow: SireFF::missing_forcefield\nThrow: SireFF::duplicate_forcefield\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireSystem::System::at
        
            typedef ::SireSystem::SystemMonitor const & ( ::SireSystem::System::*at_function_type)( ::SireSystem::MonitorID const & ) const;
            at_function_type at_function_value( &::SireSystem::System::at );
            
            System_exposer.def( 
                "at"
                , at_function_value
                , ( bp::arg("monid") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Return the monitor at ID monid\nThrow: SireSystem::missing_monitor\nThrow: SireSystem::duplicate_monitor\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireSystem::System::at
        
            typedef ::SireMol::MoleculeGroup const & ( ::SireSystem::System::*at_function_type)( ::SireMol::MGNum ) const;
            at_function_type at_function_value( &::SireSystem::System::at );
            
            System_exposer.def( 
                "at"
                , at_function_value
                , ( bp::arg("mgnum") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "overloading MolGroupsBase virtual functions" );
        
        }
        { //::SireSystem::System::builtinProperties
        
            typedef ::SireBase::Properties ( ::SireSystem::System::*builtinProperties_function_type)(  ) const;
            builtinProperties_function_type builtinProperties_function_value( &::SireSystem::System::builtinProperties );
            
            System_exposer.def( 
                "builtinProperties"
                , builtinProperties_function_value
                , bp::release_gil_policy()
                , "Return the values of all built-in properties of this system" );
        
        }
        { //::SireSystem::System::builtinProperty
        
            typedef ::SireBase::Property const & ( ::SireSystem::System::*builtinProperty_function_type)( ::QString const & ) const;
            builtinProperty_function_type builtinProperty_function_value( &::SireSystem::System::builtinProperty );
            
            System_exposer.def( 
                "builtinProperty"
                , builtinProperty_function_value
                , ( bp::arg("name") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Return the built-in property at name. This will by-pass any\nuser-supplied property with this name, and will raise an\nexception if there is no built-in property with this name\nThrow: SireBase::missing_property\n" );
        
        }
        { //::SireSystem::System::clearStatistics
        
            typedef void ( ::SireSystem::System::*clearStatistics_function_type)(  ) ;
            clearStatistics_function_type clearStatistics_function_value( &::SireSystem::System::clearStatistics );
            
            System_exposer.def( 
                "clearStatistics"
                , clearStatistics_function_value
                , bp::release_gil_policy()
                , "Completely clear all statistics held in the monitors" );
        
        }
        { //::SireSystem::System::clearStatistics
        
            typedef void ( ::SireSystem::System::*clearStatistics_function_type)( ::SireSystem::MonitorID const & ) ;
            clearStatistics_function_type clearStatistics_function_value( &::SireSystem::System::clearStatistics );
            
            System_exposer.def( 
                "clearStatistics"
                , clearStatistics_function_value
                , ( bp::arg("monid") )
                , bp::release_gil_policy()
                , "Clear the statistics of the monitors that match the ID monid.\nThis does nothing if there are no matching monitors" );
        
        }
        { //::SireSystem::System::collectStats
        
            typedef void ( ::SireSystem::System::*collectStats_function_type)(  ) ;
            collectStats_function_type collectStats_function_value( &::SireSystem::System::collectStats );
            
            System_exposer.def( 
                "collectStats"
                , collectStats_function_value
                , bp::release_gil_policy()
                , "Collect statistics about the current configuration" );
        
        }
        { //::SireSystem::System::componentExpression
        
            typedef ::SireCAS::Expression ( ::SireSystem::System::*componentExpression_function_type)( ::SireCAS::Symbol const & ) const;
            componentExpression_function_type componentExpression_function_value( &::SireSystem::System::componentExpression );
            
            System_exposer.def( 
                "componentExpression"
                , componentExpression_function_value
                , ( bp::arg("symbol") )
                , bp::release_gil_policy()
                , "Return the expression that defines the component represented\nby the symbol symbol\nThrow: SireFF::missing_component\n" );
        
        }
        { //::SireSystem::System::componentExpressions
        
            typedef ::QHash< SireCAS::Symbol, SireCAS::Expression > ( ::SireSystem::System::*componentExpressions_function_type)( ::QSet< SireCAS::Symbol > const & ) const;
            componentExpressions_function_type componentExpressions_function_value( &::SireSystem::System::componentExpressions );
            
            System_exposer.def( 
                "componentExpressions"
                , componentExpressions_function_value
                , ( bp::arg("symbols") )
                , bp::release_gil_policy()
                , "Return the expressions that define the components whose\nsymbols are in symbols\nThrow: SireFF::missing_component\n" );
        
        }
        { //::SireSystem::System::componentExpressions
        
            typedef ::QHash< SireCAS::Symbol, SireCAS::Expression > ( ::SireSystem::System::*componentExpressions_function_type)(  ) const;
            componentExpressions_function_type componentExpressions_function_value( &::SireSystem::System::componentExpressions );
            
            System_exposer.def( 
                "componentExpressions"
                , componentExpressions_function_value
                , bp::release_gil_policy()
                , "Return all of the expressions that define all of the components\nof this system" );
        
        }
        { //::SireSystem::System::componentSymbols
        
            typedef ::QSet< SireCAS::Symbol > ( ::SireSystem::System::*componentSymbols_function_type)(  ) const;
            componentSymbols_function_type componentSymbols_function_value( &::SireSystem::System::componentSymbols );
            
            System_exposer.def( 
                "componentSymbols"
                , componentSymbols_function_value
                , bp::release_gil_policy()
                , "Return all of the symbols that represent the constant and\nenergy components of this system" );
        
        }
        { //::SireSystem::System::componentValue
        
            typedef double ( ::SireSystem::System::*componentValue_function_type)( ::SireCAS::Symbol const & ) ;
            componentValue_function_type componentValue_function_value( &::SireSystem::System::componentValue );
            
            System_exposer.def( 
                "componentValue"
                , componentValue_function_value
                , ( bp::arg("symbol") )
                , bp::release_gil_policy()
                , "Return the value of the energy or constant component\nwith symbol symbol\nThrow: SireFF::missing_component\n" );
        
        }
        { //::SireSystem::System::componentValues
        
            typedef ::SireCAS::Values ( ::SireSystem::System::*componentValues_function_type)(  ) ;
            componentValues_function_type componentValues_function_value( &::SireSystem::System::componentValues );
            
            System_exposer.def( 
                "componentValues"
                , componentValues_function_value
                , bp::release_gil_policy()
                , "Return the values of all components of this system\n(constant components and energies)" );
        
        }
        { //::SireSystem::System::componentValues
        
            typedef ::SireCAS::Values ( ::SireSystem::System::*componentValues_function_type)( ::QSet< SireCAS::Symbol > const & ) ;
            componentValues_function_type componentValues_function_value( &::SireSystem::System::componentValues );
            
            System_exposer.def( 
                "componentValues"
                , componentValues_function_value
                , ( bp::arg("symbols") )
                , bp::release_gil_policy()
                , "Retunr the value of the energy or constant component values\nwhose symbols are in symbols\nThrow: SireFF::missing_component\n" );
        
        }
        { //::SireSystem::System::compoundProperty
        
            typedef ::SireBase::Property const & ( ::SireSystem::System::*compoundProperty_function_type)( ::QString const & ) const;
            compoundProperty_function_type compoundProperty_function_value( &::SireSystem::System::compoundProperty );
            
            System_exposer.def( 
                "compoundProperty"
                , compoundProperty_function_value
                , ( bp::arg("name") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Return the raw compound property with name name - this returns\nthe property representing the link, or the combined property,\nand raises an exception if a compound property with this name\ndoes not exist\nThrow: SireBase::missing_property\n" );
        
        }
        { //::SireSystem::System::constant
        
            typedef double ( ::SireSystem::System::*constant_function_type)( ::SireCAS::Symbol const & ) const;
            constant_function_type constant_function_value( &::SireSystem::System::constant );
            
            System_exposer.def( 
                "constant"
                , constant_function_value
                , ( bp::arg("component") )
                , bp::release_gil_policy()
                , "Return the constant value for the constant component component\nThrow: SireFF::missing_component\n" );
        
        }
        { //::SireSystem::System::constantComponents
        
            typedef ::SireCAS::Values ( ::SireSystem::System::*constantComponents_function_type)(  ) const;
            constantComponents_function_type constantComponents_function_value( &::SireSystem::System::constantComponents );
            
            System_exposer.def( 
                "constantComponents"
                , constantComponents_function_value
                , bp::release_gil_policy()
                , "Return the values of all constant components of this system" );
        
        }
        { //::SireSystem::System::constantExpression
        
            typedef ::SireCAS::Expression ( ::SireSystem::System::*constantExpression_function_type)( ::SireCAS::Symbol const & ) const;
            constantExpression_function_type constantExpression_function_value( &::SireSystem::System::constantExpression );
            
            System_exposer.def( 
                "constantExpression"
                , constantExpression_function_value
                , ( bp::arg("symbol") )
                , bp::release_gil_policy()
                , "Return the expression that defines the constant component with\nsymbol symbol\nThrow: SireFF::missing_component\n" );
        
        }
        { //::SireSystem::System::constantExpressions
        
            typedef ::QHash< SireCAS::Symbol, SireCAS::Expression > ( ::SireSystem::System::*constantExpressions_function_type)( ::QSet< SireCAS::Symbol > const & ) const;
            constantExpressions_function_type constantExpressions_function_value( &::SireSystem::System::constantExpressions );
            
            System_exposer.def( 
                "constantExpressions"
                , constantExpressions_function_value
                , ( bp::arg("symbols") )
                , bp::release_gil_policy()
                , "Return the expressions that define the constant components\nwhose symbols are in symbols\nThrow: SireFF::missing_component\n" );
        
        }
        { //::SireSystem::System::constantExpressions
        
            typedef ::QHash< SireCAS::Symbol, SireCAS::Expression > ( ::SireSystem::System::*constantExpressions_function_type)(  ) const;
            constantExpressions_function_type constantExpressions_function_value( &::SireSystem::System::constantExpressions );
            
            System_exposer.def( 
                "constantExpressions"
                , constantExpressions_function_value
                , bp::release_gil_policy()
                , "Return all of the expressions that define the constant components\nof this system" );
        
        }
        { //::SireSystem::System::constantSymbols
        
            typedef ::QSet< SireCAS::Symbol > ( ::SireSystem::System::*constantSymbols_function_type)(  ) const;
            constantSymbols_function_type constantSymbols_function_value( &::SireSystem::System::constantSymbols );
            
            System_exposer.def( 
                "constantSymbols"
                , constantSymbols_function_value
                , bp::release_gil_policy()
                , "Return the symbols that represent constant components of this system" );
        
        }
        { //::SireSystem::System::constants
        
            typedef ::SireCAS::Values ( ::SireSystem::System::*constants_function_type)(  ) const;
            constants_function_type constants_function_value( &::SireSystem::System::constants );
            
            System_exposer.def( 
                "constants"
                , constants_function_value
                , bp::release_gil_policy()
                , "Return the values of all constant components in this system" );
        
        }
        { //::SireSystem::System::constants
        
            typedef ::SireCAS::Values ( ::SireSystem::System::*constants_function_type)( ::QSet< SireCAS::Symbol > const & ) const;
            constants_function_type constants_function_value( &::SireSystem::System::constants );
            
            System_exposer.def( 
                "constants"
                , constants_function_value
                , ( bp::arg("components") )
                , bp::release_gil_policy()
                , "Return the values of the constant components whose symbols\nare in components\nThrow: SireFF::missing_component\n" );
        
        }
        { //::SireSystem::System::constraints
        
            typedef ::SireSystem::Constraints const & ( ::SireSystem::System::*constraints_function_type)(  ) const;
            constraints_function_type constraints_function_value( &::SireSystem::System::constraints );
            
            System_exposer.def( 
                "constraints"
                , constraints_function_value
                , bp::return_value_policy< bp::copy_const_reference >()
                , "Return all of the contraints that are applied to the system" );
        
        }
        { //::SireSystem::System::constraintsSatisfied
        
            typedef bool ( ::SireSystem::System::*constraintsSatisfied_function_type)(  ) const;
            constraintsSatisfied_function_type constraintsSatisfied_function_value( &::SireSystem::System::constraintsSatisfied );
            
            System_exposer.def( 
                "constraintsSatisfied"
                , constraintsSatisfied_function_value
                , bp::release_gil_policy()
                , "Return whether or not the constraints are satisfied" );
        
        }
        { //::SireSystem::System::containsProperty
        
            typedef bool ( ::SireSystem::System::*containsProperty_function_type)( ::QString const & ) const;
            containsProperty_function_type containsProperty_function_value( &::SireSystem::System::containsProperty );
            
            System_exposer.def( 
                "containsProperty"
                , containsProperty_function_value
                , ( bp::arg("name") )
                , bp::release_gil_policy()
                , "Return whether or not any of the forcefields contain a property called name" );
        
        }
        { //::SireSystem::System::containsProperty
        
            typedef bool ( ::SireSystem::System::*containsProperty_function_type)( ::SireFF::FFID const &,::QString const & ) const;
            containsProperty_function_type containsProperty_function_value( &::SireSystem::System::containsProperty );
            
            System_exposer.def( 
                "containsProperty"
                , containsProperty_function_value
                , ( bp::arg("ffid"), bp::arg("name") )
                , bp::release_gil_policy()
                , "Return whether or not any of the forcefields identified by the ID ffid\ncontain a property called name" );
        
        }
        { //::SireSystem::System::containsProperty
        
            typedef bool ( ::SireSystem::System::*containsProperty_function_type)( ::SireBase::PropertyName const & ) const;
            containsProperty_function_type containsProperty_function_value( &::SireSystem::System::containsProperty );
            
            System_exposer.def( 
                "containsProperty"
                , containsProperty_function_value
                , ( bp::arg("name") )
                , bp::release_gil_policy()
                , "Return whether or not any of the forcefields contain a property called name" );
        
        }
        { //::SireSystem::System::containsProperty
        
            typedef bool ( ::SireSystem::System::*containsProperty_function_type)( ::SireFF::FFID const &,::SireBase::PropertyName const & ) const;
            containsProperty_function_type containsProperty_function_value( &::SireSystem::System::containsProperty );
            
            System_exposer.def( 
                "containsProperty"
                , containsProperty_function_value
                , ( bp::arg("ffid"), bp::arg("name") )
                , bp::release_gil_policy()
                , "Return whether or not any of the forcefields identified by the ID ffid\ncontain a property called name" );
        
        }
        { //::SireSystem::System::energies
        
            typedef ::SireCAS::Values ( ::SireSystem::System::*energies_function_type)(  ) ;
            energies_function_type energies_function_value( &::SireSystem::System::energies );
            
            System_exposer.def( 
                "energies"
                , energies_function_value
                , bp::release_gil_policy()
                , "Return the energies of all energy components in this system" );
        
        }
        { //::SireSystem::System::energies
        
            typedef ::SireCAS::Values ( ::SireSystem::System::*energies_function_type)( ::QSet< SireCAS::Symbol > const & ) ;
            energies_function_type energies_function_value( &::SireSystem::System::energies );
            
            System_exposer.def( 
                "energies"
                , energies_function_value
                , ( bp::arg("components") )
                , bp::release_gil_policy()
                , "Return the energies of the energy components of this system whose\nsymbols are in components\nThrow: SireFF::missing_component\n" );
        
        }
        { //::SireSystem::System::energy
        
            typedef ::SireUnits::Dimension::MolarEnergy ( ::SireSystem::System::*energy_function_type)(  ) ;
            energy_function_type energy_function_value( &::SireSystem::System::energy );
            
            System_exposer.def( 
                "energy"
                , energy_function_value
                , bp::release_gil_policy()
                , "Return the total energy of this system." );
        
        }
        { //::SireSystem::System::energy
        
            typedef ::SireUnits::Dimension::MolarEnergy ( ::SireSystem::System::*energy_function_type)( ::SireCAS::Symbol const & ) ;
            energy_function_type energy_function_value( &::SireSystem::System::energy );
            
            System_exposer.def( 
                "energy"
                , energy_function_value
                , ( bp::arg("component") )
                , bp::release_gil_policy()
                , "Return the total energy of the energy component in this system\nthat is identified by the energy component component\nThrow: SireFF::missing_component\n" );
        
        }
        { //::SireSystem::System::energy
        
            typedef void ( ::SireSystem::System::*energy_function_type)( ::SireFF::EnergyTable &,double ) ;
            energy_function_type energy_function_value( &::SireSystem::System::energy );
            
            System_exposer.def( 
                "energy"
                , energy_function_value
                , ( bp::arg("energytable"), bp::arg("scale_energy")=1 )
                , "Return the total energytable in this system\n" );
        
        }
        { //::SireSystem::System::energy
        
            typedef void ( ::SireSystem::System::*energy_function_type)( ::SireFF::EnergyTable &,::SireCAS::Symbol const &,double ) ;
            energy_function_type energy_function_value( &::SireSystem::System::energy );
            
            System_exposer.def( 
                "energy"
                , energy_function_value
                , ( bp::arg("energytable"), bp::arg("component"), bp::arg("scale_energy")=1 )
                , "Return the total energytable of the energy component in this system\nthat is identified by the energy component component\n" );
        
        }
        { //::SireSystem::System::energyComponents
        
            typedef ::SireCAS::Values ( ::SireSystem::System::*energyComponents_function_type)(  ) ;
            energyComponents_function_type energyComponents_function_value( &::SireSystem::System::energyComponents );
            
            System_exposer.def( 
                "energyComponents"
                , energyComponents_function_value
                , bp::release_gil_policy()
                , "Return all of the energy components of this system" );
        
        }
        { //::SireSystem::System::energyExpression
        
            typedef ::SireCAS::Expression ( ::SireSystem::System::*energyExpression_function_type)( ::SireCAS::Symbol const & ) const;
            energyExpression_function_type energyExpression_function_value( &::SireSystem::System::energyExpression );
            
            System_exposer.def( 
                "energyExpression"
                , energyExpression_function_value
                , ( bp::arg("expression") )
                , bp::release_gil_policy()
                , "Return the energy expression for the energy component component\nThrow: SireFF::missing_component\n" );
        
        }
        { //::SireSystem::System::energyExpressions
        
            typedef ::QHash< SireCAS::Symbol, SireCAS::Expression > ( ::SireSystem::System::*energyExpressions_function_type)( ::QSet< SireCAS::Symbol > const & ) const;
            energyExpressions_function_type energyExpressions_function_value( &::SireSystem::System::energyExpressions );
            
            System_exposer.def( 
                "energyExpressions"
                , energyExpressions_function_value
                , ( bp::arg("symbols") )
                , bp::release_gil_policy()
                , "Return the energy expressions for the energy components whose\nsymbols are in symbols\nThrow: SireFF::missing_component\n" );
        
        }
        { //::SireSystem::System::energyExpressions
        
            typedef ::QHash< SireCAS::Symbol, SireCAS::Expression > ( ::SireSystem::System::*energyExpressions_function_type)(  ) const;
            energyExpressions_function_type energyExpressions_function_value( &::SireSystem::System::energyExpressions );
            
            System_exposer.def( 
                "energyExpressions"
                , energyExpressions_function_value
                , bp::release_gil_policy()
                , "Return all of the energy expressions in this system" );
        
        }
        { //::SireSystem::System::energySymbols
        
            typedef ::QSet< SireCAS::Symbol > ( ::SireSystem::System::*energySymbols_function_type)(  ) const;
            energySymbols_function_type energySymbols_function_value( &::SireSystem::System::energySymbols );
            
            System_exposer.def( 
                "energySymbols"
                , energySymbols_function_value
                , bp::release_gil_policy()
                , "Return the symbols that represent the energy expressions of this system" );
        
        }
        { //::SireSystem::System::extraGroups
        
            typedef ::SireMol::MoleculeGroups const & ( ::SireSystem::System::*extraGroups_function_type)(  ) const;
            extraGroups_function_type extraGroups_function_value( &::SireSystem::System::extraGroups );
            
            System_exposer.def( 
                "extraGroups"
                , extraGroups_function_value
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Return all of the extra non-forcefield molecule groups in this system" );
        
        }
        { //::SireSystem::System::ffIdx
        
            typedef ::SireFF::FFIdx ( ::SireSystem::System::*ffIdx_function_type)( ::SireFF::FFID const & ) const;
            ffIdx_function_type ffIdx_function_value( &::SireSystem::System::ffIdx );
            
            System_exposer.def( 
                "ffIdx"
                , ffIdx_function_value
                , ( bp::arg("ffid") )
                , bp::release_gil_policy()
                , "Return the index of the forcefield with ID ffid\nThrow: SireFF::missing_forcefield\nThrow: SireFF::duplicate_forcefield\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireSystem::System::ffName
        
            typedef ::SireFF::FFName const & ( ::SireSystem::System::*ffName_function_type)( ::SireFF::FFID const & ) const;
            ffName_function_type ffName_function_value( &::SireSystem::System::ffName );
            
            System_exposer.def( 
                "ffName"
                , ffName_function_value
                , ( bp::arg("ffid") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Return the name of the forcefield with ID ffid\nThrow: SireFF::missing_forcefield\nThrow: SireFF::duplicate_forcefield\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireSystem::System::field
        
            typedef void ( ::SireSystem::System::*field_function_type)( ::SireFF::FieldTable &,double ) ;
            field_function_type field_function_value( &::SireSystem::System::field );
            
            System_exposer.def( 
                "field"
                , field_function_value
                , ( bp::arg("fieldtable"), bp::arg("scale_field")=1 )
                , "Add the fields acting on the molecules in the fieldtable fieldtable\nfrom this system onto this fieldtable, scaled by the optionally\nsupplied scale_field" );
        
        }
        { //::SireSystem::System::field
        
            typedef void ( ::SireSystem::System::*field_function_type)( ::SireFF::FieldTable &,::SireCAS::Symbol const &,double ) ;
            field_function_type field_function_value( &::SireSystem::System::field );
            
            System_exposer.def( 
                "field"
                , field_function_value
                , ( bp::arg("fieldtable"), bp::arg("component"), bp::arg("scale_field")=1 )
                , "Add the fields acting on the molecules in the fieldtable fieldtable\nfrom the component of this system identified by component onto\nthis fieldtable, scaled by the optionally supplied scale_field" );
        
        }
        { //::SireSystem::System::field
        
            typedef void ( ::SireSystem::System::*field_function_type)( ::SireFF::FieldTable &,::SireFF::Probe const &,double ) ;
            field_function_type field_function_value( &::SireSystem::System::field );
            
            System_exposer.def( 
                "field"
                , field_function_value
                , ( bp::arg("fieldtable"), bp::arg("probe"), bp::arg("scale_field")=1 )
                , "Add the fields acting on the molecules in the fieldtable fieldtable\nfrom this system onto this fieldtable, scaled by the optionally\nsupplied scale_field" );
        
        }
        { //::SireSystem::System::field
        
            typedef void ( ::SireSystem::System::*field_function_type)( ::SireFF::FieldTable &,::SireCAS::Symbol const &,::SireFF::Probe const &,double ) ;
            field_function_type field_function_value( &::SireSystem::System::field );
            
            System_exposer.def( 
                "field"
                , field_function_value
                , ( bp::arg("fieldtable"), bp::arg("component"), bp::arg("probe"), bp::arg("scale_field")=1 )
                , "Add the fields acting on the molecules in the fieldtable fieldtable\nfrom the component of this system identified by component onto\nthis fieldtable, scaled by the optionally supplied scale_field" );
        
        }
        { //::SireSystem::System::force
        
            typedef void ( ::SireSystem::System::*force_function_type)( ::SireFF::ForceTable &,double ) ;
            force_function_type force_function_value( &::SireSystem::System::force );
            
            System_exposer.def( 
                "force"
                , force_function_value
                , ( bp::arg("forcetable"), bp::arg("scale_force")=1 )
                , "Add the forces acting on the molecules in the forcetable forcetable\nfrom this system onto this forcetable, scaled by the optionally\nsupplied scale_force" );
        
        }
        { //::SireSystem::System::force
        
            typedef void ( ::SireSystem::System::*force_function_type)( ::SireFF::ForceTable &,::SireCAS::Symbol const &,double ) ;
            force_function_type force_function_value( &::SireSystem::System::force );
            
            System_exposer.def( 
                "force"
                , force_function_value
                , ( bp::arg("forcetable"), bp::arg("component"), bp::arg("scale_force")=1 )
                , "Add the forces acting on the molecules in the forcetable forcetable\nfrom the component of this system identified by component onto\nthis forcetable, scaled by the optionally supplied scale_force" );
        
        }
        { //::SireSystem::System::forceField
        
            typedef ::SireFF::FF const & ( ::SireSystem::System::*forceField_function_type)( ::SireFF::FFID const & ) const;
            forceField_function_type forceField_function_value( &::SireSystem::System::forceField );
            
            System_exposer.def( 
                "forceField"
                , forceField_function_value
                , ( bp::arg("ffid") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Return the forcefield with ID ffid in this system\nThrow: SireFF::missing_forcefield\nThrow: SireFF::duplicate_forcefield\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireSystem::System::forceField
        
            typedef ::SireFF::FF const & ( ::SireSystem::System::*forceField_function_type)( ::SireMol::MGID const & ) const;
            forceField_function_type forceField_function_value( &::SireSystem::System::forceField );
            
            System_exposer.def( 
                "forceField"
                , forceField_function_value
                , ( bp::arg("mgid") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Return the forcefield that contains the molecule group\nidentified by the ID mgid\nThrow: SireMol::missing_group\nThrow: SireMol::duplicate_group\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireSystem::System::forceFields
        
            typedef ::SireFF::ForceFields const & ( ::SireSystem::System::*forceFields_function_type)(  ) const;
            forceFields_function_type forceFields_function_value( &::SireSystem::System::forceFields );
            
            System_exposer.def( 
                "forceFields"
                , forceFields_function_value
                , bp::return_value_policy< bp::copy_const_reference >()
                , "Return an array of all of the forcefields in this system" );
        
        }
        { //::SireSystem::System::hasComponent
        
            typedef bool ( ::SireSystem::System::*hasComponent_function_type)( ::SireCAS::Symbol const & ) const;
            hasComponent_function_type hasComponent_function_value( &::SireSystem::System::hasComponent );
            
            System_exposer.def( 
                "hasComponent"
                , hasComponent_function_value
                , ( bp::arg("symbol") )
                , bp::release_gil_policy()
                , "Return whether or not this system has a constant or energy\ncomponent represented by the symbol symbol" );
        
        }
        { //::SireSystem::System::hasConstantComponent
        
            typedef bool ( ::SireSystem::System::*hasConstantComponent_function_type)( ::SireCAS::Symbol const & ) const;
            hasConstantComponent_function_type hasConstantComponent_function_value( &::SireSystem::System::hasConstantComponent );
            
            System_exposer.def( 
                "hasConstantComponent"
                , hasConstantComponent_function_value
                , ( bp::arg("component") )
                , bp::release_gil_policy()
                , "Return whether or not this system has a constant\ncomponent with symbol component" );
        
        }
        { //::SireSystem::System::hasEnergyComponent
        
            typedef bool ( ::SireSystem::System::*hasEnergyComponent_function_type)( ::SireCAS::Symbol const & ) const;
            hasEnergyComponent_function_type hasEnergyComponent_function_value( &::SireSystem::System::hasEnergyComponent );
            
            System_exposer.def( 
                "hasEnergyComponent"
                , hasEnergyComponent_function_value
                , ( bp::arg("component") )
                , bp::release_gil_policy()
                , "Return whether or not this system has an energy component component" );
        
        }
        { //::SireSystem::System::isBuiltinProperty
        
            typedef bool ( ::SireSystem::System::*isBuiltinProperty_function_type)( ::QString const & ) const;
            isBuiltinProperty_function_type isBuiltinProperty_function_value( &::SireSystem::System::isBuiltinProperty );
            
            System_exposer.def( 
                "isBuiltinProperty"
                , isBuiltinProperty_function_value
                , ( bp::arg("name") )
                , bp::release_gil_policy()
                , "Return whether or not the property name exists and is a builtin\nproperty of one of the forcefields in this System" );
        
        }
        { //::SireSystem::System::isClean
        
            typedef bool ( ::SireSystem::System::*isClean_function_type)(  ) const;
            isClean_function_type isClean_function_value( &::SireSystem::System::isClean );
            
            System_exposer.def( 
                "isClean"
                , isClean_function_value
                , bp::release_gil_policy()
                , "Return whether or not all of the forcefields are clean" );
        
        }
        { //::SireSystem::System::isCompoundProperty
        
            typedef bool ( ::SireSystem::System::*isCompoundProperty_function_type)( ::QString const & ) const;
            isCompoundProperty_function_type isCompoundProperty_function_value( &::SireSystem::System::isCompoundProperty );
            
            System_exposer.def( 
                "isCompoundProperty"
                , isCompoundProperty_function_value
                , ( bp::arg("name") )
                , bp::release_gil_policy()
                , "Return whether or not the property name exists and is a compound\nproperty (either a link or a combined property)" );
        
        }
        { //::SireSystem::System::isConstantComponent
        
            typedef bool ( ::SireSystem::System::*isConstantComponent_function_type)( ::SireCAS::Symbol const & ) const;
            isConstantComponent_function_type isConstantComponent_function_value( &::SireSystem::System::isConstantComponent );
            
            System_exposer.def( 
                "isConstantComponent"
                , isConstantComponent_function_value
                , ( bp::arg("component") )
                , bp::release_gil_policy()
                , "Return whether or not the system component component\nis a constant component\nThrow: SireFF::missing_component\n" );
        
        }
        { //::SireSystem::System::isDirty
        
            typedef bool ( ::SireSystem::System::*isDirty_function_type)(  ) const;
            isDirty_function_type isDirty_function_value( &::SireSystem::System::isDirty );
            
            System_exposer.def( 
                "isDirty"
                , isDirty_function_value
                , bp::release_gil_policy()
                , "Return whether or not any of the forcefields are dirty" );
        
        }
        { //::SireSystem::System::isEnergyComponent
        
            typedef bool ( ::SireSystem::System::*isEnergyComponent_function_type)( ::SireCAS::Symbol const & ) const;
            isEnergyComponent_function_type isEnergyComponent_function_value( &::SireSystem::System::isEnergyComponent );
            
            System_exposer.def( 
                "isEnergyComponent"
                , isEnergyComponent_function_value
                , ( bp::arg("component") )
                , bp::release_gil_policy()
                , "Return whether or not the component component is an energy component\nThrow: SireFF::missing_component\n" );
        
        }
        { //::SireSystem::System::isUserProperty
        
            typedef bool ( ::SireSystem::System::*isUserProperty_function_type)( ::QString const & ) const;
            isUserProperty_function_type isUserProperty_function_value( &::SireSystem::System::isUserProperty );
            
            System_exposer.def( 
                "isUserProperty"
                , isUserProperty_function_value
                , ( bp::arg("name") )
                , bp::release_gil_policy()
                , "Return whether or not the property name exists and is a user\nsupplied property (either a compound property or an extra\nSystem property)" );
        
        }
        { //::SireSystem::System::monitor
        
            typedef ::SireSystem::SystemMonitor const & ( ::SireSystem::System::*monitor_function_type)( ::SireSystem::MonitorID const & ) const;
            monitor_function_type monitor_function_value( &::SireSystem::System::monitor );
            
            System_exposer.def( 
                "monitor"
                , monitor_function_value
                , ( bp::arg("monid") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Return the monitor at ID monid\nThrow: SireSystem::missing_monitor\nThrow: SireSystem::duplicate_monitor\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireSystem::System::monitorName
        
            typedef ::SireSystem::MonitorName ( ::SireSystem::System::*monitorName_function_type)( ::SireSystem::MonitorID const & ) const;
            monitorName_function_type monitorName_function_value( &::SireSystem::System::monitorName );
            
            System_exposer.def( 
                "monitorName"
                , monitorName_function_value
                , ( bp::arg("monid") )
                , bp::release_gil_policy()
                , "Return the name of the monitor at ID monid\nThrow: SireSystem::missing_monitor\nThrow: SireSystem::duplicate_monitor\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireSystem::System::monitors
        
            typedef ::QList< SireBase::PropPtr< SireSystem::SystemMonitor > > ( ::SireSystem::System::*monitors_function_type)( ::SireSystem::MonitorID const & ) const;
            monitors_function_type monitors_function_value( &::SireSystem::System::monitors );
            
            System_exposer.def( 
                "monitors"
                , monitors_function_value
                , ( bp::arg("monid") )
                , bp::release_gil_policy()
                , "Return the monitors with ID monid\nThrow: SireSystem::missing_monitor\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireSystem::System::monitors
        
            typedef ::SireSystem::SystemMonitors const & ( ::SireSystem::System::*monitors_function_type)(  ) const;
            monitors_function_type monitors_function_value( &::SireSystem::System::monitors );
            
            System_exposer.def( 
                "monitors"
                , monitors_function_value
                , bp::return_value_policy< bp::copy_const_reference >()
                , "Return the list of all monitors of this system" );
        
        }
        { //::SireSystem::System::mustNowRecalculateFromScratch
        
            typedef void ( ::SireSystem::System::*mustNowRecalculateFromScratch_function_type)(  ) ;
            mustNowRecalculateFromScratch_function_type mustNowRecalculateFromScratch_function_value( &::SireSystem::System::mustNowRecalculateFromScratch );
            
            System_exposer.def( 
                "mustNowRecalculateFromScratch"
                , mustNowRecalculateFromScratch_function_value
                , bp::release_gil_policy()
                , "Tell all of the forcefields that they will need to recalculate\ntheir energies from scratch. This can speed up calculations where\nyou know that the majority (or all) of the molecules will be\nchanging" );
        
        }
        { //::SireSystem::System::nConstraints
        
            typedef int ( ::SireSystem::System::*nConstraints_function_type)(  ) const;
            nConstraints_function_type nConstraints_function_value( &::SireSystem::System::nConstraints );
            
            System_exposer.def( 
                "nConstraints"
                , nConstraints_function_value
                , bp::release_gil_policy()
                , "Return the number of constraints on the system" );
        
        }
        { //::SireSystem::System::nForceFields
        
            typedef int ( ::SireSystem::System::*nForceFields_function_type)(  ) const;
            nForceFields_function_type nForceFields_function_value( &::SireSystem::System::nForceFields );
            
            System_exposer.def( 
                "nForceFields"
                , nForceFields_function_value
                , bp::release_gil_policy()
                , "Return the number of forcefields in this system" );
        
        }
        { //::SireSystem::System::nMonitors
        
            typedef int ( ::SireSystem::System::*nMonitors_function_type)(  ) const;
            nMonitors_function_type nMonitors_function_value( &::SireSystem::System::nMonitors );
            
            System_exposer.def( 
                "nMonitors"
                , nMonitors_function_value
                , bp::release_gil_policy()
                , "Return the number of monitors in this system" );
        
        }
        { //::SireSystem::System::name
        
            typedef ::SireSystem::SysName const & ( ::SireSystem::System::*name_function_type)(  ) const;
            name_function_type name_function_value( &::SireSystem::System::name );
            
            System_exposer.def( 
                "name"
                , name_function_value
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "" );
        
        }
        { //::SireSystem::System::needsAccepting
        
            typedef bool ( ::SireSystem::System::*needsAccepting_function_type)(  ) const;
            needsAccepting_function_type needsAccepting_function_value( &::SireSystem::System::needsAccepting );
            
            System_exposer.def( 
                "needsAccepting"
                , needsAccepting_function_value
                , bp::release_gil_policy()
                , "Return whether or not any part of the forcefield is using temporary\nworkspaces that need to be accepted" );
        
        }
        { //::SireSystem::System::null
        
            typedef ::SireSystem::System const & ( *null_function_type )(  );
            null_function_type null_function_value( &::SireSystem::System::null );
            
            System_exposer.def( 
                "null"
                , null_function_value
                , bp::return_value_policy< bp::copy_const_reference >()
                , "" );
        
        }
        System_exposer.def( bp::self != bp::self );
        { //::SireSystem::System::operator=
        
            typedef ::SireSystem::System & ( ::SireSystem::System::*assign_function_type)( ::SireSystem::System const & ) ;
            assign_function_type assign_function_value( &::SireSystem::System::operator= );
            
            System_exposer.def( 
                "assign"
                , assign_function_value
                , ( bp::arg("other") )
                , bp::return_self< >()
                , "" );
        
        }
        System_exposer.def( bp::self == bp::self );
        { //::SireSystem::System::operator[]
        
            typedef ::SireFF::FF const & ( ::SireSystem::System::*__getitem___function_type)( ::SireFF::FFID const & ) const;
            __getitem___function_type __getitem___function_value( &::SireSystem::System::operator[] );
            
            System_exposer.def( 
                "__getitem__"
                , __getitem___function_value
                , ( bp::arg("ffid") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "" );
        
        }
        { //::SireSystem::System::operator[]
        
            typedef ::SireSystem::SystemMonitor const & ( ::SireSystem::System::*__getitem___function_type)( ::SireSystem::MonitorID const & ) const;
            __getitem___function_type __getitem___function_value( &::SireSystem::System::operator[] );
            
            System_exposer.def( 
                "__getitem__"
                , __getitem___function_value
                , ( bp::arg("monid") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "" );
        
        }
        { //::SireSystem::System::operator[]
        
            typedef ::SireMol::MoleculeGroup const & ( ::SireSystem::System::*__getitem___function_type)( ::SireMol::MGID const & ) const;
            __getitem___function_type __getitem___function_value( &::SireSystem::System::operator[] );
            
            System_exposer.def( 
                "__getitem__"
                , __getitem___function_value
                , ( bp::arg("mgid") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "" );
        
        }
        { //::SireSystem::System::operator[]
        
            typedef ::SireMol::ViewsOfMol ( ::SireSystem::System::*__getitem___function_type)( int ) const;
            __getitem___function_type __getitem___function_value( &::SireSystem::System::operator[] );
            
            System_exposer.def( 
                "__getitem__"
                , __getitem___function_value
                , ( bp::arg("i") )
                , "" );
        
        }
        { //::SireSystem::System::operator[]
        
            typedef ::SireMol::ViewsOfMol ( ::SireSystem::System::*__getitem___function_type)( ::QString const & ) const;
            __getitem___function_type __getitem___function_value( &::SireSystem::System::operator[] );
            
            System_exposer.def( 
                "__getitem__"
                , __getitem___function_value
                , ( bp::arg("name") )
                , "" );
        
        }
        { //::SireSystem::System::operator[]
        
            typedef ::QList< SireBase::PropPtr< SireMol::MoleculeView > > ( ::SireSystem::System::*__getitem___function_type)( ::SireBase::Slice const & ) const;
            __getitem___function_type __getitem___function_value( &::SireSystem::System::operator[] );
            
            System_exposer.def( 
                "__getitem__"
                , __getitem___function_value
                , ( bp::arg("slice") )
                , "" );
        
        }
        { //::SireSystem::System::operator[]
        
            typedef ::SireMol::ViewsOfMol ( ::SireSystem::System::*__getitem___function_type)( ::SireMol::MolNum ) const;
            __getitem___function_type __getitem___function_value( &::SireSystem::System::operator[] );
            
            System_exposer.def( 
                "__getitem__"
                , __getitem___function_value
                , ( bp::arg("molnum") )
                , "" );
        
        }
        { //::SireSystem::System::operator[]
        
            typedef ::SireMol::ViewsOfMol ( ::SireSystem::System::*__getitem___function_type)( ::SireMol::MolID const & ) const;
            __getitem___function_type __getitem___function_value( &::SireSystem::System::operator[] );
            
            System_exposer.def( 
                "__getitem__"
                , __getitem___function_value
                , ( bp::arg("molid") )
                , "" );
        
        }
        { //::SireSystem::System::potential
        
            typedef void ( ::SireSystem::System::*potential_function_type)( ::SireFF::PotentialTable &,::SireFF::Probe const &,double ) ;
            potential_function_type potential_function_value( &::SireSystem::System::potential );
            
            System_exposer.def( 
                "potential"
                , potential_function_value
                , ( bp::arg("pottable"), bp::arg("probe"), bp::arg("scale_potential")=1 )
                , "Add the potentials acting on the molecules in the potential table pottable\nfrom this system onto this potential table, scaled by the optionally\nsupplied scale_potential" );
        
        }
        { //::SireSystem::System::potential
        
            typedef void ( ::SireSystem::System::*potential_function_type)( ::SireFF::PotentialTable &,::SireCAS::Symbol const &,::SireFF::Probe const &,double ) ;
            potential_function_type potential_function_value( &::SireSystem::System::potential );
            
            System_exposer.def( 
                "potential"
                , potential_function_value
                , ( bp::arg("pottable"), bp::arg("component"), bp::arg("probe"), bp::arg("scale_potential")=1 )
                , "Add the potentials acting on the molecules in the potential table pottable\nfrom the component of this system identified by component onto\nthis potential table, scaled by the optionally supplied scale_potential" );
        
        }
        { //::SireSystem::System::potential
        
            typedef void ( ::SireSystem::System::*potential_function_type)( ::SireFF::PotentialTable &,double ) ;
            potential_function_type potential_function_value( &::SireSystem::System::potential );
            
            System_exposer.def( 
                "potential"
                , potential_function_value
                , ( bp::arg("pottable"), bp::arg("scale_potential")=1 )
                , "Add the potentials acting on the molecules in the potential table pottable\nfrom this system onto this potential table, scaled by the optionally\nsupplied scale_potential" );
        
        }
        { //::SireSystem::System::potential
        
            typedef void ( ::SireSystem::System::*potential_function_type)( ::SireFF::PotentialTable &,::SireCAS::Symbol const &,double ) ;
            potential_function_type potential_function_value( &::SireSystem::System::potential );
            
            System_exposer.def( 
                "potential"
                , potential_function_value
                , ( bp::arg("pottable"), bp::arg("component"), bp::arg("scale_potential")=1 )
                , "Add the potentials acting on the molecules in the potential table pottable\nfrom the component of this system identified by component onto\nthis potential table, scaled by the optionally supplied scale_potential" );
        
        }
        { //::SireSystem::System::properties
        
            typedef ::SireBase::Properties ( ::SireSystem::System::*properties_function_type)(  ) const;
            properties_function_type properties_function_value( &::SireSystem::System::properties );
            
            System_exposer.def( 
                "properties"
                , properties_function_value
                , bp::release_gil_policy()
                , "Return the values of all of the properties of this system\nThrow: SireBase::duplicate_property\n" );
        
        }
        { //::SireSystem::System::properties
        
            typedef ::SireBase::Properties ( ::SireSystem::System::*properties_function_type)( ::SireFF::FFID const & ) const;
            properties_function_type properties_function_value( &::SireSystem::System::properties );
            
            System_exposer.def( 
                "properties"
                , properties_function_value
                , ( bp::arg("ffid") )
                , bp::release_gil_policy()
                , "Return the values of all of the properties of this system that\nare in the forcefields that match the ID ffid\nThrow: SireBase::duplicate_property\nThrow: SireFF::missing_forcefield\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireSystem::System::property
        
            typedef ::SireBase::Property const & ( ::SireSystem::System::*property_function_type)( ::SireBase::PropertyName const & ) const;
            property_function_type property_function_value( &::SireSystem::System::property );
            
            System_exposer.def( 
                "property"
                , property_function_value
                , ( bp::arg("name") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Return the values of the property called name in all of the\nforcefields that contain this property\nThrow: SireBase::missing_property\nThrow: SireBase::duplicate_property\n" );
        
        }
        { //::SireSystem::System::property
        
            typedef ::SireBase::Property const & ( ::SireSystem::System::*property_function_type)( ::SireFF::FFID const &,::SireBase::PropertyName const & ) const;
            property_function_type property_function_value( &::SireSystem::System::property );
            
            System_exposer.def( 
                "property"
                , property_function_value
                , ( bp::arg("ffid"), bp::arg("name") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Return the value of the property name in the forcefield identified\nby the ID ffid\nThrow: SireBase::duplicate_property\nThrow: SireFF::missing_forcefield\nThrow: SireBase::missing_property\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireSystem::System::propertyKeys
        
            typedef ::QStringList ( ::SireSystem::System::*propertyKeys_function_type)(  ) const;
            propertyKeys_function_type propertyKeys_function_value( &::SireSystem::System::propertyKeys );
            
            System_exposer.def( 
                "propertyKeys"
                , propertyKeys_function_value
                , bp::release_gil_policy()
                , "Return the names of all of the properties of this system" );
        
        }
        { //::SireSystem::System::propertyKeys
        
            typedef ::QStringList ( ::SireSystem::System::*propertyKeys_function_type)( ::SireFF::FFID const & ) const;
            propertyKeys_function_type propertyKeys_function_value( &::SireSystem::System::propertyKeys );
            
            System_exposer.def( 
                "propertyKeys"
                , propertyKeys_function_value
                , ( bp::arg("ffid") )
                , bp::release_gil_policy()
                , "Return the names of all of the properties of the forcefields in\nthis system that match the ID ffid\nThrow: SireFF::missing_forcefield\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireSystem::System::remove
        
            typedef void ( ::SireSystem::System::*remove_function_type)( ::SireSystem::MonitorID const & ) ;
            remove_function_type remove_function_value( &::SireSystem::System::remove );
            
            System_exposer.def( 
                "remove"
                , remove_function_value
                , ( bp::arg("monid") )
                , bp::release_gil_policy()
                , "Remove all monitors that match the ID monid\nThrow: SireSystem::missing_monitor\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireSystem::System::remove
        
            typedef void ( ::SireSystem::System::*remove_function_type)( ::SireFF::FFID const & ) ;
            remove_function_type remove_function_value( &::SireSystem::System::remove );
            
            System_exposer.def( 
                "remove"
                , remove_function_value
                , ( bp::arg("ffid") )
                , bp::release_gil_policy()
                , "Remove the forcefield(s) that match the ID ffid\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireSystem::System::remove
        
            typedef void ( ::SireSystem::System::*remove_function_type)( ::SireFF::FF const & ) ;
            remove_function_type remove_function_value( &::SireSystem::System::remove );
            
            System_exposer.def( 
                "remove"
                , remove_function_value
                , ( bp::arg("ff") )
                , bp::release_gil_policy()
                , "Remove the forcefield ff. Note that this removes the forcefield\nin this system that has the same name as ff\nThrow: SireFF::missing_forcefield\n" );
        
        }
        { //::SireSystem::System::remove
        
            typedef bool ( ::SireSystem::System::*remove_function_type)( ::SireMol::MGID const & ) ;
            remove_function_type remove_function_value( &::SireSystem::System::remove );
            
            System_exposer.def( 
                "remove"
                , remove_function_value
                , ( bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Remove the molecule group(s) that match the ID mgid.\nNote that you cant remove molecule groups that are part\nof a forcefield\nThrow: SireMol::missing_group\nThrow: SireError::invalid_index\nThrow: SireError::invalid_arg\n" );
        
        }
        { //::SireSystem::System::remove
        
            typedef bool ( ::SireSystem::System::*remove_function_type)( ::SireMol::MoleculeGroup const & ) ;
            remove_function_type remove_function_value( &::SireSystem::System::remove );
            
            System_exposer.def( 
                "remove"
                , remove_function_value
                , ( bp::arg("molgroup") )
                , bp::release_gil_policy()
                , "Remove the molecules contained in the molecule group molgroup.\nThis doesnt remove the molecule group itself though. If you\nwant to remove the molecule group, use System::remove(molgroup.number())\nThrow: SireMol::missing_group\n" );
        
        }
        { //::SireSystem::System::remove
        
            typedef bool ( ::SireSystem::System::*remove_function_type)( ::SireMol::MolID const & ) ;
            remove_function_type remove_function_value( &::SireSystem::System::remove );
            
            System_exposer.def( 
                "remove"
                , remove_function_value
                , ( bp::arg("molid") )
                , bp::release_gil_policy()
                , "Remove all molecules from this system that match the ID molid\nThrow: SireMol::missing_molecule\n" );
        
        }
        { //::SireSystem::System::remove
        
            typedef void ( ::SireSystem::System::*remove_function_type)( ::SireSystem::Constraint const & ) ;
            remove_function_type remove_function_value( &::SireSystem::System::remove );
            
            System_exposer.def( 
                "remove"
                , remove_function_value
                , ( bp::arg("constraint") )
                , bp::release_gil_policy()
                , "Remove the constraints in constraints from the list of constraints\nthat are applied to this system" );
        
        }
        { //::SireSystem::System::remove
        
            typedef void ( ::SireSystem::System::*remove_function_type)( ::SireSystem::Constraints const & ) ;
            remove_function_type remove_function_value( &::SireSystem::System::remove );
            
            System_exposer.def( 
                "remove"
                , remove_function_value
                , ( bp::arg("constraints") )
                , bp::release_gil_policy()
                , "Remove the constraints in constraints from the list of constraints\nthat are applied to this system" );
        
        }
        { //::SireSystem::System::remove
        
            typedef bool ( ::SireSystem::System::*remove_function_type)( ::SireMol::MoleculeView const &,::SireMol::MGID const & ) ;
            remove_function_type remove_function_value( &::SireSystem::System::remove );
            
            System_exposer.def( 
                "remove"
                , remove_function_value
                , ( bp::arg("molview"), bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Remove the view molview from the specified groups in this\nforcefield. Note that this only removes the specific view\n(and indeed only the first copy of this view if there\nare duplicates) - it does not remove the atoms in this\nview from all of the other views\nThrow: SireMol::missing_group\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireSystem::System::remove
        
            typedef bool ( ::SireSystem::System::*remove_function_type)( ::SireMol::ViewsOfMol const &,::SireMol::MGID const & ) ;
            remove_function_type remove_function_value( &::SireSystem::System::remove );
            
            System_exposer.def( 
                "remove"
                , remove_function_value
                , ( bp::arg("molviews"), bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Remove the views in molviews from the specified groups in this\nforcefield. Note that this only removes the specific views\n(and indeed only the first copy of this view if there\nare duplicates) - it does not remove the atoms in this\nview from all of the other views\nThrow: SireMol::missing_group\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireSystem::System::remove
        
            typedef bool ( ::SireSystem::System::*remove_function_type)( ::SireMol::Molecules const &,::SireMol::MGID const & ) ;
            remove_function_type remove_function_value( &::SireSystem::System::remove );
            
            System_exposer.def( 
                "remove"
                , remove_function_value
                , ( bp::arg("molecules"), bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Remove them molecules in molecules from the specified groups in this\nforcefield. Note that this only removes the specific views\n(and indeed only the first copy of this view if there\nare duplicates) - it does not remove the atoms in this\nview from all of the other views\nThrow: SireMol::missing_group\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireSystem::System::remove
        
            typedef bool ( ::SireSystem::System::*remove_function_type)( ::SireMol::MoleculeGroup const &,::SireMol::MGID const & ) ;
            remove_function_type remove_function_value( &::SireSystem::System::remove );
            
            System_exposer.def( 
                "remove"
                , remove_function_value
                , ( bp::arg("molgroup"), bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Remove the views in the molecule group molgroup from the specified\ngroups in this forcefield. Note that this only removes the specific views\n(and indeed only the first copy of this view if there\nare duplicates) - it does not remove the atoms in this\nview from all of the other views\nThrow: SireMol::missing_group\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireSystem::System::remove
        
            typedef bool ( ::SireSystem::System::*remove_function_type)( ::SireMol::MolNum,::SireMol::MGID const & ) ;
            remove_function_type remove_function_value( &::SireSystem::System::remove );
            
            System_exposer.def( 
                "remove"
                , remove_function_value
                , ( bp::arg("molnum"), bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Remove all views of the molecule with number molnum from the molecule\ngroups identified by mgid\nThrow: SireMol::missing_group\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireSystem::System::remove
        
            typedef bool ( ::SireSystem::System::*remove_function_type)( ::QSet< SireMol::MolNum > const &,::SireMol::MGID const & ) ;
            remove_function_type remove_function_value( &::SireSystem::System::remove );
            
            System_exposer.def( 
                "remove"
                , remove_function_value
                , ( bp::arg("molnums"), bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Remove all of the molecules whose numbers are in molnums from\nall of the molecule groups identified by the ID mgid\nThrow: SireMol::missing_group\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireSystem::System::removeAll
        
            typedef bool ( ::SireSystem::System::*removeAll_function_type)( ::SireMol::MGID const & ) ;
            removeAll_function_type removeAll_function_value( &::SireSystem::System::removeAll );
            
            System_exposer.def( 
                "removeAll"
                , removeAll_function_value
                , ( bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Remove all molecules from the molecule groups identified by the ID mgid\nThrow: SireMol::missing_group\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireSystem::System::removeAll
        
            typedef bool ( ::SireSystem::System::*removeAll_function_type)( ::SireMol::MoleculeView const &,::SireMol::MGID const & ) ;
            removeAll_function_type removeAll_function_value( &::SireSystem::System::removeAll );
            
            System_exposer.def( 
                "removeAll"
                , removeAll_function_value
                , ( bp::arg("molview"), bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Remove the all copies of the view in molview from the specified\ngroups in this forcefield. Note that this only removes the specific views\n- it does not remove the atoms in this view from all of the other views\nThrow: SireMol::missing_group\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireSystem::System::removeAll
        
            typedef bool ( ::SireSystem::System::*removeAll_function_type)( ::SireMol::ViewsOfMol const &,::SireMol::MGID const & ) ;
            removeAll_function_type removeAll_function_value( &::SireSystem::System::removeAll );
            
            System_exposer.def( 
                "removeAll"
                , removeAll_function_value
                , ( bp::arg("molviews"), bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Remove the all copies of the views in molviews from the specified\ngroups in this forcefield. Note that this only removes the specific views\n- it does not remove the atoms in this view from all of the other views\nThrow: SireMol::missing_group\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireSystem::System::removeAll
        
            typedef bool ( ::SireSystem::System::*removeAll_function_type)( ::SireMol::Molecules const &,::SireMol::MGID const & ) ;
            removeAll_function_type removeAll_function_value( &::SireSystem::System::removeAll );
            
            System_exposer.def( 
                "removeAll"
                , removeAll_function_value
                , ( bp::arg("molecules"), bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Remove the all copies of the molecules in molecules from the specified\ngroups in this forcefield. Note that this only removes the specific views\n- it does not remove the atoms in this view from all of the other views\nThrow: SireMol::missing_group\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireSystem::System::removeAll
        
            typedef bool ( ::SireSystem::System::*removeAll_function_type)( ::SireMol::MoleculeGroup const &,::SireMol::MGID const & ) ;
            removeAll_function_type removeAll_function_value( &::SireSystem::System::removeAll );
            
            System_exposer.def( 
                "removeAll"
                , removeAll_function_value
                , ( bp::arg("molgroup"), bp::arg("mgid") )
                , bp::release_gil_policy()
                , "Remove the all copies of the molecules in the molecule group molgroup\nfrom the specified groups in this forcefield. Note that this only removes\nthe specific views - it does not remove the atoms in this view from all\nof the other views\nThrow: SireMol::missing_group\nThrow: SireError::invalid_index\n" );
        
        }
        { //::SireSystem::System::removeAllConstraints
        
            typedef void ( ::SireSystem::System::*removeAllConstraints_function_type)(  ) ;
            removeAllConstraints_function_type removeAllConstraints_function_value( &::SireSystem::System::removeAllConstraints );
            
            System_exposer.def( 
                "removeAllConstraints"
                , removeAllConstraints_function_value
                , bp::release_gil_policy()
                , "Remove all constraints from this system" );
        
        }
        { //::SireSystem::System::removeAllForceFields
        
            typedef void ( ::SireSystem::System::*removeAllForceFields_function_type)(  ) ;
            removeAllForceFields_function_type removeAllForceFields_function_value( &::SireSystem::System::removeAllForceFields );
            
            System_exposer.def( 
                "removeAllForceFields"
                , removeAllForceFields_function_value
                , bp::release_gil_policy()
                , "Completely remove all of the forcefields (and their contained\nmolecule groups) from this system" );
        
        }
        { //::SireSystem::System::removeAllMoleculeGroups
        
            typedef void ( ::SireSystem::System::*removeAllMoleculeGroups_function_type)(  ) ;
            removeAllMoleculeGroups_function_type removeAllMoleculeGroups_function_value( &::SireSystem::System::removeAllMoleculeGroups );
            
            System_exposer.def( 
                "removeAllMoleculeGroups"
                , removeAllMoleculeGroups_function_value
                , bp::release_gil_policy()
                , "Completely remove all non-forcefield molecule groups\nfrom this system" );
        
        }
        { //::SireSystem::System::removeAllMolecules
        
            typedef bool ( ::SireSystem::System::*removeAllMolecules_function_type)(  ) ;
            removeAllMolecules_function_type removeAllMolecules_function_value( &::SireSystem::System::removeAllMolecules );
            
            System_exposer.def( 
                "removeAllMolecules"
                , removeAllMolecules_function_value
                , bp::release_gil_policy()
                , "Completely remove all molecules from this system" );
        
        }
        { //::SireSystem::System::removeAllMonitors
        
            typedef void ( ::SireSystem::System::*removeAllMonitors_function_type)(  ) ;
            removeAllMonitors_function_type removeAllMonitors_function_value( &::SireSystem::System::removeAllMonitors );
            
            System_exposer.def( 
                "removeAllMonitors"
                , removeAllMonitors_function_value
                , bp::release_gil_policy()
                , "Completely remove all monitors from this system" );
        
        }
        { //::SireSystem::System::removeProperty
        
            typedef void ( ::SireSystem::System::*removeProperty_function_type)( ::QString const & ) ;
            removeProperty_function_type removeProperty_function_value( &::SireSystem::System::removeProperty );
            
            System_exposer.def( 
                "removeProperty"
                , removeProperty_function_value
                , ( bp::arg("name") )
                , bp::release_gil_policy()
                , "Remove the property with name name. Note that this can only\nremove user-level properties - it cannot remove built-in properties\nof the system. This does nothing if there is no user-level\nproperty with this name" );
        
        }
        { //::SireSystem::System::setComponent
        
            typedef void ( ::SireSystem::System::*setComponent_function_type)( ::SireCAS::Symbol const &,double ) ;
            setComponent_function_type setComponent_function_value( &::SireSystem::System::setComponent );
            
            System_exposer.def( 
                "setComponent"
                , setComponent_function_value
                , ( bp::arg("symbol"), bp::arg("value") )
                , bp::release_gil_policy()
                , "Synonym for System::setConstantComponent(symbol, value)" );
        
        }
        { //::SireSystem::System::setComponent
        
            typedef void ( ::SireSystem::System::*setComponent_function_type)( ::SireCAS::Symbol const &,::SireCAS::Expression const & ) ;
            setComponent_function_type setComponent_function_value( &::SireSystem::System::setComponent );
            
            System_exposer.def( 
                "setComponent"
                , setComponent_function_value
                , ( bp::arg("symbol"), bp::arg("expression") )
                , bp::release_gil_policy()
                , "Synonym for System::setEnergyComponent(symbol, expression)" );
        
        }
        { //::SireSystem::System::setConstant
        
            typedef void ( ::SireSystem::System::*setConstant_function_type)( ::SireCAS::Symbol const &,double ) ;
            setConstant_function_type setConstant_function_value( &::SireSystem::System::setConstant );
            
            System_exposer.def( 
                "setConstant"
                , setConstant_function_value
                , ( bp::arg("symbol"), bp::arg("value") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireSystem::System::setConstant
        
            typedef void ( ::SireSystem::System::*setConstant_function_type)( ::SireCAS::Symbol const &,::SireCAS::Expression const & ) ;
            setConstant_function_type setConstant_function_value( &::SireSystem::System::setConstant );
            
            System_exposer.def( 
                "setConstant"
                , setConstant_function_value
                , ( bp::arg("symbol"), bp::arg("expression") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireSystem::System::setConstantComponent
        
            typedef void ( ::SireSystem::System::*setConstantComponent_function_type)( ::SireCAS::Symbol const &,double ) ;
            setConstantComponent_function_type setConstantComponent_function_value( &::SireSystem::System::setConstantComponent );
            
            System_exposer.def( 
                "setConstantComponent"
                , setConstantComponent_function_value
                , ( bp::arg("symbol"), bp::arg("value") )
                , bp::release_gil_policy()
                , "Set the constant component symbol to the value value\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireSystem::System::setConstantComponent
        
            typedef void ( ::SireSystem::System::*setConstantComponent_function_type)( ::SireCAS::Symbol const &,::SireCAS::Expression const & ) ;
            setConstantComponent_function_type setConstantComponent_function_value( &::SireSystem::System::setConstantComponent );
            
            System_exposer.def( 
                "setConstantComponent"
                , setConstantComponent_function_value
                , ( bp::arg("symbol"), bp::arg("expression") )
                , bp::release_gil_policy()
                , "Set the constant component symbol to the expression\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireSystem::System::setConstraints
        
            typedef void ( ::SireSystem::System::*setConstraints_function_type)( ::SireSystem::Constraints const & ) ;
            setConstraints_function_type setConstraints_function_value( &::SireSystem::System::setConstraints );
            
            System_exposer.def( 
                "setConstraints"
                , setConstraints_function_value
                , ( bp::arg("constraints") )
                , bp::release_gil_policy()
                , "Set the constraints for the system equal to constraints" );
        
        }
        { //::SireSystem::System::setContents
        
            typedef void ( ::SireSystem::System::*setContents_function_type)( ::SireMol::MGID const &,::SireMol::MoleculeView const &,::SireBase::PropertyMap const & ) ;
            setContents_function_type setContents_function_value( &::SireSystem::System::setContents );
            
            System_exposer.def( 
                "setContents"
                , setContents_function_value
                , ( bp::arg("mgid"), bp::arg("molview"), bp::arg("map") )
                , bp::release_gil_policy()
                , "Set the contents of the molecule group(s) identified by the ID mgid\nso that they contain just the view of the molecule in molview.\nThe version of the molecule already present in this set is used if\nsuch a molecule already exists. The supplied property map\nis used to find the properties required by any forcefields\nthat this molecule may be added to.\nThrow: SireMol::missing_group\nThrow: SireBase::missing_property\nThrow: SireError::invalid_index\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireSystem::System::setContents
        
            typedef void ( ::SireSystem::System::*setContents_function_type)( ::SireMol::MGID const &,::SireMol::ViewsOfMol const &,::SireBase::PropertyMap const & ) ;
            setContents_function_type setContents_function_value( &::SireSystem::System::setContents );
            
            System_exposer.def( 
                "setContents"
                , setContents_function_value
                , ( bp::arg("mgid"), bp::arg("molviews"), bp::arg("map") )
                , bp::release_gil_policy()
                , "Set the contents of the molecule group(s) identified by the ID mgid\nso that they contain just the views of the molecule in molviews.\nThe version of the molecule already present in this set is used if\nsuch a molecule already exists. The supplied property map\nis used to find the properties required by any forcefields\nthat this molecule may be added to.\nThrow: SireMol::missing_group\nThrow: SireBase::missing_property\nThrow: SireError::invalid_index\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireSystem::System::setContents
        
            typedef void ( ::SireSystem::System::*setContents_function_type)( ::SireMol::MGID const &,::SireMol::Molecules const &,::SireBase::PropertyMap const & ) ;
            setContents_function_type setContents_function_value( &::SireSystem::System::setContents );
            
            System_exposer.def( 
                "setContents"
                , setContents_function_value
                , ( bp::arg("mgid"), bp::arg("molecules"), bp::arg("map") )
                , bp::release_gil_policy()
                , "Set the contents of the molecule group(s) identified by the ID mgid\nso that they contain just the views of the molecules in molecules.\nThe version of the molecule already present in this set is used if\nsuch a molecule already exists. The supplied property map\nis used to find the properties required by any forcefields\nthat this molecule may be added to.\nThrow: SireMol::missing_group\nThrow: SireBase::missing_property\nThrow: SireError::invalid_index\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireSystem::System::setContents
        
            typedef void ( ::SireSystem::System::*setContents_function_type)( ::SireMol::MGID const &,::SireMol::MoleculeGroup const &,::SireBase::PropertyMap const & ) ;
            setContents_function_type setContents_function_value( &::SireSystem::System::setContents );
            
            System_exposer.def( 
                "setContents"
                , setContents_function_value
                , ( bp::arg("mgid"), bp::arg("molgroup"), bp::arg("map") )
                , bp::release_gil_policy()
                , "Set the contents of the molecule group(s) identified by the ID mgid\nso that they contain just the molecules in the group molgroup.\nThe version of the molecule already present in this set is used if\nsuch a molecule already exists. The supplied property map\nis used to find the properties required by any forcefields\nthat this molecule may be added to.\nThrow: SireMol::missing_group\nThrow: SireBase::missing_property\nThrow: SireError::invalid_index\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireSystem::System::setContents
        
            typedef void ( ::SireSystem::System::*setContents_function_type)( ::SireMol::MGID const &,::SireMol::MoleculeView const & ) ;
            setContents_function_type setContents_function_value( &::SireSystem::System::setContents );
            
            System_exposer.def( 
                "setContents"
                , setContents_function_value
                , ( bp::arg("mgid"), bp::arg("molview") )
                , bp::release_gil_policy()
                , "Convenient overload of System::setContents that uses the default\nproperty locations to find the properties required by the forcefields\nThrow: SireMol::missing_group\nThrow: SireBase::missing_property\nThrow: SireError::invalid_index\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireSystem::System::setContents
        
            typedef void ( ::SireSystem::System::*setContents_function_type)( ::SireMol::MGID const &,::SireMol::ViewsOfMol const & ) ;
            setContents_function_type setContents_function_value( &::SireSystem::System::setContents );
            
            System_exposer.def( 
                "setContents"
                , setContents_function_value
                , ( bp::arg("mgid"), bp::arg("molviews") )
                , bp::release_gil_policy()
                , "Convenient overload of System::setContents that uses the default\nproperty locations to find the properties required by the forcefields\nThrow: SireMol::missing_group\nThrow: SireBase::missing_property\nThrow: SireError::invalid_index\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireSystem::System::setContents
        
            typedef void ( ::SireSystem::System::*setContents_function_type)( ::SireMol::MGID const &,::SireMol::Molecules const & ) ;
            setContents_function_type setContents_function_value( &::SireSystem::System::setContents );
            
            System_exposer.def( 
                "setContents"
                , setContents_function_value
                , ( bp::arg("mgid"), bp::arg("molecules") )
                , bp::release_gil_policy()
                , "Convenient overload of System::setContents that uses the default\nproperty locations to find the properties required by the forcefields\nThrow: SireMol::missing_group\nThrow: SireBase::missing_property\nThrow: SireError::invalid_index\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireSystem::System::setContents
        
            typedef void ( ::SireSystem::System::*setContents_function_type)( ::SireMol::MGID const &,::SireMol::MoleculeGroup const & ) ;
            setContents_function_type setContents_function_value( &::SireSystem::System::setContents );
            
            System_exposer.def( 
                "setContents"
                , setContents_function_value
                , ( bp::arg("mgid"), bp::arg("molgroup") )
                , bp::release_gil_policy()
                , "Convenient overload of System::setContents that uses the default\nproperty locations to find the properties required by the forcefields\nThrow: SireMol::missing_group\nThrow: SireBase::missing_property\nThrow: SireError::invalid_index\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireSystem::System::setEnergyComponent
        
            typedef void ( ::SireSystem::System::*setEnergyComponent_function_type)( ::SireCAS::Symbol const &,::SireCAS::Expression const & ) ;
            setEnergyComponent_function_type setEnergyComponent_function_value( &::SireSystem::System::setEnergyComponent );
            
            System_exposer.def( 
                "setEnergyComponent"
                , setEnergyComponent_function_value
                , ( bp::arg("symbol"), bp::arg("expression") )
                , bp::release_gil_policy()
                , "Set the energy component symbol equal to the expression expression" );
        
        }
        { //::SireSystem::System::setMonitors
        
            typedef void ( ::SireSystem::System::*setMonitors_function_type)( ::SireSystem::SystemMonitors const & ) ;
            setMonitors_function_type setMonitors_function_value( &::SireSystem::System::setMonitors );
            
            System_exposer.def( 
                "setMonitors"
                , setMonitors_function_value
                , ( bp::arg("monitors") )
                , bp::release_gil_policy()
                , "Set the monitors of this system to monitors" );
        
        }
        { //::SireSystem::System::setMonitors
        
            typedef void ( ::SireSystem::System::*setMonitors_function_type)( ::SireSystem::SystemMonitors const &,int ) ;
            setMonitors_function_type setMonitors_function_value( &::SireSystem::System::setMonitors );
            
            System_exposer.def( 
                "setMonitors"
                , setMonitors_function_value
                , ( bp::arg("monitors"), bp::arg("frequency") )
                , bp::release_gil_policy()
                , "Set the monitors of the system to monitors, and reset the\nfrequency of all of the monitors so that they are triggered\nevery frequency steps" );
        
        }
        { //::SireSystem::System::setName
        
            typedef void ( ::SireSystem::System::*setName_function_type)( ::SireSystem::SysName const & ) ;
            setName_function_type setName_function_value( &::SireSystem::System::setName );
            
            System_exposer.def( 
                "setName"
                , setName_function_value
                , ( bp::arg("newname") )
                , bp::release_gil_policy()
                , "Set the name of this system" );
        
        }
        { //::SireSystem::System::setName
        
            typedef void ( ::SireSystem::System::*setName_function_type)( ::QString const & ) ;
            setName_function_type setName_function_value( &::SireSystem::System::setName );
            
            System_exposer.def( 
                "setName"
                , setName_function_value
                , ( bp::arg("newname") )
                , bp::release_gil_policy()
                , "Set the name of this system" );
        
        }
        { //::SireSystem::System::setProperty
        
            typedef void ( ::SireSystem::System::*setProperty_function_type)( ::QString const &,::SireBase::Property const & ) ;
            setProperty_function_type setProperty_function_value( &::SireSystem::System::setProperty );
            
            System_exposer.def( 
                "setProperty"
                , setProperty_function_value
                , ( bp::arg("name"), bp::arg("value") )
                , bp::release_gil_policy()
                , "Set the value of the property called name to the value value in\nall forcefields that have this property\nThrow: SireBase::missing_property\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireSystem::System::setProperty
        
            typedef void ( ::SireSystem::System::*setProperty_function_type)( ::SireFF::FFID const &,::QString const &,::SireBase::Property const & ) ;
            setProperty_function_type setProperty_function_value( &::SireSystem::System::setProperty );
            
            System_exposer.def( 
                "setProperty"
                , setProperty_function_value
                , ( bp::arg("ffid"), bp::arg("name"), bp::arg("value") )
                , bp::release_gil_policy()
                , "Set the value of the property called name in the forcefields identified\nby the ID ffid to the value value\nThrow: SireBase::missing_property\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireSystem::System::subVersion
        
            typedef ::quint32 ( ::SireSystem::System::*subVersion_function_type)(  ) const;
            subVersion_function_type subVersion_function_value( &::SireSystem::System::subVersion );
            
            System_exposer.def( 
                "subVersion"
                , subVersion_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireSystem::System::toString
        
            typedef ::QString ( ::SireSystem::System::*toString_function_type)(  ) const;
            toString_function_type toString_function_value( &::SireSystem::System::toString );
            
            System_exposer.def( 
                "toString"
                , toString_function_value
                , bp::release_gil_policy()
                , "Return a string representation of this system" );
        
        }
        { //::SireSystem::System::totalComponent
        
            typedef ::SireCAS::Symbol const & ( ::SireSystem::System::*totalComponent_function_type)(  ) const;
            totalComponent_function_type totalComponent_function_value( &::SireSystem::System::totalComponent );
            
            System_exposer.def( 
                "totalComponent"
                , totalComponent_function_value
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Return the symbol that represents the total energy component\nof the system" );
        
        }
        { //::SireSystem::System::typeName
        
            typedef char const * ( *typeName_function_type )(  );
            typeName_function_type typeName_function_value( &::SireSystem::System::typeName );
            
            System_exposer.def( 
                "typeName"
                , typeName_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireSystem::System::update
        
            typedef void ( ::SireSystem::System::*update_function_type)( ::SireMol::MoleculeData const &,bool ) ;
            update_function_type update_function_value( &::SireSystem::System::update );
            
            System_exposer.def( 
                "update"
                , update_function_value
                , ( bp::arg("moldata"), bp::arg("auto_commit")=(bool)(true) )
                , "Update this system so that it uses the version of the molecule\navailable in moldata\nThrow: SireBase::missing_property\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireSystem::System::update
        
            typedef void ( ::SireSystem::System::*update_function_type)( ::SireMol::Molecules const &,bool ) ;
            update_function_type update_function_value( &::SireSystem::System::update );
            
            System_exposer.def( 
                "update"
                , update_function_value
                , ( bp::arg("molecules"), bp::arg("auto_commit")=(bool)(true) )
                , "Update this system so that it uses the same version of the molecules\npresent in molecules\nThrow: SireBase::missing_property\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireSystem::System::update
        
            typedef void ( ::SireSystem::System::*update_function_type)( ::SireMol::MoleculeGroup const &,bool ) ;
            update_function_type update_function_value( &::SireSystem::System::update );
            
            System_exposer.def( 
                "update"
                , update_function_value
                , ( bp::arg("molgroup"), bp::arg("auto_commit")=(bool)(true) )
                , "Update this system so that it uses the same version of the molecules\npresent in the molecule group molgroup\nThrow: SireBase::missing_property\nThrow: SireError::invalid_cast\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireSystem::System::userProperties
        
            typedef ::SireBase::Properties ( ::SireSystem::System::*userProperties_function_type)(  ) const;
            userProperties_function_type userProperties_function_value( &::SireSystem::System::userProperties );
            
            System_exposer.def( 
                "userProperties"
                , userProperties_function_value
                , bp::release_gil_policy()
                , "Return the values of all user-level properties of this\nsystem" );
        
        }
        { //::SireSystem::System::userProperty
        
            typedef ::SireBase::Property const & ( ::SireSystem::System::*userProperty_function_type)( ::QString const & ) const;
            userProperty_function_type userProperty_function_value( &::SireSystem::System::userProperty );
            
            System_exposer.def( 
                "userProperty"
                , userProperty_function_value
                , ( bp::arg("name") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "Return the user-supplied property at name. This raises an\nexception if there is no user-supplied property with this name\nThrow: SireBase::missing_property\n" );
        
        }
        { //::SireSystem::System::version
        
            typedef ::SireBase::Version const & ( ::SireSystem::System::*version_function_type)(  ) const;
            version_function_type version_function_value( &::SireSystem::System::version );
            
            System_exposer.def( 
                "version"
                , version_function_value
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "" );
        
        }
        System_exposer.staticmethod( "null" );
        System_exposer.staticmethod( "typeName" );
        System_exposer.def( "__copy__", &__copy__);
        System_exposer.def( "__deepcopy__", &__copy__);
        System_exposer.def( "clone", &__copy__);
        System_exposer.def( "__rlshift__", &__rlshift__QDataStream< ::SireSystem::System >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        System_exposer.def( "__rrshift__", &__rrshift__QDataStream< ::SireSystem::System >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        System_exposer.def_pickle(sire_pickle_suite< ::SireSystem::System >());
        System_exposer.def( "__str__", &__str__< ::SireSystem::System > );
        System_exposer.def( "__repr__", &__str__< ::SireSystem::System > );
        System_exposer.def( "__len__", &__len_count< ::SireSystem::System > );
    }

}
