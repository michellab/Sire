// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 2 License

#include "boost/python.hpp"
#include "FreeEnergyMonitor.pypp.hpp"

namespace bp = boost::python;

#include "SireError/errors.h"

#include "SireMM/atomljs.h"

#include "SireMM/cljatoms.h"

#include "SireMM/cljshiftfunction.h"

#include "SireMM/ljpair.h"

#include "SireMol/atomcharges.h"

#include "SireMol/atomcoords.h"

#include "SireMol/mgname.h"

#include "SireMol/partialmolecule.h"

#include "SireStream/datastream.h"

#include "SireStream/shareddatastream.h"

#include "SireSystem/freeenergymonitor.h"

#include "SireSystem/system.h"

#include "SireUnits/units.h"

#include "freeenergymonitor.h"

#include <QTime>

#include "freeenergymonitor.h"

SireSystem::FreeEnergyMonitor __copy__(const SireSystem::FreeEnergyMonitor &other){ return SireSystem::FreeEnergyMonitor(other); }

#include "Qt/qdatastream.hpp"

#include "Helpers/str.hpp"

#include "Helpers/release_gil_policy.hpp"

void register_FreeEnergyMonitor_class(){

    { //::SireSystem::FreeEnergyMonitor
        typedef bp::class_< SireSystem::FreeEnergyMonitor, bp::bases< SireSystem::SystemMonitor, SireBase::Property > > FreeEnergyMonitor_exposer_t;
        FreeEnergyMonitor_exposer_t FreeEnergyMonitor_exposer = FreeEnergyMonitor_exposer_t( "FreeEnergyMonitor", "This monitor is used to monitor the free energy difference of two\nmolecule groups against every molecule view in the third.\nThis uses dual topology to calculate\nthe free energy difference between the interaction of each view in the\nreference molecule group, and the group A and group B groups. This is intended\nto complement free energy calculations by letting you decompose\nthe free energy difference into per-residue components. The coulomb\nand LJ components are also separately calculated and accumulated.\n\nAuthor: Christopher Woods\n", bp::init< >("Null constructor. By default, we dont collect a histogram of each of\nthe components energies as this is too memory hungry") );
        bp::scope FreeEnergyMonitor_scope( FreeEnergyMonitor_exposer );
        FreeEnergyMonitor_exposer.def( bp::init< SireSystem::AssignerGroup const &, SireSystem::AssignerGroup const &, SireSystem::AssignerGroup const & >(( bp::arg("reference"), bp::arg("groupA"), bp::arg("groupB") ), "Construct to monitor the free energy difference of the reference group\ninteracting with group A as it is perturbed into group B. By default,\nwe dont collect a histogram of each of the components energies as this\nis too memory hungry") );
        FreeEnergyMonitor_exposer.def( bp::init< SireSystem::FreeEnergyMonitor const & >(( bp::arg("other") ), "Copy constructor") );
        { //::SireSystem::FreeEnergyMonitor::binWidth
        
            typedef ::SireUnits::Dimension::MolarEnergy ( ::SireSystem::FreeEnergyMonitor::*binWidth_function_type)(  ) const;
            binWidth_function_type binWidth_function_value( &::SireSystem::FreeEnergyMonitor::binWidth );
            
            FreeEnergyMonitor_exposer.def( 
                "binWidth"
                , binWidth_function_value
                , bp::release_gil_policy()
                , "Return the width of the histogram bins used to record the free energies" );
        
        }
        { //::SireSystem::FreeEnergyMonitor::clearStatistics
        
            typedef void ( ::SireSystem::FreeEnergyMonitor::*clearStatistics_function_type)(  ) ;
            clearStatistics_function_type clearStatistics_function_value( &::SireSystem::FreeEnergyMonitor::clearStatistics );
            
            FreeEnergyMonitor_exposer.def( 
                "clearStatistics"
                , clearStatistics_function_value
                , bp::release_gil_policy()
                , "Clear all statistics" );
        
        }
        { //::SireSystem::FreeEnergyMonitor::conserveMemory
        
            typedef void ( ::SireSystem::FreeEnergyMonitor::*conserveMemory_function_type)( ::SireSystem::FreeEnergyMonitor const & ) ;
            conserveMemory_function_type conserveMemory_function_value( &::SireSystem::FreeEnergyMonitor::conserveMemory );
            
            FreeEnergyMonitor_exposer.def( 
                "conserveMemory"
                , conserveMemory_function_value
                , ( bp::arg("other") )
                , bp::release_gil_policy()
                , "Conserve memory by copying the molecule data etc. from other into this monitor" );
        
        }
        { //::SireSystem::FreeEnergyMonitor::coulombFreeEnergies
        
            typedef ::QVector< SireMaths::FreeEnergyAverage > ( ::SireSystem::FreeEnergyMonitor::*coulombFreeEnergies_function_type)(  ) const;
            coulombFreeEnergies_function_type coulombFreeEnergies_function_value( &::SireSystem::FreeEnergyMonitor::coulombFreeEnergies );
            
            FreeEnergyMonitor_exposer.def( 
                "coulombFreeEnergies"
                , coulombFreeEnergies_function_value
                , bp::release_gil_policy()
                , "Return the array of all accumulated coulomb free energies" );
        
        }
        { //::SireSystem::FreeEnergyMonitor::coulombPower
        
            typedef int ( ::SireSystem::FreeEnergyMonitor::*coulombPower_function_type)(  ) const;
            coulombPower_function_type coulombPower_function_value( &::SireSystem::FreeEnergyMonitor::coulombPower );
            
            FreeEnergyMonitor_exposer.def( 
                "coulombPower"
                , coulombPower_function_value
                , bp::release_gil_policy()
                , "Return the coulomb power, if extra coulomb softening is used.\nThis returns 0 if coulomb softening is not used" );
        
        }
        { //::SireSystem::FreeEnergyMonitor::deltaLambda
        
            typedef double ( ::SireSystem::FreeEnergyMonitor::*deltaLambda_function_type)(  ) const;
            deltaLambda_function_type deltaLambda_function_value( &::SireSystem::FreeEnergyMonitor::deltaLambda );
            
            FreeEnergyMonitor_exposer.def( 
                "deltaLambda"
                , deltaLambda_function_value
                , bp::release_gil_policy()
                , "Return the value of delta lambda used to calculate the free energy gradients" );
        
        }
        { //::SireSystem::FreeEnergyMonitor::freeEnergies
        
            typedef ::QVector< SireMaths::FreeEnergyAverage > ( ::SireSystem::FreeEnergyMonitor::*freeEnergies_function_type)(  ) const;
            freeEnergies_function_type freeEnergies_function_value( &::SireSystem::FreeEnergyMonitor::freeEnergies );
            
            FreeEnergyMonitor_exposer.def( 
                "freeEnergies"
                , freeEnergies_function_value
                , bp::release_gil_policy()
                , "Return the array of all accumulated total free energies" );
        
        }
        { //::SireSystem::FreeEnergyMonitor::groupA
        
            typedef ::SireSystem::AssignerGroup const & ( ::SireSystem::FreeEnergyMonitor::*groupA_function_type)(  ) const;
            groupA_function_type groupA_function_value( &::SireSystem::FreeEnergyMonitor::groupA );
            
            FreeEnergyMonitor_exposer.def( 
                "groupA"
                , groupA_function_value
                , bp::return_value_policy< bp::copy_const_reference >()
                , "Return group A (the group interacting with the reference group at lambda = 0)" );
        
        }
        { //::SireSystem::FreeEnergyMonitor::groupB
        
            typedef ::SireSystem::AssignerGroup const & ( ::SireSystem::FreeEnergyMonitor::*groupB_function_type)(  ) const;
            groupB_function_type groupB_function_value( &::SireSystem::FreeEnergyMonitor::groupB );
            
            FreeEnergyMonitor_exposer.def( 
                "groupB"
                , groupB_function_value
                , bp::return_value_policy< bp::copy_const_reference >()
                , "Return group B (the group interacting with the reference group at lambda = 1)" );
        
        }
        { //::SireSystem::FreeEnergyMonitor::isCompatible
        
            typedef bool ( ::SireSystem::FreeEnergyMonitor::*isCompatible_function_type)( ::SireSystem::FreeEnergyMonitor const & ) const;
            isCompatible_function_type isCompatible_function_value( &::SireSystem::FreeEnergyMonitor::isCompatible );
            
            FreeEnergyMonitor_exposer.def( 
                "isCompatible"
                , isCompatible_function_value
                , ( bp::arg("other") )
                , bp::release_gil_policy()
                , "Return whether or not this monitor is compatible with other\n(have the same groups, soft-core parameters, delta lambda, temperature etc.)" );
        
        }
        { //::SireSystem::FreeEnergyMonitor::isCompatibleExceptLambda
        
            typedef bool ( ::SireSystem::FreeEnergyMonitor::*isCompatibleExceptLambda_function_type)( ::SireSystem::FreeEnergyMonitor const & ) const;
            isCompatibleExceptLambda_function_type isCompatibleExceptLambda_function_value( &::SireSystem::FreeEnergyMonitor::isCompatibleExceptLambda );
            
            FreeEnergyMonitor_exposer.def( 
                "isCompatibleExceptLambda"
                , isCompatibleExceptLambda_function_value
                , ( bp::arg("other") )
                , bp::release_gil_policy()
                , "Return whether or not this monitor is compatible with other, ignoring that\nthe monitors have different lambda values. This will let you know if it is sensible\nto construct PMFs from a combination of these monitors" );
        
        }
        { //::SireSystem::FreeEnergyMonitor::isEmpty
        
            typedef bool ( ::SireSystem::FreeEnergyMonitor::*isEmpty_function_type)(  ) const;
            isEmpty_function_type isEmpty_function_value( &::SireSystem::FreeEnergyMonitor::isEmpty );
            
            FreeEnergyMonitor_exposer.def( 
                "isEmpty"
                , isEmpty_function_value
                , bp::release_gil_policy()
                , "Return whether this is empty (has no group data)" );
        
        }
        { //::SireSystem::FreeEnergyMonitor::lambdaComponent
        
            typedef ::SireCAS::Symbol ( ::SireSystem::FreeEnergyMonitor::*lambdaComponent_function_type)(  ) const;
            lambdaComponent_function_type lambdaComponent_function_value( &::SireSystem::FreeEnergyMonitor::lambdaComponent );
            
            FreeEnergyMonitor_exposer.def( 
                "lambdaComponent"
                , lambdaComponent_function_value
                , bp::release_gil_policy()
                , "Return the symbol used to find the value of lambda from the system" );
        
        }
        { //::SireSystem::FreeEnergyMonitor::lambdaValue
        
            typedef double ( ::SireSystem::FreeEnergyMonitor::*lambdaValue_function_type)(  ) const;
            lambdaValue_function_type lambdaValue_function_value( &::SireSystem::FreeEnergyMonitor::lambdaValue );
            
            FreeEnergyMonitor_exposer.def( 
                "lambdaValue"
                , lambdaValue_function_value
                , bp::release_gil_policy()
                , "Return the lambda value at which the free energy components were collected" );
        
        }
        { //::SireSystem::FreeEnergyMonitor::ljFreeEnergies
        
            typedef ::QVector< SireMaths::FreeEnergyAverage > ( ::SireSystem::FreeEnergyMonitor::*ljFreeEnergies_function_type)(  ) const;
            ljFreeEnergies_function_type ljFreeEnergies_function_value( &::SireSystem::FreeEnergyMonitor::ljFreeEnergies );
            
            FreeEnergyMonitor_exposer.def( 
                "ljFreeEnergies"
                , ljFreeEnergies_function_value
                , bp::release_gil_policy()
                , "Return the array of all accumulated LJ free energies" );
        
        }
        { //::SireSystem::FreeEnergyMonitor::merge
        
            typedef ::SireSystem::FreeEnergyMonitor ( *merge_function_type )( ::QList< SireSystem::FreeEnergyMonitor > const & );
            merge_function_type merge_function_value( &::SireSystem::FreeEnergyMonitor::merge );
            
            FreeEnergyMonitor_exposer.def( 
                "merge"
                , merge_function_value
                , ( bp::arg("monitors") )
                , bp::release_gil_policy()
                , "Merge a whole set of free energy monitors together. Note that you can\nonly merge them if they have the same groups, soft-core parameters, delta lambda,\ntemperature etc.\nThrow: SireError::incompatible_error\n" );
        
        }
        { //::SireSystem::FreeEnergyMonitor::monitor
        
            typedef void ( ::SireSystem::FreeEnergyMonitor::*monitor_function_type)( ::SireSystem::System & ) ;
            monitor_function_type monitor_function_value( &::SireSystem::FreeEnergyMonitor::monitor );
            
            FreeEnergyMonitor_exposer.def( 
                "monitor"
                , monitor_function_value
                , ( bp::arg("system") )
                , bp::release_gil_policy()
                , "Accumulate energies from the passed system" );
        
        }
        { //::SireSystem::FreeEnergyMonitor::nSamples
        
            typedef int ( ::SireSystem::FreeEnergyMonitor::*nSamples_function_type)(  ) const;
            nSamples_function_type nSamples_function_value( &::SireSystem::FreeEnergyMonitor::nSamples );
            
            FreeEnergyMonitor_exposer.def( 
                "nSamples"
                , nSamples_function_value
                , bp::release_gil_policy()
                , "Return the number of samples used to form all of the free energy averages\nin this monitor" );
        
        }
        FreeEnergyMonitor_exposer.def( bp::self != bp::self );
        FreeEnergyMonitor_exposer.def( bp::self + bp::self );
        { //::SireSystem::FreeEnergyMonitor::operator=
        
            typedef ::SireSystem::FreeEnergyMonitor & ( ::SireSystem::FreeEnergyMonitor::*assign_function_type)( ::SireSystem::FreeEnergyMonitor const & ) ;
            assign_function_type assign_function_value( &::SireSystem::FreeEnergyMonitor::operator= );
            
            FreeEnergyMonitor_exposer.def( 
                "assign"
                , assign_function_value
                , ( bp::arg("other") )
                , bp::return_self< >()
                , "" );
        
        }
        FreeEnergyMonitor_exposer.def( bp::self == bp::self );
        { //::SireSystem::FreeEnergyMonitor::referenceGroup
        
            typedef ::SireSystem::AssignerGroup const & ( ::SireSystem::FreeEnergyMonitor::*referenceGroup_function_type)(  ) const;
            referenceGroup_function_type referenceGroup_function_value( &::SireSystem::FreeEnergyMonitor::referenceGroup );
            
            FreeEnergyMonitor_exposer.def( 
                "referenceGroup"
                , referenceGroup_function_value
                , bp::return_value_policy< bp::copy_const_reference >()
                , "Return the reference group" );
        
        }
        { //::SireSystem::FreeEnergyMonitor::referenceViews
        
            typedef ::QVector< SireMol::PartialMolecule > ( ::SireSystem::FreeEnergyMonitor::*referenceViews_function_type)(  ) const;
            referenceViews_function_type referenceViews_function_value( &::SireSystem::FreeEnergyMonitor::referenceViews );
            
            FreeEnergyMonitor_exposer.def( 
                "referenceViews"
                , referenceViews_function_value
                , bp::release_gil_policy()
                , "Return the array of the reference group molecule views in the same order as they\nappear in the arrays of free energies" );
        
        }
        { //::SireSystem::FreeEnergyMonitor::setBinWidth
        
            typedef void ( ::SireSystem::FreeEnergyMonitor::*setBinWidth_function_type)( ::SireUnits::Dimension::MolarEnergy const & ) ;
            setBinWidth_function_type setBinWidth_function_value( &::SireSystem::FreeEnergyMonitor::setBinWidth );
            
            FreeEnergyMonitor_exposer.def( 
                "setBinWidth"
                , setBinWidth_function_value
                , ( bp::arg("binwidth") )
                , bp::release_gil_policy()
                , "Set the bin width for the histogram of recorded free energies.\nBy default, we dont collect a histogram of each of the components energies\nas this is too memory hungry." );
        
        }
        { //::SireSystem::FreeEnergyMonitor::setCoulombPower
        
            typedef void ( ::SireSystem::FreeEnergyMonitor::*setCoulombPower_function_type)( int ) ;
            setCoulombPower_function_type setCoulombPower_function_value( &::SireSystem::FreeEnergyMonitor::setCoulombPower );
            
            FreeEnergyMonitor_exposer.def( 
                "setCoulombPower"
                , setCoulombPower_function_value
                , ( bp::arg("power") )
                , bp::release_gil_policy()
                , "Set the coulomb power parameter used by the soft-core potential" );
        
        }
        { //::SireSystem::FreeEnergyMonitor::setDeltaLambda
        
            typedef void ( ::SireSystem::FreeEnergyMonitor::*setDeltaLambda_function_type)( double ) ;
            setDeltaLambda_function_type setDeltaLambda_function_value( &::SireSystem::FreeEnergyMonitor::setDeltaLambda );
            
            FreeEnergyMonitor_exposer.def( 
                "setDeltaLambda"
                , setDeltaLambda_function_value
                , ( bp::arg("delta_lam") )
                , bp::release_gil_policy()
                , "Set the value of delta lambda to use to calculate the free energy gradients" );
        
        }
        { //::SireSystem::FreeEnergyMonitor::setLambdaComponent
        
            typedef void ( ::SireSystem::FreeEnergyMonitor::*setLambdaComponent_function_type)( ::SireCAS::Symbol const & ) ;
            setLambdaComponent_function_type setLambdaComponent_function_value( &::SireSystem::FreeEnergyMonitor::setLambdaComponent );
            
            FreeEnergyMonitor_exposer.def( 
                "setLambdaComponent"
                , setLambdaComponent_function_value
                , ( bp::arg("component") )
                , bp::release_gil_policy()
                , "Set the system component symbol used to get the value of lambda" );
        
        }
        { //::SireSystem::FreeEnergyMonitor::setShiftDelta
        
            typedef void ( ::SireSystem::FreeEnergyMonitor::*setShiftDelta_function_type)( double ) ;
            setShiftDelta_function_type setShiftDelta_function_value( &::SireSystem::FreeEnergyMonitor::setShiftDelta );
            
            FreeEnergyMonitor_exposer.def( 
                "setShiftDelta"
                , setShiftDelta_function_value
                , ( bp::arg("delta") )
                , bp::release_gil_policy()
                , "Set the shift delta parameter used by the soft-core potential" );
        
        }
        { //::SireSystem::FreeEnergyMonitor::setTemperature
        
            typedef void ( ::SireSystem::FreeEnergyMonitor::*setTemperature_function_type)( ::SireUnits::Dimension::Temperature const & ) ;
            setTemperature_function_type setTemperature_function_value( &::SireSystem::FreeEnergyMonitor::setTemperature );
            
            FreeEnergyMonitor_exposer.def( 
                "setTemperature"
                , setTemperature_function_value
                , ( bp::arg("temperature") )
                , bp::release_gil_policy()
                , "Set the temperature at which the free energies are accumulated" );
        
        }
        { //::SireSystem::FreeEnergyMonitor::shiftDelta
        
            typedef double ( ::SireSystem::FreeEnergyMonitor::*shiftDelta_function_type)(  ) const;
            shiftDelta_function_type shiftDelta_function_value( &::SireSystem::FreeEnergyMonitor::shiftDelta );
            
            FreeEnergyMonitor_exposer.def( 
                "shiftDelta"
                , shiftDelta_function_value
                , bp::release_gil_policy()
                , "Return the shift delta parameter if a soft-core potential is used.\nThis returns 0 if a LJ shifting term is not used" );
        
        }
        { //::SireSystem::FreeEnergyMonitor::temperature
        
            typedef ::SireUnits::Dimension::Temperature ( ::SireSystem::FreeEnergyMonitor::*temperature_function_type)(  ) const;
            temperature_function_type temperature_function_value( &::SireSystem::FreeEnergyMonitor::temperature );
            
            FreeEnergyMonitor_exposer.def( 
                "temperature"
                , temperature_function_value
                , bp::release_gil_policy()
                , "Return the temperature at which the free energies are calculated" );
        
        }
        { //::SireSystem::FreeEnergyMonitor::typeName
        
            typedef char const * ( *typeName_function_type )(  );
            typeName_function_type typeName_function_value( &::SireSystem::FreeEnergyMonitor::typeName );
            
            FreeEnergyMonitor_exposer.def( 
                "typeName"
                , typeName_function_value
                , bp::release_gil_policy()
                , "Return the typename of the class" );
        
        }
        { //::SireSystem::FreeEnergyMonitor::usesSoftCore
        
            typedef bool ( ::SireSystem::FreeEnergyMonitor::*usesSoftCore_function_type)(  ) const;
            usesSoftCore_function_type usesSoftCore_function_value( &::SireSystem::FreeEnergyMonitor::usesSoftCore );
            
            FreeEnergyMonitor_exposer.def( 
                "usesSoftCore"
                , usesSoftCore_function_value
                , bp::release_gil_policy()
                , "Return whether or not this monitor uses a soft-core potential to\ncalculate the CLJ energy between the molecules in views0() and the\nmolecules in views1()" );
        
        }
        FreeEnergyMonitor_exposer.staticmethod( "merge" );
        FreeEnergyMonitor_exposer.staticmethod( "typeName" );
        FreeEnergyMonitor_exposer.def( "__copy__", &__copy__);
        FreeEnergyMonitor_exposer.def( "__deepcopy__", &__copy__);
        FreeEnergyMonitor_exposer.def( "clone", &__copy__);
        FreeEnergyMonitor_exposer.def( "__rlshift__", &__rlshift__QDataStream< ::SireSystem::FreeEnergyMonitor >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        FreeEnergyMonitor_exposer.def( "__rrshift__", &__rrshift__QDataStream< ::SireSystem::FreeEnergyMonitor >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        FreeEnergyMonitor_exposer.def_pickle(sire_pickle_suite< ::SireSystem::FreeEnergyMonitor >());
        FreeEnergyMonitor_exposer.def( "__str__", &__str__< ::SireSystem::FreeEnergyMonitor > );
        FreeEnergyMonitor_exposer.def( "__repr__", &__str__< ::SireSystem::FreeEnergyMonitor > );
    }

}
